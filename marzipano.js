(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Marzipano = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(name, definition)
  else root[name] = definition()
}(this, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)(o|0)s/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    } else if (/opr\/|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/Whale/i.test(ua)) {
      result = {
        name: 'NAVER Whale browser'
        , whale: t
        , version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/MZBrowser/i.test(ua)) {
      result = {
        name: 'MZ Browser'
        , mzbrowser: t
        , version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/focus/i.test(ua)) {
      result = {
        name: 'Focus'
        , focus: t
        , version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , osname: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , osname: 'Chrome OS'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/edg([ea]|ios)/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , osname: 'Sailfish OS'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
        result.osname = 'Firefox OS'
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , osname: 'BlackBerry OS'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , osname: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , osname: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , osname: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && (android || result.silk)) {
      result.android = t
      result.osname = 'Android'
    } else if (!result.windowsphone && iosdevice) {
      result[iosdevice] = t
      result.ios = t
      result.osname = 'iOS'
    } else if (mac) {
      result.mac = t
      result.osname = 'macOS'
    } else if (xbox) {
      result.xbox = t
      result.osname = 'Xbox'
    } else if (windows) {
      result.windows = t
      result.osname = 'Windows'
    } else if (linux) {
      result.linux = t
      result.osname = 'Linux'
    }

    function getWindowsVersion (s) {
      switch (s) {
        case 'NT': return 'NT'
        case 'XP': return 'XP'
        case 'NT 5.0': return '2000'
        case 'NT 5.1': return 'XP'
        case 'NT 5.2': return '2003'
        case 'NT 6.0': return 'Vista'
        case 'NT 6.1': return '7'
        case 'NT 6.2': return '8'
        case 'NT 6.3': return '8.1'
        case 'NT 10.0': return '10'
        default: return undefined
      }
    }

    // OS version extraction
    var osVersion = '';
    if (result.windows) {
      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
    } else if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (result.mac) {
      osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = !result.windows && osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.whale && compareVersions([result.version, '1.0']) === 1) ||
        (result.mzbrowser && compareVersions([result.version, '6.0']) === 1) ||
        (result.focus && compareVersions([result.version, '1.0']) === 1) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  /*
   * Set our detect public method to the main bowser object
   * This is needed to implement bowser in server side
   */
  bowser.detect = detect;
  return bowser
});

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],3:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

exports.glMatrix = glMatrix;

var mat2 = _interopRequireWildcard(require("./mat2.js"));

exports.mat2 = mat2;

var mat2d = _interopRequireWildcard(require("./mat2d.js"));

exports.mat2d = mat2d;

var mat3 = _interopRequireWildcard(require("./mat3.js"));

exports.mat3 = mat3;

var mat4 = _interopRequireWildcard(require("./mat4.js"));

exports.mat4 = mat4;

var quat = _interopRequireWildcard(require("./quat.js"));

exports.quat = quat;

var quat2 = _interopRequireWildcard(require("./quat2.js"));

exports.quat2 = quat2;

var vec2 = _interopRequireWildcard(require("./vec2.js"));

exports.vec2 = vec2;

var vec3 = _interopRequireWildcard(require("./vec3.js"));

exports.vec3 = vec3;

var vec4 = _interopRequireWildcard(require("./vec4.js"));

exports.vec4 = vec4;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./common.js":2,"./mat2.js":4,"./mat2d.js":5,"./mat3.js":6,"./mat4.js":7,"./quat.js":8,"./quat2.js":9,"./vec2.js":10,"./vec3.js":11,"./vec4.js":12}],4:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.str = str;
exports.frob = frob;
exports.LDU = LDU;
exports.add = add;
exports.subtract = subtract;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */


function fromValues(m00, m01, m10, m11) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */


function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */


function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],5:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.invert = invert;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(6);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */


function fromValues(a, b, c, d, tx, ty) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */


function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */


function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/


function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],6:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],7:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromQuat2 = fromQuat2;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":2}],8:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.getAngle = getAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.exp = exp;
exports.ln = ln;
exports.pow = pow;
exports.slerp = slerp;
exports.random = random;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var mat3 = _interopRequireWildcard(require("./mat3.js"));

var vec3 = _interopRequireWildcard(require("./vec3.js"));

var vec4 = _interopRequireWildcard(require("./vec4.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */


function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */


function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */


function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */


function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */


function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */


function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */


function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

exports.equals = equals;

var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);

    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


exports.rotationTo = rotationTo;

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */


exports.sqlerp = sqlerp;

var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

exports.setAxes = setAxes;
},{"./common.js":2,"./mat3.js":6,"./vec3.js":11,"./vec4.js":12}],9:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.fromRotationTranslationValues = fromRotationTranslationValues;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromMat4 = fromMat4;
exports.copy = copy;
exports.identity = identity;
exports.set = set;
exports.getDual = getDual;
exports.setDual = setDual;
exports.getTranslation = getTranslation;
exports.translate = translate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.rotateByQuatAppend = rotateByQuatAppend;
exports.rotateByQuatPrepend = rotateByQuatPrepend;
exports.rotateAroundAxis = rotateAroundAxis;
exports.add = add;
exports.multiply = multiply;
exports.scale = scale;
exports.lerp = lerp;
exports.invert = invert;
exports.conjugate = conjugate;
exports.normalize = normalize;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.dot = exports.mul = exports.setReal = exports.getReal = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var quat = _interopRequireWildcard(require("./quat.js"));

var mat4 = _interopRequireWildcard(require("./mat4.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */
function create() {
  var dq = new glMatrix.ARRAY_TYPE(8);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */


function clone(a) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */


function fromMat4(out, a) {
  //TODO Optimize this
  var outer = quat.create();
  mat4.getRotation(outer, a);
  var t = new glMatrix.ARRAY_TYPE(3);
  mat4.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */


function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */


var getReal = quat.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

exports.getReal = getReal;

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */


var setReal = quat.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

exports.setReal = setReal;

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */


function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */


function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */


function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */


function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */


function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < glMatrix.EPSILON) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */


function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

exports.mul = mul;

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */


var dot = quat.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

exports.dot = dot;

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */


function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */


var length = quat.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = quat.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

exports.sqrLen = sqrLen;

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */


function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}
},{"./common.js":2,"./mat4.js":7,"./quat.js":8}],10:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.rotate = rotate;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */


function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],11:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],12:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":2}],13:[function(require,module,exports){
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge]
 * @returns {Object} dest
 */
function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
function merge(dest, src) {
    return extend(dest, src, true);
}

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        extend(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument;
    return (doc.defaultView || doc.parentWindow);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = last.deltaX - input.deltaX;
        var deltaY = last.deltaY - input.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.id = uniqueId();

    this.manager = null;
    this.options = merge(options || {}, this.defaults);

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(withState) {
            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(true);
        }

        emit(); // simple 'eventName' events

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(true);
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = extend({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        this._super.emit.call(this, input);
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            this.manager.emit(this.options.event + inOut, input);
        }
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 500, // minimal time of the pointer to be pressed
        threshold: 5 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.65,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.velocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.velocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.velocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.direction &&
            input.distance > this.options.threshold &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.direction);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 2, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED ) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create an manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.4';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],
        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    options = options || {};

    this.options = merge(options, Hammer.defaults);
    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        extend(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        var recognizers = this.recognizers;
        recognizer = this.get(recognizer);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

extend(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

if (typeof define == TYPE_FUNCTION && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],14:[function(require,module,exports){
'use strict';

/**
 * @class
 * @classdesc Minimalistic event emitter mixin.
 */
function EventEmitter() {}

/**
 * Registers an event listener for the specified event. If the listener has
 * already been registered for the event, this is a no-op.
 *
 * @param {string} name The event name.
 * @param {function} fn The listener function.
 */
EventEmitter.prototype.addEventListener = function(name, fn) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name] = eventMap[name] || [];
  if (handlerList.indexOf(fn) < 0) {
    handlerList.push(fn);
  }
};

/**
 * Unregisters an event listener from the specified event. If the listener
 * hasn't been registered for the event, this is a no-op.
 *
 * @param {string} name The event name.
 * @param {function} fn The listener function.
 */
EventEmitter.prototype.removeEventListener = function(name, fn) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name];
  if (handlerList) {
    var index = handlerList.indexOf(fn);
    if (index >= 0) {
      handlerList.splice(index, 1);
    }
  }
};

/**
 * Emits an event, causing all registered event listeners for that event to be
 * called in registration order.
 *
 * @param {string} name The event name.
 * @param {...*} var_args Arguments to call listeners with.
 */
EventEmitter.prototype.emit = function(name, var_args) {
  var eventMap = this.__events = this.__events || {};
  var handlerList = eventMap[name];
  var args = Array.prototype.slice.call(arguments, 1);
  if (handlerList) {
    for (var i = 0; i < handlerList.length; i++) {
      var fn = handlerList[i];
      fn.apply(this, args);
    }
  }
};

/**
 * Mixes in {@link EventEmitter} into a constructor function.
 *
 * @param {function} ctor The constructor function.
 */
function eventEmitter(ctor) {
  for (var prop in EventEmitter.prototype) {
    if (EventEmitter.prototype.hasOwnProperty(prop)) {
      ctor.prototype[prop] = EventEmitter.prototype[prop];
    }
  }
}

module.exports = eventEmitter;

},{}],15:[function(require,module,exports){
'use strict';

var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * @class DepthmapStore
 * @classdesc
 *
 * A DepthmapStore maintains a cache of depthmap data used to render a {@link Layer}.
 *
 * Multiple layers belonging to the same underlying {@link WebGlStage} may
 * share the same DepthmapStore. Layers belonging to distinct {@link WebGlStage}
 * instances may not do so due to restrictions on the use of textures across
 * stages.
 *
 * @param {string} source The underlying source url.
 * @param {Stage} stage The underlying stage.
 * @param {Object} opts Options.
 */
function DepthmapStore(source, stage, opts) {

  var self = this;

  opts = opts || {};

  self._source = source;
  self._stage = stage;

  self._asset = null;
  self._texture = null;
  self._cubeTexture = null;

  // TODO Other types of depthmap.
  self._sourceType = source.split('.').pop();
  if (self._sourceType == 'stl') {
    // Load STL file.
    stage.loadModel(source, function(err, { positions, indices }) {
      if (err) {
        return;
      }

      // Make 3D model as depth cube texture.
      self.createCubeTexture(self._stage._gl, positions, indices);

    });
  } else {
    stage.loadImage(source, null, function (err, asset) {
      if (err) {
        return;
      }

      stage.createTexture(null, asset, function (err, _tile, asset, texture) {
        if (err) {
          return;
        }

        self._asset = asset;
        self._texture = texture;
      });
    });
  }
}

eventEmitter(DepthmapStore);


/**
 * Destructor.
 */
DepthmapStore.prototype.destroy = function () {

  var gl = this._stage._gl;
  var asset = this._asset;
  var texture = this._texture;
  var cubeTexture = this._cubeTexture;

  // Destroy asset.
  if (asset) {
    asset.destroy();
  }

  // Destroy texture.
  if (texture) {
    texture.destroy();
  }

  // Destroy cube texture.
  if (cubeTexture) {
    gl.deleteTexture(cubeTexture);
  }

  clearOwnProperties(this);
};

// TODO Optimize the following functions.
function E(gl, a, b, c) {
  gl.texParameteri(a, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(a, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(a, gl.TEXTURE_MAG_FILTER, b);
  gl.texParameteri(a, gl.TEXTURE_MIN_FILTER, c ? gl.LINEAR : b)
}

function za() {
  var l = "undefined" !== typeof Float32Array ? new Float32Array(16) : Array(16);
  df(l);
  return l
}

function df(l) {
  l[0] = l[5] = l[10] = l[15] = 1;
  l[1] = l[2] = l[3] = l[4] = l[6] = l[7] = l[8] = l[9] = l[11] = l[12] = l[13] = l[14] = 0
}

function Rd(l, a, c, b, d, O, B, f, k, n, e, h, p, m, g, z, y) {
  l[0] = a;
  l[1] = c;
  l[2] = b;
  l[3] = d;
  l[4] = O;
  l[5] = B;
  l[6] = f;
  l[7] = k;
  l[8] = n;
  l[9] = e;
  l[10] = h;
  l[11] = p;
  l[12] = m;
  l[13] = g;
  l[14] = z;
  l[15] = y
}

function zd(l, a, c, b, d, O, B, f, k, n) {
  l[0] = a;
  l[1] = c;
  l[2] = b;
  l[3] = 0;
  l[4] = d;
  l[5] = O;
  l[6] = B;
  l[7] = 0;
  l[8] = f;
  l[9] = k;
  l[10] = n;
  l[11] = 0;
  l[12] = 0;
  l[13] = 0;
  l[14] = 0;
  l[15] = 1
}

function ye(l, a, c, b, d) {
  Rd(l, a, 0, 0, 0, 0, a, 0, 0, b, d, 1, 0, c * b, c * d, c, 1)
}

function Sb(l, a) {
  var c = a[0]
    , b = a[1]
    , d = a[2]
    , O = a[3]
    , B = a[4]
    , f = a[5]
    , k = a[6]
    , n = a[7]
    , e = a[8]
    , h = a[9]
    , p = a[10]
    , m = a[11]
    , g = a[12]
    , z = a[13]
    , y = a[14]
    , x = a[15]
    , A = l[0]
    , E = l[1]
    , C = l[2]
    , q = l[3];
  l[0] = A * c + E * B + C * e + q * g;
  l[1] = A * b + E * f + C * h + q * z;
  l[2] = A * d + E * k + C * p + q * y;
  l[3] = A * O + E * n + C * m + q * x;
  A = l[4];
  E = l[5];
  C = l[6];
  q = l[7];
  l[4] = A * c + E * B + C * e + q * g;
  l[5] = A * b + E * f + C * h + q * z;
  l[6] = A * d + E * k + C * p + q * y;
  l[7] = A * O + E * n + C * m + q * x;
  A = l[8];
  E = l[9];
  C = l[10];
  q = l[11];
  l[8] = A * c + E * B + C * e + q * g;
  l[9] = A * b + E * f + C * h + q * z;
  l[10] = A * d + E * k + C * p + q * y;
  l[11] = A * O + E * n + C * m + q * x;
  A = l[12];
  E = l[13];
  C = l[14];
  q = l[15];
  l[12] = A * c + E * B + C * e + q * g;
  l[13] = A * b + E * f + C * h + q * z;
  l[14] = A * d + E * k + C * p + q * y;
  l[15] = A * O + E * n + C * m + q * x;
}

function Gd(l, a, c, b) {

  const ia = 0.017453292519943295;

  var d, O, g;
  d = c * ia;
  c = Math.cos(d);
  O = Math.sin(d);
  d = -a * ia;
  a = Math.cos(d);
  g = Math.sin(d);
  d = -b * ia;
  b = Math.cos(d);
  d = Math.sin(d);
  zd(l, -g * b - a * O * d, -g * d + a * O * b, -a * c, -c * d, c * b, O, a * b - g * O * d, a * d + g * O * b, -g * c);
}

function Ad(l, a, c, b) {
  Rd(l, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, a, c, b, 1)
}

function se(l, a) {
  var c = l[0]
    , b = l[1]
    , d = l[2]
    , O = l[3]
    , g = l[4]
    , f = l[5]
    , k = l[6]
    , n = l[7]
    , e = l[8]
    , h = l[9]
    , p = l[10]
    , m = l[11]
    , I = l[12]
    , z = l[13]
    , y = l[14]
    , x = l[15]
    , A = a[0]
    , E = a[1]
    , C = a[2]
    , q = a[3]
    , v = a[4]
    , M = a[5]
    , u = a[6]
    , Q = a[7]
    , F = a[8]
    , aa = a[9]
    , U = a[10]
    , w = a[11]
    , yc = a[12]
    , Ha = a[13]
    , r = a[14]
    , J = a[15];
  l[0] = A * c + E * g + C * e + q * I;
  l[1] = A * b + E * f + C * h + q * z;
  l[2] = A * d + E * k + C * p + q * y;
  l[3] = A * O + E * n + C * m + q * x;
  l[4] = v * c + M * g + u * e + Q * I;
  l[5] = v * b + M * f + u * h + Q * z;
  l[6] = v * d + M * k + u * p + Q * y;
  l[7] = v * O + M * n + u * m + Q * x;
  l[8] = F * c + aa * g + U * e + w * I;
  l[9] = F * b + aa * f + U * h + w * z;
  l[10] = F * d + aa * k + U * p + w * y;
  l[11] = F * O + aa * n + U * m + w * x;
  l[12] = yc * c + Ha * g + r * e + J * I;
  l[13] = yc * b + Ha * f + r * h + J * z;
  l[14] = yc * d + Ha * k + r * p + J * y;
  l[15] = yc * O + Ha * n + r * m + J * x
}

function na(gl, program, verticesBuffer, indicesBuffer, verticesArray, indicesArray) {

  const size = 512;
  const e = [
    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
  ];

  var texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
  E(gl, gl.TEXTURE_CUBE_MAP, gl.NEAREST, false);
  for (let i = 0; i < 6; i++) {
    gl.texImage2D(e[i], 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  }
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

  var renderBuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, size, size);

  let h = [];
  for (let i = 0; i < 6; i++) {
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, e[i], texture, 0);
    h.push(frameBuffer);
  }

  //e = da.useShader(b, 62);
  gl.useProgram(program);

  let t = za();
  let c = za();
  var k = za();

  var p = -1 / -99999.9;
  var m = 1 / (size / 2);

  Rd(c, m, 0, 0, 0, 0, -m, 0, 0, 0, 0, 100000.1 * p, 1, 0, 0, -(2e4 * p), 0);
  ye(k, size / 2, 0, 0, 0);
  Sb(k, c);

  const mp = gl.getUniformLocation(program, 'mp');
  gl.uniformMatrix4fv(mp, false, k);

  const viewPort = gl.getParameter(gl.VIEWPORT);
  gl.viewport(0, 0, size, size);

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  var p = { x: 0, y: 0, z: 0 };
  var G = verticesArray;
  var n = G.length;

  var q = 1e7;
  var m = 0;
  var H, r, u;

  for (c = 0; c < n; c += 3) {
    H = G[c];
    r = G[c + 1];
    u = G[c + 2];
    H = H * H + r * r + u * u;
    H < q && (q = H);
    H > m && (m = H);
  }

  Math.sqrt(q);
  m = Math.ceil(Math.sqrt(m) + /*p.length()*/ 0);
  //m *= /*a.farscale*/ 1;

  //gl.uniform1f(e.r, m);
  gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
  const vx = gl.getAttribLocation(program, 'a_position');
  gl.enableVertexAttribArray(vx);
  gl.vertexAttribPointer(vx, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
  gl.disable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);

  G = za();

  const mx = gl.getUniformLocation(program, 'mx');
  for (let i = 0; i < 6; i++) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, h[i]);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderBuffer);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

    Gd(t, i < 4 ? 90 * (i - 0) : 90, i == 4 ? 90 : i == 5 ? -90 : 0, 0);    // Rotation?
    Ad(G, -1 * p.z, 1 * p.y, 1 * p.x);
    se(t, G);
    
    gl.uniformMatrix4fv(mx, false, t);
    gl.drawElements(gl.TRIANGLES, indicesArray.length, gl.UNSIGNED_INT, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null);
  }

  gl.enable(gl.CULL_FACE);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(viewPort[0], viewPort[1], viewPort[2], viewPort[3]);
  gl.deleteRenderbuffer(renderBuffer);

  return texture;
}

/**
 * Make 3D model as depth cube texture..
 * @param {Array} positions 3D model positions.
 * @param {Array} indices 3D model indicies.
 */
DepthmapStore.prototype.createCubeTexture = function (gl, positions, indices) {

  gl.getExtension("OES_element_index_uint");

  // Define the vertex shader code
  const vertexShaderSource = `
    attribute vec3 a_position;
    uniform mat4 mx, mp;

    varying float w;

    void main() {
      vec4 v = mp * mx * vec4(a_position, 1.0);
      gl_Position = v;
      w = v.w;
    }
  `;

  // Define the fragment shader code
  const fragmentShaderSource = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
    #else
        precision mediump float;
    #endif

    varying float w;

    void main() {
      vec3 b;
      b.x = (gl_FragCoord.x-256.0)/255.5,
      b.y = (gl_FragCoord.y-256.0)/255.5,
      b.z = -1.0;

      float e = length(b);
      float c = 1.0 - w*e/15.0;
      c = c * 255.0 * 255.0 * 255.0;

      vec4 a;
      a.r = floor(c/256.0/256.0),
      a.g = floor((c-a.r*256.0*256.0)/256.0),
      a.b = floor(c-a.r*256.0*256.0-a.g*256.0),
      a /= 255.0,
      a.a = 1.0;

      gl_FragColor = a;
    }
  `;

  // Create and compile the shaders
  const vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.compileShader(vertexShader);

  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.compileShader(fragmentShader);

  // Create the shader program and attach the shaders
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  // Convert the vertices and indices to Float32Array and Uint32Array
  const verticesArray = new Float32Array(positions);
  const indicesArray = new Uint32Array(indices);

  // Create and bind the buffer for the rectangle vertices
  const verticesBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, verticesArray, gl.STATIC_DRAW);

  const indicesBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicesArray, gl.STATIC_DRAW);

  this._cubeTexture = na(gl,program, verticesBuffer, indicesBuffer, verticesArray, indicesArray);

  // Delete resources.
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  gl.deleteProgram(program);
  gl.deleteBuffer(verticesBuffer);
  gl.deleteBuffer(indicesBuffer);
};

/**
 * Return the underlying {@link Stage}.
 * @return {Stage}
 */
DepthmapStore.prototype.stage = function () {
  return this._stage;
};

/**
 * Return the underlying source.
 * @return {string}
 */
DepthmapStore.prototype.source = function () {
  return this._source;
};

/**
 * Return the underlying source type.
 * @return {string}
 */
DepthmapStore.prototype.sourceType = function () {
  return this._sourceType;
};

/**
 * Return the depthmap asset {@link Source}.
 * @return {Asset}
 */
DepthmapStore.prototype.asset = function () {
  return this._asset;
};

/**
 * Return the depthmap texture {@link WebGlTexture}.
 * @return {WebGlTexture}
 */
DepthmapStore.prototype.texture = function () {
  return this._texture;
};

/**
 * Return the depthmap cube texture.
 */
DepthmapStore.prototype.cubeTexture = function () {
  return this._cubeTexture;
};

module.exports = DepthmapStore;

},{"./util/clearOwnProperties":82,"minimal-event-emitter":14}],16:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var positionAbsolutely = require('./util/positionAbsolutely');
var setTransform = require('./util/dom').setTransform;
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * @class Hotspot
 * @classdesc
 *
 * A Hotspot allows a DOM element to be placed at a fixed position in the
 * image. The position is updated automatically when the {@link View view}
 * changes.
 *
 * Positioning is performed with the `transform` CSS property when available,
 * falling back to the `position`, `left` and `top` properties when not.
 * In both cases, the top left corner of the element is placed in the requested
 * position; clients are expected to use additional children elements or other
 * CSS properties to achieve more sophisticated layouts.
 *
 * There are two kinds of hotspots: regular and embedded. A regular hotspot
 * does not change size depending on the zoom level. An embedded hotspot is
 * displayed at a fixed size relative to the panorama, always covering the
 * same portion of the image.
 *
 * Clients should call {@link HotspotContainer#createHotspot} instead of
 * invoking the constructor directly.
 *
 * @param {Element} domElement The DOM element.
 * @param {View} view The view.
 * @param {Object} coords The hotspot coordinates.
 *     Use {@link RectilinearViewCoords} for a {@link RectilinearView} or
 *     {@link FlatViewCoords} for a {@link FlatView}.
 * @param {Object} opts Additional options.
 * @param {Object} opts.perspective Perspective options for embedded hotspots.
 * @param {number} [opts.perspective.radius=null] If set, embed the hotspot
 *     into the image by transforming it into the surface of a sphere with this
 *     radius.
 * @param {string} [opts.perspective.extraTransforms=null] If set, append this
 *     value to the CSS `transform` property used to position the hotspot. This
 *     may be used to rotate an embedded hotspot.
 */
function Hotspot(domElement, parentDomElement, view, coords, opts) {

  opts = opts || {};
  opts.perspective = opts.perspective || {};
  opts.perspective.extraTransforms =
      opts.perspective.extraTransforms != null ? opts.perspective.extraTransforms : "";

  this._domElement = domElement;
  this._parentDomElement = parentDomElement;
  this._view = view;
  this._coords = {};
  this._perspective = {};

  this.setPosition(coords);

  // Add hotspot into the DOM.
  this._parentDomElement.appendChild(this._domElement);

  this.setPerspective(opts.perspective);

  // Whether the hotspot is visible.
  // The hotspot may still be hidden if it's inside a hidden HotspotContainer.
  this._visible = true;

  // The current calculated screen position.
  this._position = { x: 0, y: 0 };
}

eventEmitter(Hotspot);


/**
 * Destructor.
 * Clients should call {@link HotspotContainer#destroyHotspot} instead.
 */
Hotspot.prototype.destroy = function() {
  this._parentDomElement.removeChild(this._domElement);
  clearOwnProperties(this);
};


/**
 * @return {Element}
 */
Hotspot.prototype.domElement = function() {
  return this._domElement;
};


/**
 * @return {Object}
 */
Hotspot.prototype.position = function() {
  return this._coords;
};


/**
 * @param {Object} coords
 */
Hotspot.prototype.setPosition = function(coords) {
  for (var key in coords) {
    this._coords[key] = coords[key];
  }
  this._update();
  // TODO: We should probably emit a hotspotsChange event on the parent
  // HotspotContainer. What's the best way to do so?
};


/**
 * @return {Object}
 */
Hotspot.prototype.perspective = function() {
  return this._perspective;
};


/**
 * @param {Object}
 */
Hotspot.prototype.setPerspective = function(perspective) {
  for (var key in perspective) {
    this._perspective[key] = perspective[key];
  }
  this._update();
};


/**
 * Show the hotspot
 */
Hotspot.prototype.show = function() {
  if (!this._visible) {
    this._visible = true;
    this._update();
  }
};


/**
 * Hide the hotspot
 */
Hotspot.prototype.hide = function() {
  if (this._visible) {
    this._visible = false;
    this._update();
  }
};


Hotspot.prototype._update = function() {
  var element = this._domElement;

  var params = this._coords;
  var position = this._position;
  var x, y;

  var isVisible = false;

  if (this._visible) {
    var view = this._view;

    if (this._perspective.radius) {
      // Hotspots that are embedded in the panorama may be visible even when
      // positioned behind the camera.
      isVisible = true;
      this._setEmbeddedPosition(view, params);
    } else {
      // Regular hotspots are only visible when positioned in front of the
      // camera. Note that they may be partially visible when positioned outside
      // the viewport.
      view.coordinatesToScreen(params, position);
      x = position.x;
      y = position.y;

      if (x != null && y != null) {
        isVisible = true;
        this._setPosition(x, y);
      }
    }
  }

  // Show if visible, hide if not.
  if (isVisible) {
    element.style.display = 'block';
    element.style.position = 'absolute';
  }
  else {
    element.style.display = 'none';
    element.style.position = '';
  }

};


Hotspot.prototype._setEmbeddedPosition = function(view, params) {
  var transform = view.coordinatesToPerspectiveTransform(
      params, this._perspective.radius, this._perspective.extraTransforms);
  setTransform(this._domElement, transform);
};


Hotspot.prototype._setPosition = function(x, y) {
  positionAbsolutely(this._domElement, x, y, this._perspective.extraTransforms);
};


module.exports = Hotspot;

},{"./util/clearOwnProperties":82,"./util/dom":91,"./util/positionAbsolutely":102,"minimal-event-emitter":14}],17:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Hotspot = require('./Hotspot');
var calcRect = require('./util/calcRect');
var positionAbsolutely = require('./util/positionAbsolutely');
var setAbsolute = require('./util/dom').setAbsolute;
var setOverflowHidden = require('./util/dom').setOverflowHidden;
var setOverflowVisible = require('./util/dom').setOverflowVisible;
var setNullSize = require('./util/dom').setNullSize;
var setPixelSize = require('./util/dom').setPixelSize;
var setPointerEvents = require('./util/dom').setWithVendorPrefix('pointer-events');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that a hotspot has been created or destroyed on the container.
 * @event HotspotContainer#hotspotsChange
 */

/**
 * @class HotspotContainer
 * @classdesc
 *
 * Creates a DOM element to hold {@link Hotspot hotspots} and updates their
 * position when necessary.
 *
 * @param {Element} parentDomElement The DOM element inside which the container
 *     should be created.
 * @param {Stage} stage The underlying stage.
 * @param {View} view The view according to which the hotspots are positioned.
 * @param {RenderLoop} renderLoop The render loop indicating when the hotspots
 *     must be rendered.
 * @param {Object} opts
 * @param {RectSpec} opts.rect Rectangular region covered by the container. See
 *    {@link Effects#rect}.
 */
function HotspotContainer(parentDomElement, stage, view, renderLoop, opts) {
  opts = opts || {};

  this._parentDomElement = parentDomElement;
  this._stage = stage;
  this._view = view;
  this._renderLoop = renderLoop;

  // Hotspot list.
  this._hotspots = [];

  // Whether the hotspot container should be visible.
  this._visible = true;

  // The current rect.
  this._rect = opts.rect;

  // Whether the visibility or the rect have changed since the last DOM update.
  this._visibilityOrRectChanged = true;

  // The last seen stage dimensions.
  this._stageWidth = null;
  this._stageHeight = null;

  // Temporary variable to hold the calculated position and size.
  this._tmpRect = {};

  // Wrapper element. When the rect effect is set, the wrapper will have nonzero
  // dimensions and `pointer-events: none` so that hotspots outside the rect are
  // hidden, but no mouse events are hijacked.
  this._hotspotContainerWrapper = document.createElement('div');
  setAbsolute(this._hotspotContainerWrapper);
  setPointerEvents(this._hotspotContainerWrapper, 'none');
  this._parentDomElement.appendChild(this._hotspotContainerWrapper);

  // Hotspot container element. It has zero dimensions and `pointer-events: all`
  // to override the `pointer-events: none` on the wrapper and allow hotspots to
  // be interacted with.
  this._hotspotContainer = document.createElement('div');
  setAbsolute(this._hotspotContainer);
  setPointerEvents(this._hotspotContainer, 'all');
  this._hotspotContainerWrapper.appendChild(this._hotspotContainer);

  // Update when the hotspots change or scene is re-rendered.
  this._updateHandler = this._update.bind(this);
  this._renderLoop.addEventListener('afterRender', this._updateHandler);
}

eventEmitter(HotspotContainer);


/**
 * Destructor.
 */
HotspotContainer.prototype.destroy = function() {
  while (this._hotspots.length) {
    this.destroyHotspot(this._hotspots[0]);
  }

  this._parentDomElement.removeChild(this._hotspotContainerWrapper);

  this._renderLoop.removeEventListener('afterRender', this._updateHandler);

  clearOwnProperties(this);
};


/**
 * @return {Element}
 */
HotspotContainer.prototype.domElement = function() {
  return this._hotspotContainer;
};


/**
 * @param {Rect} rect
 */
HotspotContainer.prototype.setRect = function(rect) {
  this._rect = rect;
  this._visibilityOrRectChanged = true;
};


/**
 * @return {Rect}
 */
HotspotContainer.prototype.rect = function() {
  return this._rect;
};


/**
 * Creates a new hotspot in this container.
 *
 * @param {Element} domElement DOM element to use for the hotspot
 * @param {Object} coords The hotspot coordinates.
 *     Use {@link RectilinearViewCoords}` for a {@link RectilinearView} or
 *     {@link FlatViewCoords} for a {@link FlatView}.
 * @param {Object} opts Options in the same format as the `opts` argument to
 *     the {@link Hotspot} constructor.
 * @return {Hotspot}
 */
HotspotContainer.prototype.createHotspot = function(domElement, coords, opts) {
  coords = coords || {};

  var hotspot = new Hotspot(
      domElement, this._hotspotContainer, this._view, coords, opts);
  this._hotspots.push(hotspot);
  hotspot._update();

  this.emit('hotspotsChange');

  return hotspot;
};


/**
 * @param {Hotspot} hotspot
 * @return {boolean}
 */
HotspotContainer.prototype.hasHotspot = function(hotspot) {
  return this._hotspots.indexOf(hotspot) >= 0;
};


/**
 * @return {Hotspot[]}
 */
HotspotContainer.prototype.listHotspots = function() {
  return [].concat(this._hotspots);
};


/**
 * Removes a hotspot from the container.
 *
 * @param {Hotspot} hotspot
 */
HotspotContainer.prototype.destroyHotspot = function(hotspot) {
  var i = this._hotspots.indexOf(hotspot);
  if (i < 0) {
    throw new Error('No such hotspot');
  }
  this._hotspots.splice(i, 1);

  hotspot.destroy();
  this.emit('hotspotsChange');
};


/**
 * Hide the container's DOM element, causing every contained {@link Hotspot} to
 * be hidden.
 */
HotspotContainer.prototype.hide = function() {
  if (this._visible) {
    this._visible = false;
    this._visibilityOrRectChanged = true;
    this._update();
  }
};


/**
 * Show the container's DOM element, causing every contained {@link Hotspot} to
 * be shown.
 */
HotspotContainer.prototype.show = function() {
  if (!this._visible) {
    this._visible = true;
    this._visibilityOrRectChanged = true;
    this._update();
  }
};


HotspotContainer.prototype._update = function() {
  var wrapper = this._hotspotContainerWrapper;
  var width = this._stage.width();
  var height = this._stage.height();
  var tmpRect = this._tmpRect;

  // Avoid updating the wrapper DOM unless necessary.
  if (this._visibilityOrRectChanged ||
      (this._rect && (width !== this._stageWidth || height !== this._stageHeight))) {
    var visible = this._visible;
    wrapper.style.display = visible ? 'block' : 'none';

    if (visible) {
      if (this._rect) {
        calcRect(width, height, this._rect, tmpRect);
        positionAbsolutely(wrapper, width * tmpRect.x, height * tmpRect.y);
        setPixelSize(wrapper, width * tmpRect.width, height * tmpRect.height);
        setOverflowHidden(wrapper);
      } else {
        positionAbsolutely(wrapper, 0, 0);
        setNullSize(wrapper);
        setOverflowVisible(wrapper);
      }
    }

    this._stageWidth = width;
    this._stageHeight = height;
    this._visibilityOrRectChanged = false;
  }

  // Update hotspots unconditionally, as the view parameters may have changed.
  for (var i = 0; i < this._hotspots.length; i++) {
    this._hotspots[i]._update();
  }
};


module.exports = HotspotContainer;

},{"./Hotspot":16,"./util/calcRect":78,"./util/clearOwnProperties":82,"./util/dom":91,"./util/positionAbsolutely":102,"minimal-event-emitter":14}],18:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';


var eventEmitter = require('minimal-event-emitter');
var extend = require('./util/extend');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the layer has been rendered.
 *
 * @param {boolean} stable Whether all tiles were successfully rendered without
 *     missing textures or resorting to fallbacks.
 * @event Layer#renderComplete
 */

/**
 * @class Layer
 * @classdesc
 *
 * A Layer is a combination of {@link Source}, {@link Geometry}, {@link View}
 * and {@link TextureStore} that may be added into a {@link Stage} and rendered
 * with {@link Effects}.
 *
 * @param {Source} source
 * @param {Geometry} geometry
 * @param {string} depthmap
 * @param {View} view
 * @param {TextureStore} textureStore
 * @param {Object} opts
 * @param {Effects} opts.effects
*/
function Layer(source, geometry, depthmap, view, textureStore, depthmapStore, opts) {
  opts = opts || {};

  var self = this;

  this._source = source;
  this._geometry = geometry;
  this._depthmap = depthmap;
  this._view = view;
  this._textureStore = textureStore;
  this._depthmapStore = depthmapStore;

  this._effects = opts.effects || {};

  this._fixedLevelIndex = null;

  this._viewChangeHandler = function () {
    self.emit('viewChange', self.view());
  };

  this._view.addEventListener('change', this._viewChangeHandler);

  this._textureStoreChangeHandler = function () {
    self.emit('textureStoreChange', self.textureStore());
  };

  this._textureStore.addEventListener('textureLoad',
    this._textureStoreChangeHandler);
  this._textureStore.addEventListener('textureError',
    this._textureStoreChangeHandler);
  this._textureStore.addEventListener('textureInvalid',
    this._textureStoreChangeHandler);
}

eventEmitter(Layer);


/**
 * Destructor.
 */
Layer.prototype.destroy = function () {
  this._view.removeEventListener('change', this._viewChangeHandler);
  this._textureStore.removeEventListener('textureLoad',
    this._textureStoreChangeHandler);
  this._textureStore.removeEventListener('textureError',
    this._textureStoreChangeHandler);
  this._textureStore.removeEventListener('textureInvalid',
    this._textureStoreChangeHandler);
  clearOwnProperties(this);
};


/**
 * Returns the underlying {@link Source source}.
 * @return {Source}
 */
Layer.prototype.source = function () {
  return this._source;
};

/**
 * Returns the underlying depthmap.
 * @returns {string}
 */
Layer.prototype.depthmap = function () {
  return this._depthmap;
}

/**
 * Returns the underlying {@link Geometry geometry}.
 * @return {Geometry}
 */
Layer.prototype.geometry = function () {
  return this._geometry;
};


/**
 * Returns the underlying {@link View view}.
 * @return {View}
 */
Layer.prototype.view = function () {
  return this._view;
};


/**
 * Returns the underlying {@link TextureStore texture store}.
 * @return {TextureStore}
 */
Layer.prototype.textureStore = function () {
  return this._textureStore;
};


/**
 * Returns the underlying {@link DepthmapStore date store}.
 * @return {DepthmapStore}
 */
Layer.prototype.depthmapStore = function () {
  return this._depthmapStore;
};


/**
 * Returns the currently set {@link Effects effects}.
 * @return {Effects}
 */
Layer.prototype.effects = function () {
  return this._effects;
};


/**
 * Sets the {@link Effects effects}.
 * @param {Effects} effects
 */
Layer.prototype.setEffects = function (effects) {
  this._effects = effects;
  this.emit('effectsChange', this._effects);
};


/**
 * Merges effects into the currently set ones. The merge is non-recursive; for
 * instance, if current effects are `{ rect: { relativeWidth: 0.5 } }`,
 * calling this method with `{ rect: { relativeX: 0.5 }}` will reset
 * `rect.relativeWidth`.
 *
 * @param {Effects} effects
 */
Layer.prototype.mergeEffects = function (effects) {
  extend(this._effects, effects);
  this.emit('effectsChange', this._effects);
};


/**
 * Returns the fixed level index.
 * @return {(number|null)}
 */
Layer.prototype.fixedLevel = function () {
  return this._fixedLevelIndex;
};


/**
 * Sets the fixed level index. When set, the corresponding level will be
 * used regardless of the view parameters. Unset with a null argument.
 *
 * @param {(number|null)} levelIndex
 * @throws An error if the level index is out of range.
 */
Layer.prototype.setFixedLevel = function (levelIndex) {
  if (levelIndex !== this._fixedLevelIndex) {
    if (levelIndex != null && (levelIndex >= this._geometry.levelList.length ||
      levelIndex < 0)) {
      throw new Error("Level index out of range: " + levelIndex);
    }
    this._fixedLevelIndex = levelIndex;
    this.emit('fixedLevelChange', this._fixedLevelIndex);
  }
};


Layer.prototype._selectLevel = function () {
  var level;
  if (this._fixedLevelIndex != null) {
    level = this._geometry.levelList[this._fixedLevelIndex];
  } else {
    level = this._view.selectLevel(this._geometry.selectableLevelList);
  }
  return level;
};


Layer.prototype.visibleTiles = function (result) {
  var level = this._selectLevel();
  return this._geometry.visibleTiles(this._view, level, result);
};


/**
 * Pin a whole level into the texture store.
 * @param {Number} levelIndex
 */
Layer.prototype.pinLevel = function (levelIndex) {
  var level = this._geometry.levelList[levelIndex];
  var tiles = this._geometry.levelTiles(level);
  for (var i = 0; i < tiles.length; i++) {
    this._textureStore.pin(tiles[i]);
  }
};


/**
 * Unpin a whole level from the texture store.
 * @param {Number} levelIndex
 */
Layer.prototype.unpinLevel = function (levelIndex) {
  var level = this._geometry.levelList[levelIndex];
  var tiles = this._geometry.levelTiles(level);
  for (var i = 0; i < tiles.length; i++) {
    this._textureStore.unpin(tiles[i]);
  }
};


/**
 * Pin the first level. Equivalent to `pinLevel(0)`.
 */
Layer.prototype.pinFirstLevel = function () {
  return this.pinLevel(0);
};


/**
 * Unpin the first level. Equivalent to `unpinLevel(0)`.
 */
Layer.prototype.unpinFirstLevel = function () {
  return this.unpinLevel(0);
};


module.exports = Layer;

},{"./util/clearOwnProperties":82,"./util/extend":92,"minimal-event-emitter":14}],19:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('./util/inherits');

/**
 * @class NetworkError
 * @extends {Error}
 * @classdesc
 *
 * Signals an error that occurred while fetching a URL. This is used by
 * {@link Loader loaders} to distinguish network failures from other errors.
 */
function NetworkError(message) {
  // See: https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript
  this.constructor.super_.apply(this, arguments);
  this.message = message;
}

inherits(NetworkError, Error);

module.exports = NetworkError;

},{"./util/inherits":95}],20:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that {@link Stage#render} is about to be called.
 * @event RenderLoop#beforeRender
 */

/**
 * Signals that {@link Stage#render} has just been called.
 * @event RenderLoop#afterRender
 */

/**
 * @class RenderLoop
 * @classdesc
 *
 * A RenderLoop wraps a {@link Stage} and calls {@link Stage#render} on the next
 * frame whenever it fires {@link Stage#renderInvalid}. It may be started and
 * stopped, and is initially in the stopped state, in which no call to
 * {@link Stage#render} occurs.
 *
 * @listens Stage#renderInvalid
 *
 * @param {Stage} stage
 */
function RenderLoop(stage) {

  var self = this;

  // The stage wrapped by the loop.
  this._stage = stage;

  // Whether the loop is running.
  this._running = false;

  // Whether the loop is currently rendering.
  this._rendering = false;

  // The current requestAnimationFrame handle.
  this._requestHandle = null;

  // The callback passed into requestAnimationFrame.
  this._boundLoop = this._loop.bind(this);

  // Handler for renderInvalid events emitted by the stage.
  this._renderInvalidHandler = function() {
    // If we are already rendering, there's no need to schedule a new render
    // on the next frame.
    if (!self._rendering) {
      self.renderOnNextFrame();
    }
  };

  // Handle renderInvalid events emitted by the stage.
  this._stage.addEventListener('renderInvalid', this._renderInvalidHandler);

}

eventEmitter(RenderLoop);


/**
 * Destructor.
 */
RenderLoop.prototype.destroy = function() {
  this.stop();
  this._stage.removeEventListener('renderInvalid', this._renderInvalidHandler);
  clearOwnProperties(this);
};


/**
 * Returns the underlying stage.
 * @return {Stage}
 */
RenderLoop.prototype.stage = function() {
  return this._stage;
};


/**
 * Starts the render loop.
 */
RenderLoop.prototype.start = function() {
  this._running = true;
  this.renderOnNextFrame();
};


/**
 * Stops the render loop.
 */
RenderLoop.prototype.stop = function() {
  if (this._requestHandle) {
    window.cancelAnimationFrame(this._requestHandle);
    this._requestHandle = null;
  }
  this._running = false;
};


/**
 * Forces the stage to render on the next frame, even if its contents remain
 * valid. Does nothing if the loop is stopped.
 */
RenderLoop.prototype.renderOnNextFrame = function() {
  if (this._running && !this._requestHandle) {
    this._requestHandle = window.requestAnimationFrame(this._boundLoop);
  }
};


RenderLoop.prototype._loop = function() {
  if (!this._running) {
    throw new Error('Render loop running while in stopped state');
  }
  this._requestHandle = null;
  this._rendering = true;
  this.emit('beforeRender');
  this._rendering = false;
  this._stage.render();
  this.emit('afterRender');
};


module.exports = RenderLoop;

},{"./util/clearOwnProperties":82,"minimal-event-emitter":14}],21:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Layer = require('./Layer');
var TextureStore = require('./TextureStore');
var DepthmapStore = require('./DepthmapStore');
var HotspotContainer = require('./HotspotContainer');
var eventEmitter = require('minimal-event-emitter');
var now = require('./util/now');
var noop = require('./util/noop');
var type = require('./util/type');
var defaults = require('./util/defaults');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the scene's view has changed. See {@link View#event:change}.
 * @event Scene#viewChange
 */

/**
 * Signals that the scene's layers have changed.
 * @event Scene#layerChange
 */

/**
 * @class Scene
 * @classdesc
 *
 * A Scene is a stack of {@link Layer layers} sharing the same {@link View view}
 * and {@link HotspotContainer hotspot container}. It belongs to the
 * {@link Viewer viewer} inside which it is displayed.
 *
 * Clients should call {@link Viewer#createScene} instead of invoking the
 * constructor directly.
 *
 * @param {Viewer} viewer The viewer this scene belongs to.
 * @param {View} view The scene's underlying view.
 */
function Scene(viewer, view) {
  this._viewer = viewer;
  this._view = view;
  this._layers = [];

  // Hotspot container. Assume it occupies a full rect.
  this._hotspotContainer = new HotspotContainer(
    viewer._controlContainer,
    viewer.stage(),
    this._view,
    viewer.renderLoop());

  // The current movement.
  this._movement = null;
  this._movementStartTime = null;
  this._movementStep = null;
  this._movementParams = null;
  this._movementCallback = null;

  // Event listener for updating the view according to the current movement.
  // The listener is set/unset on the render loop when a movement starts/stops.
  this._updateMovementHandler = this._updateMovement.bind(this);

  // Show or hide hotspots when scene changes.
  this._updateHotspotContainerHandler = this._updateHotspotContainer.bind(this);
  this._viewer.addEventListener('sceneChange', this._updateHotspotContainerHandler);

  // Emit event when view changes.
  this._viewChangeHandler = this.emit.bind(this, 'viewChange');
  this._view.addEventListener('change', this._viewChangeHandler);

  // Update the hotspot container.
  this._updateHotspotContainer();
}

eventEmitter(Scene);


/**
 * Destructor. Clients should call {@link Viewer#destroyScene} instead.
 */
Scene.prototype.destroy = function () {
  this._view.removeEventListener('change', this._viewChangeHandler);
  this._viewer.removeEventListener('sceneChange', this._updateHotspotContainerHandler);

  if (this._movement) {
    this.stopMovement();
  }

  this._hotspotContainer.destroy();

  this.destroyAllLayers();

  clearOwnProperties(this);
};



/**
 * Returns the {@link HotspotContainer hotspot container} for the scene.
 * @return {Layer}
 */
Scene.prototype.hotspotContainer = function () {
  return this._hotspotContainer;
};

/**
 * Returns the first of the {@link Layer layers} belonging to the scene, or
 * null if the scene has no layers.
 *
 * This method is equivalent to `Scene#listLayers[0]`. It may be removed in the
 * future.
 *
 * @return {Layer}
 */
Scene.prototype.layer = function () {
  return this._layers[0];
};

/**
* Returns a list of all {@link Layer layers} belonging to the scene. The
* returned list is in display order, background to foreground.
* @return {Layer[]}
 */
Scene.prototype.listLayers = function () {
  return [].concat(this._layers);
};


/**
 * Returns the scene's underlying {@link View view}.
 * @return {View}
 */
Scene.prototype.view = function () {
  return this._view;
};


/**
 * Returns the {@link Viewer viewer} the scene belongs to.
 * @return {Viewer}
 */
Scene.prototype.viewer = function () {
  return this._viewer;
};


/**
 * Returns whether the scene is currently visible.
 * @return {boolean}
 */
Scene.prototype.visible = function () {
  return this._viewer.scene() === this;
};


/**
 * Creates a new {@link Layer layer} and adds it into the scene in the
 * foreground position.
 *
 * @param {Object} opts Layer creation options.
 * @param {Source} opts.source The layer's underlying {@link Source}.
 * @param {Geometry} opts.geometry The layer's underlying {@link Geometry}.
 * @param {Source} opts.depthmap The layer's underlying depthmap {@link Source}.
 * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to
 *     provide a fallback of last resort, at the cost of memory consumption.
 * @param {Object} [opts.textureStoreOpts={}] Options to pass to the
 *     {@link TextureStore} constructor.
 * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}
 *     constructor.
 * @return {Layer}
 */
Scene.prototype.createLayer = function (opts) {
  opts = opts || {};

  var textureStoreOpts = opts.textureStoreOpts || {};
  var depthmapStoreOpts = opts.depthmapStoreOpts || {};
  var layerOpts = opts.layerOpts || {};

  var source = opts.source;
  var geometry = opts.geometry;
  var depthmap = opts.depthmap;
  var view = this._view;
  var stage = this._viewer.stage();
  var textureStore = new TextureStore(source, stage, textureStoreOpts);
  var depthmapStore = depthmap && new DepthmapStore(depthmap, stage, depthmapStoreOpts);

  var layer = new Layer(source, geometry, depthmap, view, textureStore, depthmapStore, layerOpts);

  this._layers.push(layer);

  if (opts.pinFirstLevel) {
    layer.pinFirstLevel();
  }

  // Signal that the layers have changed.
  this.emit('layerChange');

  return layer;
};


/**
 * Destroys a {@link Layer layer} and removes it from the scene.
 * @param {Layer} layer
 * @throws An error if the layer does not belong to the scene.
 */
Scene.prototype.destroyLayer = function (layer) {
  var i = this._layers.indexOf(layer);
  if (i < 0) {
    throw new Error('No such layer in scene');
  }

  this._layers.splice(i, 1);

  // Signal that the layers have changed.
  this.emit('layerChange');

  layer.textureStore().destroy();
  layer.destroy();
};


/**
 * Destroys all {@link Layer layers} and removes them from the scene.
 */
Scene.prototype.destroyAllLayers = function () {
  while (this._layers.length > 0) {
    this.destroyLayer(this._layers[0]);
  }
};


/**
 * Switches to the scene.
 *
 * This is equivalent to calling {@link Viewer#switchScene} on this scene.
 *
 * @param {Object} opts Options to pass into {@link Viewer#switchScene}.
 * @param {function} done Function to call when the switch is complete.
 */
Scene.prototype.switchTo = function (opts, done) {
  return this._viewer.switchScene(this, opts, done);
};


/**
 * Tweens the scene's underlying {@link View view}.
 *
 * @param {Object} params Target view parameters.
 * @param {Object} opts Transition options.
 * @param {function} [opts.ease=easeInOutQuad] Tween easing function
 * @param {number} [opts.controlsInterrupt=false] allow controls to interrupt
 *     an ongoing tween.
 * @param {number} [opts.transitionDuration=1000] Tween duration, in
 *     milliseconds.
 * @param {number} [opts.closest=true] Whether to tween through the shortest
 *    path between the initial and final view parameters. This requires
 *    {@link View#normalizeToClosest} to be implemented, and does nothing
 *    otherwise.
 * @param {function} done Function to call when the tween finishes or is
 *    interrupted.
 */
Scene.prototype.lookTo = function (params, opts, done) {
  var self = this;

  opts = opts || {};
  done = done || noop;

  if (type(params) !== 'object') {
    throw new Error("Target view parameters must be an object");
  }

  // Quadratic in/out easing.
  var easeInOutQuad = function (k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  };

  var ease = opts.ease != null ? opts.ease : easeInOutQuad;
  var controlsInterrupt = opts.controlsInterrupt != null ? opts.controlsInterrupt : false;
  var duration = opts.transitionDuration != null ? opts.transitionDuration : 1000;
  var shortest = opts.shortest != null ? opts.shortest : true;

  var view = this._view;

  var initialParams = view.parameters();

  var finalParams = {};
  defaults(finalParams, params);
  defaults(finalParams, initialParams);

  // Tween through the shortest path if requested.
  // The view must implement the normalizeToClosest() method.
  if (shortest && view.normalizeToClosest) {
    view.normalizeToClosest(finalParams, finalParams);
  }

  var movement = function () {

    var finalUpdate = false;

    return function (params, elapsed) {

      if (elapsed >= duration && finalUpdate) {
        return null;
      }

      var delta = Math.min(elapsed / duration, 1);

      for (var param in params) {
        var start = initialParams[param];
        var end = finalParams[param];
        params[param] = start + ease(delta) * (end - start);
      }

      finalUpdate = elapsed >= duration;

      return params;

    };
  };

  var reenableControls = this._viewer.controls().enabled();

  if (!controlsInterrupt) {
    this._viewer.controls().disable();
  }

  this.startMovement(movement, function () {
    if (reenableControls) {
      self._viewer.controls().enable();
    }
    done();
  });

};


/**
 * Starts a movement, possibly replacing the current movement.
 *
 * @param {function} fn The movement function.
 * @param {function} done Function to be called when the movement finishes or is
 *     interrupted.
 */
Scene.prototype.startMovement = function (fn, done) {

  var renderLoop = this._viewer.renderLoop();

  if (this._movement) {
    this.stopMovement();
  }

  var step = fn();
  if (typeof step !== 'function') {
    throw new Error('Bad movement');
  }

  this._movement = fn;
  this._movementStep = step;
  this._movementStartTime = now();
  this._movementParams = {};
  this._movementCallback = done;

  renderLoop.addEventListener('beforeRender', this._updateMovementHandler);
  renderLoop.renderOnNextFrame();
};


/**
 * Stops the current movement.
 */
Scene.prototype.stopMovement = function () {

  var done = this._movementCallback;
  var renderLoop = this._viewer.renderLoop();

  if (!this._movement) {
    return;
  }

  // Clear state before calling done, to prevent an infinite loop when the
  // callback starts a new movement.
  this._movement = null;
  this._movementStep = null;
  this._movementStartTime = null;
  this._movementParams = null;
  this._movementCallback = null;

  renderLoop.removeEventListener('beforeRender', this._updateMovementHandler);

  if (done) {
    done();
  }
};


/**
 * Returns the current movement.
 * @return {function}
 */
Scene.prototype.movement = function () {
  return this._movement;
};


Scene.prototype._updateMovement = function () {

  if (!this._movement) {
    throw new Error('Should not call update');
  }

  var renderLoop = this._viewer.renderLoop();
  var view = this._view;

  var elapsed = now() - this._movementStartTime;
  var step = this._movementStep;
  var params = this._movementParams;

  params = view.parameters(params);
  params = step(params, elapsed);
  if (params == null) {
    this.stopMovement();
  } else {
    view.setParameters(params);
    renderLoop.renderOnNextFrame();
  }

};


Scene.prototype._updateHotspotContainer = function () {
  if (this.visible()) {
    this._hotspotContainer.show();
  } else {
    this._hotspotContainer.hide();
  }
};


module.exports = Scene;

},{"./DepthmapStore":15,"./HotspotContainer":17,"./Layer":18,"./TextureStore":22,"./util/clearOwnProperties":82,"./util/defaults":87,"./util/noop":98,"./util/now":99,"./util/type":107,"minimal-event-emitter":14}],22:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Map = require('./collections/Map');
var Set = require('./collections/Set');
var LruSet = require('./collections/LruSet');
var eventEmitter = require('minimal-event-emitter');
var defaults = require('./util/defaults');
var retry = require('./util/retry');
var chain = require('./util/chain');
var inherits = require('./util/inherits');
var clearOwnProperties = require('./util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.textureStore;


// A Stage informs the TextureStore about the set of visible tiles during a
// frame by calling startFrame, markTile and endFrame. In a particular frame,
// TextureStore expects one or more calls to startFrame, followed by zero or
// more calls to markTile, followed by one or more calls to endFrame. The
// number of calls to startFrame and endFrame must match. Calls to other
// TextureStore methods may be freely interleaved with this sequence.
//
// At any given time, TextureStore is in one of four states. The START state
// corresponds to the interval between the first startFrame and the first
// markTile of a frame. The MARK state corresponds to the interval between the
// first markTile and the first endFrame. The END state corresponds to the
// interval between the first and the last endFrame. At any other time, the
// TextureStore is in the IDLE state.
var State = {
  IDLE: 0,
  START: 1,
  MARK: 2,
  END: 3
};


var defaultOptions = {
  // Maximum number of cached textures for previously visible tiles.
  previouslyVisibleCacheSize: 512
};


// Assign an id to each operation so we can track its state.
// We actually only need this in debug mode, but the code is less convoluted
// if we track unconditionally, and the performance hit is minimal anyway.
var nextId = 0;


// Distinguishes a cancellation from other kinds of errors.
function CancelError() {}
inherits(CancelError, Error);


/**
 * @class TextureStoreItem
 * @classdesc
 *
 * An item saved in a {@link TextureStore}.
 *
 * Clients do not need to instantiate this. It is automatically instantiated by
 * a {@link TextureStore} to manage the lifetime of a stored item: loading,
 * refreshing, unloading and emitting associated events.
 *
 * @param {TextureStore} store The underlying {@link TextureStore}.
 * @param {Tile} tile The underlying tile.
 */
function TextureStoreItem(store, tile) {

  var self = this;

  var id = nextId++;

  self._id = id;
  self._store = store;
  self._tile = tile;

  self._asset = null;
  self._texture = null;

  self._changeHandler = function() {
    store.emit('textureInvalid', tile);
  };

  var source = store.source();
  var stage = store.stage();

  var loadAsset = source.loadAsset.bind(source);
  var createTexture = stage.createTexture.bind(stage);

  // Retry loading the asset until it succeeds, then create the texture from it.
  // This process may be canceled at any point by calling the destroy() method.
  var fn = chain(retry(loadAsset), createTexture);

  store.emit('textureStartLoad', tile);
  if (debug) {
    console.log('loading', id, tile);
  }

  self._cancel = fn(stage, tile, function(err, _tile, asset, texture) {

    // Make sure we do not call cancel after the operation is complete.
    self._cancel = null;

    if (err) {
      // The loading process was interrupted by an error.
      // This could either be because the texture creation failed, or because
      // the operation was canceled before the loading was complete.

      // Destroy the asset and texture, if they exist.
      if (asset) {
        asset.destroy();
      }
      if (texture) {
        texture.destroy();
      }

      // Emit events.
      if (err instanceof CancelError) {
        store.emit('textureCancel', tile);
        if (debug) {
          console.log('cancel', id, tile);
        }
      } else {
        store.emit('textureError', tile, err);
        if (debug) {
          console.log('error', id, tile);
        }
      }

      return;
    }

    // Save a local reference to the texture.
    self._texture = texture;

    // If the asset is dynamic, save a local reference to it and set up a
    // handler to be called whenever it changes. Otherwise, destroy the asset
    // as we won't be needing it any longer.
    if (asset.isDynamic()) {
      self._asset = asset;
      asset.addEventListener('change', self._changeHandler);
    } else {
      asset.destroy();
    }

    // Emit event.
    store.emit('textureLoad', tile);
    if (debug) {
      console.log('load', id, tile);
    }
  });

}


TextureStoreItem.prototype.asset = function() {
  return this._asset;
};


TextureStoreItem.prototype.texture = function() {
  return this._texture;
};


TextureStoreItem.prototype.destroy = function() {
  var id = this._id;
  var store = this._store;
  var tile = this._tile;
  var asset = this._asset;
  var texture = this._texture;
  var cancel = this._cancel;

  if (cancel) {
    // The texture is still loading, so cancel it.
    cancel(new CancelError('Texture load cancelled'));
    return;
  }

  // Destroy asset.
  if (asset) {
    asset.removeEventListener('change', this._changeHandler);
    asset.destroy();
  }

  // Destroy texture.
  if (texture) {
    texture.destroy();
  }

  // Emit event.
  store.emit('textureUnload', tile);
  if (debug) {
    console.log('unload', id, tile);
  }

  clearOwnProperties(this);
};

eventEmitter(TextureStoreItem);

/**
 * Signals that a texture has started to load.
 *
 * This event is followed by either {@link TextureStore#textureLoad},
 * {@link TextureStore#textureError} or {@link TextureStore#textureCancel}.
 *
 * @event TextureStore#textureStartLoad
 * @param {Tile} tile The tile for which the texture has started to load.
 */

/**
 * Signals that a texture has been loaded.
 *
 * @event TextureStore#textureLoad
 * @param {Tile} tile The tile for which the texture was loaded.
 */

/**
 * Signals that a texture has been unloaded.
 *
 * @event TextureStore#textureUnload
 * @param {Tile} tile The tile for which the texture was unloaded.
 */

/**
 * Signals that a texture has been invalidated.
 *
 * This event may be raised for a texture with an underlying dynamic asset. It
 * may only occur while the texture is loaded, i.e., in between
 * {@link TextureStore#textureLoad} and {@link TextureStore#textureUnload}.
 *
 * @event TextureStore#textureInvalid
 * @param {Tile} tile The tile for which the texture was invalidated.
 */

/**
 * Signals that loading a texture has been cancelled.
 *
 * This event may follow {@link TextureStore#textureStartLoad} if the texture
 * becomes unnecessary before it finishes loading.
 *
 * @event TextureStore#textureCancel
 * @param {Tile} tile The tile for which the texture loading was cancelled.
 */

/**
 * Signals that loading a texture has failed.
 *
 * This event may follow {@link TextureStore#textureStartLoad} if the texture
 * fails to load.
 *
 * @event TextureStore#textureError
 * @param {Tile} tile The tile for which the texture loading has failed.
 */

/**
 * @class TextureStore
 * @classdesc
 *
 * A TextureStore maintains a cache of textures used to render a {@link Layer}.
 *
 * A {@link Stage} communicates with the TextureStore through the startFrame(),
 * markTile() and endFrame() methods, which indicate the tiles that are visible
 * in the current frame. Textures for visible tiles are loaded and retained
 * as long as the tiles remain visible. A limited amount of textures whose
 * tiles were previously visible are cached according to an LRU policy. Tiles
 * may be pinned to keep their respective textures cached even when they are
 * invisible; these textures do not count towards the previously visible limit.
 *
 * Multiple layers belonging to the same underlying {@link WebGlStage} may
 * share the same TextureStore. Layers belonging to distinct {@link WebGlStage}
 * instances may not do so due to restrictions on the use of textures across
 * stages.
 *
 * @param {Source} source The underlying source.
 * @param {Stage} stage The underlying stage.
 * @param {Object} opts Options.
 * @param {Number} [opts.previouslyVisibleCacheSize=32] The maximum number of
 *     previously visible textures to cache according to an LRU policy.
 */
function TextureStore(source, stage, opts) {
  opts = defaults(opts || {}, defaultOptions);

  this._source = source;
  this._stage = stage;

  // The current state.
  this._state = State.IDLE;

  // The number of startFrame calls yet to be matched by endFrame calls during
  // the current frame.
  this._delimCount = 0;

  // The cache proper: map cached tiles to their respective textures/assets.
  this._itemMap = new Map();

  // The subset of cached tiles that are currently visible.
  this._visible = new Set();

  // The subset of cached tiles that were visible recently, but are not
  // visible right now. Newly inserted tiles replace older ones.
  this._previouslyVisible = new LruSet(opts.previouslyVisibleCacheSize);

  // The subset of cached tiles that should never be evicted from the cache.
  // A tile may be pinned more than once; map each tile into a reference count.
  this._pinMap = new Map();

  // Temporary variables.
  this._newVisible = new Set();
  this._noLongerVisible = [];
  this._visibleAgain = [];
  this._evicted = [];
}

eventEmitter(TextureStore);


/**
 * Destructor.
 */
TextureStore.prototype.destroy = function() {
  this.clear();
  clearOwnProperties(this);
};


/**
 * Return the underlying {@link Stage}.
 * @return {Stage}
 */
TextureStore.prototype.stage = function() {
  return this._stage;
};


/**
 * Return the underlying {@link Source}.
 * @return {Source}
 */
TextureStore.prototype.source = function() {
  return this._source;
};


/**
 * Remove all textures from the TextureStore, including pinned textures.
 */
TextureStore.prototype.clear = function() {
  var self = this;

  // Collect list of tiles to be evicted.
  self._evicted.length = 0;
  self._itemMap.forEach(function(tile) {
    self._evicted.push(tile);
  });

  // Evict tiles.
  self._evicted.forEach(function(tile) {
    self._unloadTile(tile);
  });

  // Clear all internal state.
  self._itemMap.clear();
  self._visible.clear();
  self._previouslyVisible.clear();
  self._pinMap.clear();
  self._newVisible.clear();
  self._noLongerVisible.length = 0;
  self._visibleAgain.length = 0;
  self._evicted.length = 0;
};


/**
 * Remove all textures in the TextureStore, excluding unpinned textures.
 */
TextureStore.prototype.clearNotPinned = function() {
  var self = this;

  // Collect list of tiles to be evicted.
  self._evicted.length = 0;
  self._itemMap.forEach(function(tile) {
    if (!self._pinMap.has(tile)) {
      self._evicted.push(tile);
    }
  });

  // Evict tiles.
  self._evicted.forEach(function(tile) {
    self._unloadTile(tile);
  });

  // Clear all caches except the pinned set.
  self._visible.clear();
  self._previouslyVisible.clear();

  // Clear temporary variables.
  self._evicted.length = 0;
};


/**
 * Signal the beginning of a frame. Called from {@link Stage}.
 */
TextureStore.prototype.startFrame = function() {
  // Check that we are in an appropriate state.
  if (this._state !== State.IDLE && this._state !== State.START) {
    throw new Error('TextureStore: startFrame called out of sequence');
  }

  // Enter the START state, if not already there.
  this._state = State.START;

  // Expect one more endFrame call.
  this._delimCount++;
};


/**
 * Mark a tile as visible within the current frame. Called from {@link Stage}.
 * @param {Tile} tile The tile to mark.
 */
TextureStore.prototype.markTile = function(tile) {
  // Check that we are in an appropriate state.
  if (this._state !== State.START && this._state !== State.MARK) {
    throw new Error('TextureStore: markTile called out of sequence');
  }

  // Enter the MARK state, if not already there.
  this._state = State.MARK;

  // Refresh texture for dynamic assets.
  var item = this._itemMap.get(tile);
  var texture = item && item.texture();
  var asset = item && item.asset();
  if (texture && asset) {
    texture.refresh(tile, asset);
  }

  // Add tile to the visible set.
  this._newVisible.add(tile);
};


/**
 * Signal the end of a frame. Called from {@link Stage}.
 */
TextureStore.prototype.endFrame = function() {
  // Check that we are in an appropriate state.
  if (this._state !== State.START && this._state !== State.MARK && this._state !== State.END) {
    throw new Error('TextureStore: endFrame called out of sequence');
  }

  // Enter the END state, if not already there.
  this._state = State.END;

  // Expect one less call to endFrame.
  this._delimCount--;

  // If no further calls are expected, process frame and enter the IDLE state.
  if (!this._delimCount) {
    this._update();
    this._state = State.IDLE;
  }
};


TextureStore.prototype._update = function() {
  var self = this;

  // Calculate the set of tiles that used to be visible but no longer are.
  self._noLongerVisible.length = 0;
  self._visible.forEach(function(tile) {
    if (!self._newVisible.has(tile)) {
      self._noLongerVisible.push(tile);
    }
  });

  // Calculate the set of tiles that were visible recently and have become
  // visible again.
  self._visibleAgain.length = 0;
  self._newVisible.forEach(function(tile) {
    if (self._previouslyVisible.has(tile)) {
      self._visibleAgain.push(tile);
    }
  });

  // Remove tiles that have become visible again from the list of previously
  // visible tiles.
  self._visibleAgain.forEach(function(tile) {
    self._previouslyVisible.remove(tile);
  });

  // Cancel loading of tiles that are no longer visible.
  // Move no longer visible tiles with a loaded texture into the previously
  // visible set, and collect the tiles evicted from the latter.
  self._evicted.length = 0;
  self._noLongerVisible.forEach(function(tile) {
    var item = self._itemMap.get(tile);
    var texture = item && item.texture();
    if (texture) {
      var otherTile = self._previouslyVisible.add(tile);
      if (otherTile != null) {
        self._evicted.push(otherTile);
      }
    } else if (item) {
      self._unloadTile(tile);
    }
  });

  // Unload evicted tiles, unless they are pinned.
  self._evicted.forEach(function(tile) {
    if (!self._pinMap.has(tile)) {
      self._unloadTile(tile);
    }
  });

  // Load visible tiles that are not already in the store.
  // Refresh texture on visible tiles for dynamic assets.
  self._newVisible.forEach(function(tile) {
    var item = self._itemMap.get(tile);
    if (!item) {
      self._loadTile(tile);
    }
  });

  // Swap the old visible set with the new one.
  var tmp = self._visible;
  self._visible = self._newVisible;
  self._newVisible = tmp;

  // Clear the new visible set.
  self._newVisible.clear();

  // Clear temporary variables.
  self._noLongerVisible.length = 0;
  self._visibleAgain.length = 0;
  self._evicted.length = 0;
};


TextureStore.prototype._loadTile = function(tile) {
  if (this._itemMap.has(tile)) {
    throw new Error('TextureStore: loading texture already in cache');
  }
  var item = new TextureStoreItem(this, tile);
  this._itemMap.set(tile, item);
};


TextureStore.prototype._unloadTile = function(tile) {
  var item = this._itemMap.del(tile);
  if (!item) {
    throw new Error('TextureStore: unloading texture not in cache');
  }
  item.destroy();
};


TextureStore.prototype.asset = function(tile) {
  var item = this._itemMap.get(tile);
  if (item) {
    return item.asset();
  }
  return null;
};


TextureStore.prototype.texture = function(tile) {
  var item = this._itemMap.get(tile);
  if (item) {
    return item.texture();
  }
  return null;
};


/**
 * Pin a tile. Textures for pinned tiles are never evicted from the store.
 * Upon pinning, the texture is created if not already present. Pins are
 * reference-counted; a tile may be pinned multiple times and must be unpinned
 * the corresponding number of times. Pinning is useful e.g. to ensure that
 * the lowest-resolution level of an image is always available to fall back
 * onto.
 * @param {Tile} tile the tile to pin
 * @returns {number} the pin reference count.
 */
TextureStore.prototype.pin = function(tile) {
  // Increment reference count.
  var count = (this._pinMap.get(tile) || 0) + 1;
  this._pinMap.set(tile, count);
  // If the texture for the tile is not present, load it now.
  if (!this._itemMap.has(tile)) {
    this._loadTile(tile);
  }
  return count;
};


/**
 * Unpin a tile. Pins are reference-counted; a tile may be pinned multiple
 * times and must be unpinned the corresponding number of times.
 * @param {Tile} tile the tile to unpin
 * @returns {number} the pin reference count.
 */
TextureStore.prototype.unpin = function(tile) {
  var count = this._pinMap.get(tile);
  // Consistency check.
  if (!count) {
    throw new Error('TextureStore: unpin when not pinned');
  } else {
    // Decrement reference count.
    count--;
    if (count > 0) {
      this._pinMap.set(tile, count);
    } else {
      this._pinMap.del(tile);
      // If the tile does not belong to either the visible or previously
      // visible sets, evict it from the cache.
      if (!this._visible.has(tile) && !this._previouslyVisible.has(tile)) {
        this._unloadTile(tile);
      }
    }
  }
  return count;
};


/**
 * Return type for {@link TextureStore#query}.
 * @typedef {Object} TileState
 * @property {boolean} visible Whether the tile is in the visible set.
 * @property {boolean} previouslyVisible Whether the tile is in the previously
 *     visible set.
 * @property {boolean} hasAsset Whether the asset for the tile is present.
 * @property {boolean} hasTexture Whether the texture for the tile is present.
 * @property {boolean} pinned Whether the tile is in the pinned set.
 * @property {number} pinCount The pin reference count for the tile.
 */


/**
 * Return the state of a tile.
 * @param {Tile} tile The tile to query.
 * @return {TileState}
 */
TextureStore.prototype.query = function(tile) {
  var item = this._itemMap.get(tile);
  var pinCount = this._pinMap.get(tile) || 0;
  return {
    visible: this._visible.has(tile),
    previouslyVisible: this._previouslyVisible.has(tile),
    hasAsset: item != null && item.asset() != null,
    hasTexture: item != null && item.texture() != null,
    pinned: pinCount !== 0,
    pinCount: pinCount
  };
};


module.exports = TextureStore;

},{"./collections/LruSet":30,"./collections/Map":31,"./collections/Set":32,"./util/chain":80,"./util/clearOwnProperties":82,"./util/defaults":87,"./util/inherits":95,"./util/retry":105,"minimal-event-emitter":14}],23:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Set = require('./collections/Set');

/**
 * @class TileSearcher
 * @classdesc
 *
 * A TileSearcher performs searches for visible tiles.
 */
function TileSearcher() {
  // Stack of tiles to be explored.
  this._stack = [];

  // Set of already explored tiles.
  this._visited = new Set();

  // Tile vertices. Allocated by Tile#vertices on first use.
  this._vertices = null;
}

/**
 * Performs a search for visible tiles by starting at a given tile and
 * recursively exploring neighbors until no more visible tiles are found.
 *
 * @param {View} view The view used to deem whether a tile is visible.
 * @param {Tile} tile The starting tile.
 * @param {Tile[]} result An array to append the visible tiles to, including the
 *     starting tile when visible. Existing array members are preserved.
 * @return {number} The number of visible tiles found.
 */
TileSearcher.prototype.search = function(view, startingTile, result) {
  var stack = this._stack;
  var visited = this._visited;
  var vertices = this._vertices;

  var count = 0;

  // Clear internal state.
  this._clear();

  stack.push(startingTile);

  while (stack.length > 0) {
    var tile = stack.pop();

    if (visited.has(tile)) {
      // Skip already visited tile.
      continue;
    }

    if (!view.intersects(tile.vertices(vertices))) {
      // Skip non-visible tile.
      continue;
    }

    // Mark tile as visited.
    visited.add(tile);

    // Add neighbors to the stack of tiles to explore.
    var neighbors = tile.neighbors();
    for (var i = 0; i < neighbors.length; i++) {
      stack.push(neighbors[i]);
    }

    // Add to result.
    result.push(tile);

    count++;
  }

  // Reuse the vertices array in future searches.
  this._vertices = vertices;

  // Clear internal state.
  this._clear();

  return count;
};

TileSearcher.prototype._clear = function() {
  this._stack.length = 0;
  this._visited.clear();
};

module.exports = TileSearcher;

},{"./collections/Set":32}],24:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var defaults = require('./util/defaults');
var now = require('./util/now');

var defaultOptions = {
  duration: Infinity
};


/**
 * Signals a timeout.
 * @event Timer#timeout
 */


/**
 * @class Timer
 * @classdesc
 *
 * A Timer provides a mechanism to receive an event after a timeout.
 *
 * A timer has a set duration, and is either started or stopped at a given time.
 * The timer is initially stopped. When the timer is started, a timeout event is
 * scheduled to fire once the set duration elapses. When the timer is stopped,
 * the scheduled timeout event is cancelled. When a timeout event fires, the
 * timer returns to the stopped state.
 *
 * @param {number} [opts.duration=Infinity] Timeout in milliseconds.
 */
function Timer(opts) {

  opts = defaults(opts || {}, defaultOptions);

  this._duration = opts.duration;

  this._startTime = null;

  this._handle = null;

  this._check = this._check.bind(this);

}

eventEmitter(Timer);


/**
 * Starts the timer. If the timer is already started, this has the effect of
 * stopping and starting again (i.e. resetting the timer).
 */
Timer.prototype.start = function() {
  this._startTime = now();
  if (this._handle == null && this._duration < Infinity) {
    this._setup(this._duration);
  }
};


/**
 * Returns whether the timer is in the started state.
 * @return {boolean}
 */
Timer.prototype.started = function() {
  return this._startTime != null;
};


/**
 * Stops the timer.
 */
Timer.prototype.stop = function() {
  this._startTime = null;
  if (this._handle != null) {
    clearTimeout(this._handle);
    this._handle = null;
  }
};


Timer.prototype._setup = function(interval) {
  this._handle = setTimeout(this._check, interval);
};


Timer.prototype._teardown = function() {
  clearTimeout(this._handle);
  this._handle = null;
};


Timer.prototype._check = function() {
  var currentTime = now();
  var elapsed = currentTime - this._startTime;
  var remaining = this._duration - elapsed;

  this._teardown();

  if (remaining <= 0) {
    this.emit('timeout');
    this._startTime = null;
  } else if (remaining < Infinity) {
    this._setup(remaining);
  }
};


/**
 * Returns the currently set duration.
 */
Timer.prototype.duration = function() {
  return this._duration;
};


/**
 * Sets the duration. If the timer is already started, the timeout event is
 * rescheduled to occur once the new duration has elapsed since the last call
 * to start. In particular, if an amount of time larger than the new duration
 * has already elapsed, the timeout event fires immediately.
 * @param {number}
 */
Timer.prototype.setDuration = function(duration) {
  this._duration = duration;
  if (this._startTime != null) {
    this._check();
  }
};


module.exports = Timer;

},{"./util/defaults":87,"./util/now":99,"minimal-event-emitter":14}],25:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');

var RenderLoop = require('./RenderLoop');
var Controls = require('./controls/Controls');
var Scene = require('./Scene');
var Timer = require('./Timer');

var WebGlStage = require('./stages/WebGl');

var ControlCursor = require('./controls/ControlCursor');
var HammerGestures = require('./controls/HammerGestures');

var registerDefaultControls = require('./controls/registerDefaultControls');
var registerDefaultRenderers = require('./renderers/registerDefaultRenderers');

var setOverflowHidden = require('./util/dom').setOverflowHidden;
var setAbsolute = require('./util/dom').setAbsolute;
var setFullSize = require('./util/dom').setFullSize;

var tween = require('./util/tween');
var noop = require('./util/noop');
var clearOwnProperties = require('./util/clearOwnProperties');

/**
 * Signals that the current scene has changed.
 * @event Viewer#sceneChange
 */

/**
 * Signals that the view of the current scene has changed. See
 * {@link View#event:change}.
 * @event Viewer#viewChange
 */

/**
 * @class Viewer
 * @classdesc
 *
 * A Viewer is a container for multiple {@link Scene scenes} to be displayed
 * inside a {@link Stage stage} contained in the DOM.
 *
 * Scenes may be created by calling {@link Viewer#createScene}. Except during a
 * scene switch, a single one of them, called the current scene, is visible.
 * Calling {@link Viewer#switchScene} sets the current scene and switches to it.
 *
 * @param {Element} domElement The DOM element to contain the stage.
 * @param {Object} opts Viewer creation options.
 * @param {Object} opts.controls Options to be passed to
 *     {@link registerDefaultControls}.
 * @param {Object} opts.stage Options to be passed to the {@link Stage}
 *     constructor.
 * @param {Object} opts.cursors Cursor options.
 * @param {Object} opts.cursors.drag Drag cursor options to be passed to the
 *     {@link ControlCursor} constructor.
 */
function Viewer(domElement, opts) {
  opts = opts || {};

  this._domElement = domElement;

  // Add `overflow: hidden` to the domElement.
  setOverflowHidden(domElement);

  // Create stage.
  this._stage = new WebGlStage(opts.stage);

  // Register the default renderers for the selected stage.
  registerDefaultRenderers(this._stage);

  // Add the stage element into the DOM.
  this._domElement.appendChild(this._stage.domElement());

  // Create control container.
  // Controls cannot be placed directly on the root DOM element because
  // Hammer.js will prevent click events from reaching the elements beneath.

  // The hotspot containers will be added inside the controls container.
  this._controlContainer = document.createElement('div');
  setAbsolute(this._controlContainer);
  setFullSize(this._controlContainer);
  domElement.appendChild(this._controlContainer);

  // Respond to window size changes.
  this._size = {};
  this.updateSize();
  this._updateSizeListener = this.updateSize.bind(this);
  window.addEventListener('resize', this._updateSizeListener);

  // Create render loop.
  this._renderLoop = new RenderLoop(this._stage);

  // Create the controls and register them with the render loop.
  this._controls = new Controls();
  this._controlMethods = registerDefaultControls(this._controls, this._controlContainer, opts.controls);
  this._controls.attach(this._renderLoop);

  // Expose HammerJS.
  this._hammerManagerTouch = HammerGestures.get(this._controlContainer, 'touch');
  this._hammerManagerMouse = HammerGestures.get(this._controlContainer, 'mouse');

  // Initialize drag cursor.
  this._dragCursor = new ControlCursor(this._controls, 'mouseViewDrag', domElement, opts.cursors && opts.cursors.drag || {});

  // Start the render loop.
  this._renderLoop.start();

  // Scene list.
  this._scenes = [];

  // The currently visible scene.
  // During a scene transition, this is the scene being switched to.
  this._currentScene = null;

  // The scene being switched from during a scene transition.
  // This is necessary to update the layers correctly when they are added or
  // removed during a transition.
  this._replacedScene = null;

  // The current transition.
  this._cancelCurrentTween = null;

  // The event listener fired when the current scene layers change.
  // This is attached to the correct scene whenever the current scene changes.
  this._layerChangeHandler = this._updateSceneLayers.bind(this);

  // The event listener fired when the current scene view changes.
  // This is attached to the correct scene whenever the current scene changes.
  this._viewChangeHandler = this.emit.bind(this, 'viewChange');

  // Setup the idle timer.
  // By default, the timer has an infinite duration so it does nothing.
  this._idleTimer = new Timer();
  this._idleTimer.start();

  // Reset the timer whenever the view changes.
  this._resetIdleTimerHandler = this._resetIdleTimer.bind(this);
  this.addEventListener('viewChange', this._resetIdleTimerHandler);

  // Start the idle movement when the idle timer fires.
  this._triggerIdleTimerHandler = this._triggerIdleTimer.bind(this);
  this._idleTimer.addEventListener('timeout', this._triggerIdleTimerHandler);

  // Stop an ongoing movement when the controls are activated or when the
  // scene changes.
  this._stopMovementHandler = this.stopMovement.bind(this);
  this._controls.addEventListener('active', this._stopMovementHandler);
  this.addEventListener('sceneChange', this._stopMovementHandler);

  // The currently programmed idle movement.
  this._idleMovement = null;
}

eventEmitter(Viewer);


/**
 * Destructor.
 */
Viewer.prototype.destroy = function () {

  window.removeEventListener('resize', this._updateSizeListener);

  if (this._currentScene) {
    this._removeSceneEventListeners(this._currentScene);
  }

  if (this._replacedScene) {
    this._removeSceneEventListeners(this._replacedScene);
  }

  this._dragCursor.destroy();

  for (var methodName in this._controlMethods) {
    this._controlMethods[methodName].destroy();
  }

  while (this._scenes.length) {
    this.destroyScene(this._scenes[0]);
  }

  this._domElement.removeChild(this._stage.domElement());

  this._stage.destroy();
  this._renderLoop.destroy();
  this._controls.destroy();
  this._controls = null;

  if (this._cancelCurrentTween) {
    this._cancelCurrentTween();
  }

  clearOwnProperties(this);
};


/**
 * Updates the stage size to fill the containing element.
 *
 * This method is automatically called when the browser window is resized.
 * Most clients won't need to explicitly call it to keep the size up to date.
 */
Viewer.prototype.updateSize = function () {
  var size = this._size;
  size.width = this._domElement.clientWidth;
  size.height = this._domElement.clientHeight;
  this._stage.setSize(size);
};


/**
 * Returns the underlying {@link Stage stage}.
 * @return {Stage}
 */
Viewer.prototype.stage = function () {
  return this._stage;
};


/**
 * Returns the underlying {@link RenderLoop render loop}.
 * @return {RenderLoop}
 */
Viewer.prototype.renderLoop = function () {
  return this._renderLoop;
};


/**
 * Returns the underlying {@link Controls controls}.
 * @return {Controls}
 */
Viewer.prototype.controls = function () {
  return this._controls;
};


/**
 * Returns the underlying DOM element.
 * @return {Element}
 */
Viewer.prototype.domElement = function () {
  return this._domElement;
};


/**
 * Creates a new {@link Scene scene} with a single layer and adds it to the
 * viewer.
 *
 * The current scene does not change. To switch to the scene, call
 * {@link Viewer#switchScene}.
 *
 * @param {Object} opts Scene creation options.
 * @param {View} opts.view The scene's underlying {@link View}.
 * @param {Source} opts.source The layer's underlying {@link Source}.
 * @param {Geometry} opts.geometry The layer's underlying {@link Geometry}.
 * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to
 *     provide a fallback of last resort, at the cost of memory consumption.
 * @param {Object} [opts.textureStoreOpts={}] Options to pass to the
 *     {@link TextureStore} constructor.
 * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}
 *     constructor.
 * @return {Scene}
 */
Viewer.prototype.createScene = function (opts) {
  opts = opts || {};

  var scene = this.createEmptyScene({ view: opts.view });

  scene.createLayer({
    source: opts.source,
    geometry: opts.geometry,
    depthmap: opts.depthmap,
    pinFirstLevel: opts.pinFirstLevel,
    textureStoreOpts: opts.textureStoreOpts,
    layerOpts: opts.layerOpts
  });

  return scene;
};


/**
 * Creates a new {@link Scene scene} with no layers and adds it to the viewer.
 *
 * Layers may be added to the scene by calling {@link Scene#createLayer}.
 * However, if the scene has a single layer, it is simpler to call
 * {@link Viewer#createScene} instead of this method.
 *
 * The current scene does not change. To switch to the scene, call
 * {@link Viewer#switchScene}.
 *
 * @param {Object} opts Scene creation options.
 * @param {View} opts.view The scene's underlying {@link View}.
 * @return {Scene}
 */
Viewer.prototype.createEmptyScene = function (opts) {
  opts = opts || {};

  var scene = new Scene(this, opts.view);
  this._scenes.push(scene);

  return scene;
};


Viewer.prototype._updateSceneLayers = function () {
  var i;
  var layer;

  var stage = this._stage;
  var currentScene = this._currentScene;
  var replacedScene = this._replacedScene;

  var oldLayers = stage.listLayers();

  // The stage contains layers from at most two scenes: the current one, on top,
  // and the one currently being switched away from, on the bottom.
  var newLayers = [];
  if (replacedScene) {
    newLayers = newLayers.concat(replacedScene.listLayers());
  }
  if (currentScene) {
    newLayers = newLayers.concat(currentScene.listLayers());
  }

  // A single layer can be added or removed from the scene at a time.
  if (Math.abs(oldLayers.length - newLayers.length) !== 1) {
    throw new Error('Stage and scene out of sync');
  }

  if (newLayers.length < oldLayers.length) {
    // A layer was removed.
    for (i = 0; i < oldLayers.length; i++) {
      layer = oldLayers[i];
      if (newLayers.indexOf(layer) < 0) {
        this._removeLayerFromStage(layer);
        break;
      }
    }
  }
  if (newLayers.length > oldLayers.length) {
    // A layer was added.
    for (i = 0; i < newLayers.length; i++) {
      layer = newLayers[i];
      if (oldLayers.indexOf(layer) < 0) {
        this._addLayerToStage(layer, i);
      }
    }
  }

  // TODO: When in the middle of a scene transition, call the transition update
  // function immediately to prevent an added layer from flashing with the wrong
  // opacity.
};


Viewer.prototype._addLayerToStage = function (layer, i) {
  // Pin the first level to ensure a fallback while the layer is visible.
  // Note that this is distinct from the `pinFirstLevel` option passed to
  // createScene(), which pins the layer even when it's not visible.
  layer.pinFirstLevel();
  this._stage.addLayer(layer, i);
};


Viewer.prototype._removeLayerFromStage = function (layer) {
  this._stage.removeLayer(layer);
  layer.unpinFirstLevel();
  layer.textureStore().clearNotPinned();
};


Viewer.prototype._addSceneEventListeners = function (scene) {
  scene.addEventListener('layerChange', this._layerChangeHandler);
  scene.addEventListener('viewChange', this._viewChangeHandler);
};


Viewer.prototype._removeSceneEventListeners = function (scene) {
  scene.removeEventListener('layerChange', this._layerChangeHandler);
  scene.removeEventListener('viewChange', this._viewChangeHandler);
};


/**
 * Destroys a {@link Scene scene} and removes it from the viewer.
 * @param {Scene} scene
 */
Viewer.prototype.destroyScene = function (scene) {
  var i = this._scenes.indexOf(scene);
  if (i < 0) {
    throw new Error('No such scene in viewer');
  }

  var j;
  var layers;

  if (this._currentScene === scene) {
    // The destroyed scene is the current scene.
    // Remove event listeners, remove layers from stage and cancel transition.
    this._removeSceneEventListeners(scene);
    layers = scene.listLayers();
    for (j = 0; j < layers.length; j++) {
      this._removeLayerFromStage(layers[j]);
    }
    if (this._cancelCurrentTween) {
      this._cancelCurrentTween();
      this._cancelCurrentTween = null;
    }
    this._currentScene = null;
    this.emit('sceneChange');
  }

  if (this._replacedScene === scene) {
    // The destroyed scene is being switched away from.
    // Remove event listeners and remove layers from stage.
    this._removeSceneEventListeners(scene);
    layers = scene.listLayers();
    for (j = 0; j < layers.length; j++) {
      this._removeLayerFromStage(layers[j]);
    }
    this._replacedScene = null;
  }

  this._scenes.splice(i, 1);

  scene.destroy();
};


/**
 * Destroys all {@link Scene scenes} and removes them from the viewer.
 */
Viewer.prototype.destroyAllScenes = function () {
  while (this._scenes.length > 0) {
    this.destroyScene(this._scenes[0]);
  }
};


/**
 * Returns whether the viewer contains a {@link Scene scene}.
 * @param {Scene} scene
 * @return {boolean}
 */
Viewer.prototype.hasScene = function (scene) {
  return this._scenes.indexOf(scene) >= 0;
};


/**
 * Returns a list of all {@link Scene scenes}.
 * @return {Scene[]}
 */
Viewer.prototype.listScenes = function () {
  return [].concat(this._scenes);
};


/**
 * Returns the current {@link Scene scene}, or null if there isn't one.
 *
 * To change the current scene, call {@link Viewer#switchScene}.
 *
 * @return {Scene}
 */
Viewer.prototype.scene = function () {
  return this._currentScene;
};


/**
 * Returns the {@link View view} for the current {@link Scene scene}, or null
 * if there isn't one.
 * @return {View}
 */
Viewer.prototype.view = function () {
  var scene = this._currentScene;
  if (scene) {
    return scene.view();
  }
  return null;
};


/**
 * Tweens the {@link View view} for the current {@link Scene scene}.
 *
 * This method is equivalent to calling {@link Scene#lookTo} on the current
 * scene.
 *
 * @param {Object} opts Options to pass into {@link Scene#lookTo}.
 * @param {function} done Function to call when the tween is complete.
 */
Viewer.prototype.lookTo = function (params, opts, done) {
  // TODO: is it an error to call lookTo when no scene is displayed?
  var scene = this._currentScene;
  if (scene) {
    scene.lookTo(params, opts, done);
  }
};


/**
 * Starts a movement, possibly replacing the current movement.
 *
 * This method is equivalent to calling {@link Scene#startMovement} on the
 * current scene. If there is no current scene, this is a no-op.
 *
 * @param {function} fn The movement function.
 * @param {function} done Function to be called when the movement finishes or is
 *     interrupted.
 */
Viewer.prototype.startMovement = function (fn, done) {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  scene.startMovement(fn, done);
};


/**
 * Stops the current movement.
 *
 * This method is equivalent to calling {@link Scene#stopMovement} on the
 * current scene. If there is no current scene, this is a no-op.
 */
Viewer.prototype.stopMovement = function () {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  scene.stopMovement();
};


/**
 * Returns the current movement.
 *
 * This method is equivalent to calling {@link Scene#movement} on the
 * current scene. If there is no current scene, this is a no-op.
 *
 * @return {function}
 */
Viewer.prototype.movement = function () {
  var scene = this._currentScene;
  if (!scene) {
    return;
  }
  return scene.movement();
};


/**
 * Schedules an idle movement to be automatically started when the view remains
 * unchanged for the given timeout period.
 *
 * Changing the view while the idle movement is active stops the movement and
 * schedules it to start again after the same timeout period. To disable it
 * permanently, call with a null movement or an infinite timeout.
 *
 * @param {number} timeout Timeout period in milliseconds.
 * @param {function} movement Automatic movement function, or null to disable.
 */
Viewer.prototype.setIdleMovement = function (timeout, movement) {
  this._idleTimer.setDuration(timeout);
  this._idleMovement = movement;
};


/**
 * Stops the idle movement. It will be started again after the timeout set by
 * {@link Viewer#setIdleMovement}.
 */
Viewer.prototype.breakIdleMovement = function () {
  this.stopMovement();
  this._resetIdleTimer();
};


Viewer.prototype._resetIdleTimer = function () {
  this._idleTimer.start();
};


Viewer.prototype._triggerIdleTimer = function () {
  var idleMovement = this._idleMovement;
  if (!idleMovement) {
    return;
  }
  this.startMovement(idleMovement);
};


var defaultSwitchDuration = 1000;

function defaultTransitionUpdate(val, newScene, oldScene) {
  var layers = newScene.listLayers();
  layers.forEach(function (layer) {
    layer.mergeEffects({ opacity: val });
  });

  newScene._hotspotContainer.domElement().style.opacity = val;
}


/**
 * Switches to another {@link Scene scene} with a fade transition. This scene
 * becomes the current one.
 *
 * If a transition is already taking place, it is interrupted before the new one
 * starts.
 *
 * @param {Scene} newScene The scene to switch to.
 * @param {Object} opts Transition options.
 * @param {number} [opts.transitionDuration=1000] Transition duration, in
 *     milliseconds.
 * @param {number} [opts.transitionUpdate=defaultTransitionUpdate]
 *     Transition update function, with signature `f(t, newScene, oldScene)`.
 *     This function is called on each frame with `t` increasing from 0 to 1.
 *     An initial call with `t=0` and a final call with `t=1` are guaranteed.
 *     The default function sets the opacity of the new scene to `t`.
 * @param {function} done Function to call when the transition finishes or is
 *     interrupted. If the new scene is equal to the old one, no transition
 *     takes place, but this function is still called.
 */
Viewer.prototype.switchScene = function (newScene, opts, done) {
  var self = this;

  opts = opts || {};
  done = done || noop;

  var stage = this._stage;

  var oldScene = this._currentScene;

  // Do nothing if the target scene is the current one.
  if (oldScene === newScene) {
    done();
    return;
  }

  if (this._scenes.indexOf(newScene) < 0) {
    throw new Error('No such scene in viewer');
  }

  // Cancel an already ongoing transition. This ensures that the stage contains
  // layers from exactly one scene before the transition begins.
  if (this._cancelCurrentTween) {
    this._cancelCurrentTween();
    this._cancelCurrentTween = null;
  }

  var oldSceneLayers = oldScene ? oldScene.listLayers() : [];
  var newSceneLayers = newScene.listLayers();
  var stageLayers = stage.listLayers();

  // Check that the stage contains exactly as many layers as the current scene,
  // and that the top layer is the right one. If this test fails, either there
  // is a bug or the user tried to modify the stage concurrently.
  if (oldScene && ((stageLayers.length !== oldSceneLayers.length) ||
    (stageLayers.length > 1 && stageLayers[0] != oldSceneLayers[0]))) {
    throw new Error('Stage not in sync with viewer');
  }

  // Get the transition parameters.
  var duration = opts.transitionDuration != null ?
    opts.transitionDuration : defaultSwitchDuration;
  var update = opts.transitionUpdate != null ?
    opts.transitionUpdate : defaultTransitionUpdate;

  // Add new scene layers into the stage before starting the transition.
  for (var i = 0; i < newSceneLayers.length; i++) {
    this._addLayerToStage(newSceneLayers[i]);
  }

  // Update function to be called on every frame.
  function tweenUpdate(val) {
    update(val, newScene, oldScene);
  }

  // Once the transition is complete, remove old scene layers from the stage and
  // remove the event listeners. If the old scene was destroyed during the
  // transition, this has already been taken care of. Otherwise, we still need
  // to get a fresh copy of the scene's layers, since they might have changed
  // during the transition.
  function tweenDone() {
    if (self._replacedScene) {
      self._removeSceneEventListeners(self._replacedScene);
      oldSceneLayers = self._replacedScene.listLayers();
      for (var i = 0; i < oldSceneLayers.length; i++) {
        self._removeLayerFromStage(oldSceneLayers[i]);
      }
      self._replacedScene = null;
    }
    self._cancelCurrentTween = null;
    done();
  }

  // Store the cancelable for the transition.
  this._cancelCurrentTween = tween(duration, tweenUpdate, tweenDone);

  // Update the current and replaced scene.
  this._currentScene = newScene;
  this._replacedScene = oldScene;

  // Emit scene and view change events.
  this.emit('sceneChange');
  this.emit('viewChange');

  // Add event listeners to the new scene.
  // Note that event listeners can only be removed from the old scene once the
  // transition is complete, since layers might get added or removed in the
  // interim.
  this._addSceneEventListeners(newScene);
};


module.exports = Viewer;

},{"./RenderLoop":20,"./Scene":21,"./Timer":24,"./controls/ControlCursor":37,"./controls/Controls":38,"./controls/HammerGestures":42,"./controls/registerDefaultControls":48,"./renderers/registerDefaultRenderers":64,"./stages/WebGl":76,"./util/clearOwnProperties":82,"./util/dom":91,"./util/noop":98,"./util/tween":106,"minimal-event-emitter":14}],26:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var StaticAsset = require('./Static');
var inherits = require('../util/inherits');
var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class DynamicAsset
 * @implements Asset
 * @extends StaticAsset
 * @classdesc
 *
 * An {@link Asset} whose pixel contents may change.
 *
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The
 *     underlying pixel source.
 * @throws If the pixel source is unsupported.
 */
function DynamicAsset(element) {
  this.constructor.super_.call(this, element);
  this._timestamp = 0;
}

inherits(DynamicAsset, StaticAsset);
eventEmitter(DynamicAsset);

/**
 * Destructor.
 */
DynamicAsset.prototype.destroy = function() {
  clearOwnProperties(this);
};

DynamicAsset.prototype.timestamp = function() {
  return this._timestamp;
};

DynamicAsset.prototype.isDynamic = function() {
  return true;
};

/**
 * Marks the asset dirty, signaling that the contents of the underlying pixel
 * source have changed.
 *
 * @throws If the asset is not dynamic.
 */
DynamicAsset.prototype.markDirty = function() {
  this._timestamp++;
  this.emit('change');
};

module.exports = DynamicAsset;

},{"../util/clearOwnProperties":82,"../util/inherits":95,"./Static":27,"minimal-event-emitter":14}],27:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var global = require('../util/global');
var eventEmitter = require('minimal-event-emitter');
var clearOwnProperties = require('../util/clearOwnProperties');

var propertyMap = {
  HTMLImageElement: ['naturalWidth', 'naturalHeight'],
  HTMLCanvasElement: ['width', 'height'],
  ImageBitmap: ['width', 'height']
};

/**
 * @class StaticAsset
 * @implements Asset
 * @classdesc
 *
 * An {@link Asset} whose pixel contents never change.
 *
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} element The
 *     underlying pixel source.
 * @throws If the pixel source is unsupported.
 */
function StaticAsset(element) {
  var supported = false;
  for (var type in propertyMap) {
    if (global[type] && element instanceof global[type]) {
      supported = true;
      this._widthProp = propertyMap[type][0];
      this._heightProp = propertyMap[type][1];
      break;
    }
  }
  if (!supported) {
    throw new Error('Unsupported pixel source');
  }

  this._element = element;
}

eventEmitter(StaticAsset);

/**
 * Destructor.
 */
StaticAsset.prototype.destroy = function() {
  clearOwnProperties(this);
};

StaticAsset.prototype.element = function() {
  return this._element;
};

StaticAsset.prototype.width = function() {
  return this._element[this._widthProp];
};

StaticAsset.prototype.height = function() {
  return this._element[this._heightProp];
};

StaticAsset.prototype.timestamp = function() {
  return 0;
};

StaticAsset.prototype.isDynamic = function() {
  return false;
};

module.exports = StaticAsset;

},{"../util/clearOwnProperties":82,"../util/global":93,"minimal-event-emitter":14}],28:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('./util/defaults');

var defaultSpeed = 0.1;
var defaultAccel = 0.01;

var defaultOptions = {
  yawSpeed: defaultSpeed,
  pitchSpeed: defaultSpeed,
  fovSpeed: defaultSpeed,
  yawAccel: defaultAccel,
  pitchAccel: defaultAccel,
  fovAccel: defaultAccel,
  targetPitch: 0,
  targetFov: null
};

/**
 * @param {Object} opts
 * @param {Number} [opts.yawSpeed=0.1] Yaw maximum speed
 * @param {Number} [opts.pitchSpeed=0.1] Pitch maximum speed
 * @param {Number} [opts.fovSpeed=0.1] Fov maximum speed
 * @param {Number} [opts.yawAccel=0.01] Yaw acceleration
 * @param {Number} [opts.pitchAccel=0.01] Pitch acceleration
 * @param {Number} [opts.fovAccel=0.01] Fov acceleration
 * @param {Number} [opts.targetPitch=0] Value that pitch converges to. `null` means that the pitch will not change.
 * @param {Number} [opts.targetFov=null] Value that fov converges to. `null` means that the fov will not change.
 * @returns Movement function that can be passed to {@link Viewer#setIdleMovement} or {@link Scene#startMovement}
*/
function autorotate(opts) {

  opts = defaults(opts || {}, defaultOptions);

  var yawSpeed = opts.yawSpeed;
  var pitchSpeed = opts.pitchSpeed;
  var fovSpeed = opts.fovSpeed;
  var yawAccel = opts.yawAccel;
  var pitchAccel = opts.pitchAccel;
  var fovAccel = opts.fovAccel;
  var targetPitch = opts.targetPitch;
  var targetFov = opts.targetFov;

  return function start() {

    var lastTime = 0;
    var lastYawSpeed = 0;
    var lastPitchSpeed = 0;
    var lastFovSpeed = 0;

    var currentYawSpeed = 0;
    var currentPitchSpeed = 0;
    var currentFovSpeed = 0;

    var timeDelta;
    var yawDelta;
    var pitchDelta;
    var fovDelta;

    return function step(params, currentTime) {

      timeDelta = (currentTime - lastTime) / 1000;
      currentYawSpeed = Math.min(lastYawSpeed + timeDelta * yawAccel, yawSpeed);
      yawDelta = currentYawSpeed * timeDelta;
      params.yaw = params.yaw + yawDelta;

      if (targetPitch != null && params.pitch !== targetPitch) {
        var pitchThresh = 0.5 * lastPitchSpeed * lastPitchSpeed / pitchAccel;
        if (Math.abs(targetPitch - params.pitch) > pitchThresh) {
          // Acceleration phase
          currentPitchSpeed = Math.min(lastPitchSpeed + timeDelta * pitchAccel, pitchSpeed);
        } else {
          // Deceleration phase
          currentPitchSpeed = Math.max(lastPitchSpeed - timeDelta * pitchAccel, 0);
        }
        // currentPitchSpeed is the absolute value (>= 0)
        pitchDelta = currentPitchSpeed * timeDelta;
        if (targetPitch < params.pitch) {
          params.pitch = Math.max(targetPitch, params.pitch - pitchDelta);
        }
        if (targetPitch > params.pitch) {
          params.pitch = Math.min(targetPitch, params.pitch + pitchDelta);
        }
      }

      if (targetFov != null && params.fov !== targetPitch) {
        var fovThresh = 0.5 * lastFovSpeed * lastFovSpeed / fovAccel;
        if (Math.abs(targetFov - params.fov) > fovThresh) {
          // Acceleration phase
          currentFovSpeed = Math.min(lastFovSpeed + timeDelta * fovAccel, fovSpeed);
        } else {
          // Deceleration phase
          currentFovSpeed = Math.max(lastFovSpeed - timeDelta * fovAccel, 0);
        }
        // currentFovSpeed is the absolute value (>= 0)
        fovDelta = currentFovSpeed * timeDelta;
        if (targetFov < params.fov) {
          params.fov = Math.max(targetFov, params.fov - fovDelta);
        }
        if (targetFov > params.fov) {
          params.fov = Math.min(targetFov, params.fov + fovDelta);
        }
      }

      lastTime = currentTime;
      lastYawSpeed = currentYawSpeed;
      lastPitchSpeed = currentPitchSpeed;
      lastFovSpeed = currentFovSpeed;

      return params;

    };

  };

}

module.exports = autorotate;
},{"./util/defaults":87}],29:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

// An LruMap holds up to a maximum number of key-value pairs, ordered by their
// time of insertion. When the addition of a key-value pair would cause the
// capacity to be exceeded, the oldest key-value pair in the set is evicted.
// As a special case, an LruMap with zero capacity always rejects the insertion
// of a key-value pair.
//
// Keys must implement hash() and equals(). Note that the implementation doesn't
// currently use hash(), but a future version might.
function LruMap(capacity) {
  if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
    throw new Error('LruMap: invalid capacity');
  }
  this._capacity = capacity;

  // Keys and values are stored in circular arrays ordered by decreasing age.
  // Start is the index of the oldest key/value and size is the number of valid
  // key/values; the region containing valid keys/values may wrap around.
  this._keys = new Array(this._capacity);
  this._values = new Array(this._capacity);
  this._start = 0;
  this._size = 0;
}

LruMap.prototype._index = function(i) {
  return mod(this._start + i, this._capacity);
};

// Returns the value associated to the specified key, or null if not found.
LruMap.prototype.get = function(key) {
  for (var i = 0; i < this._size; i++) {
    var existingKey = this._keys[this._index(i)];
    if (key.equals(existingKey)) {
      return this._values[this._index(i)];
    }
  }
  return null;
};

// Associates the specified value with the specified key, possibly replacing the
// currently associated value. The key-value pair becomes the newest. If the map
// is at capacity, the oldest key-value pair is removed. Returns the removed
// key, or null otherwise. If the capacity is zero, does nothing and returns
// the key.
LruMap.prototype.set = function(key, value) {
  if (this._capacity === 0) {
    return key;
  }
  this.del(key);
  var evictedKey =
      this._size === this._capacity ? this._keys[this._index(0)] : null;
  this._keys[this._index(this._size)] = key;
  this._values[this._index(this._size)] = value;
  if (this._size < this._capacity) {
    this._size++;
  } else {
    this._start = this._index(1);
  }
  return evictedKey;
};

// Removes the key-value pair associated with the specified key.
// Returns the removed value, or null if not found.
LruMap.prototype.del = function(key) {
  for (var i = 0; i < this._size; i++) {
    if (key.equals(this._keys[this._index(i)])) {
      var existingValue = this._values[this._index(i)];
      for (var j = i; j < this._size - 1; j++) {
        this._keys[this._index(j)] = this._keys[this._index(j + 1)];
        this._values[this._index(j)] = this._values[this._index(j + 1)];
      }
      this._size--;
      return existingValue;
    }
  }
  return null;
};

// Returns whether there is a value associated with the specified key.
LruMap.prototype.has = function(key) {
  for (var i = 0; i < this._size; i++) {
    if (key.equals(this._keys[this._index(i)])) {
      return true;
    }
  }
  return false;
};

// Returns the number of key-value pairs in the map.
LruMap.prototype.size = function() {
  return this._size;
};

// Removes all key-value pairs from the map.
LruMap.prototype.clear = function() {
  this._keys.length = 0;
  this._values.length = 0;
  this._start = 0;
  this._size = 0;
};

// Calls fn(key, value) for each item in the map, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the map is mutated during iteration.
LruMap.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._size; i++) {
    fn(this._keys[this._index(i)], this._values[this._index(i)]);
    count += 1;
  }
  return count;
};

module.exports = LruMap;

},{"../util/mod":97}],30:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

// An LruSet holds up to a maximum number of elements, ordered by their time of
// insertion. When the addition of an element would cause the capacity to be
// exceeded, the oldest element in the set is evicted. As a special case, an
// LruSet with zero capacity always rejects the insertion of an element.
//
// Elements must implement hash() and equals(). Note that the implementation
// doesn't currently use hash(), but a future version might.
function LruSet(capacity) {
  if (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 0) {
    throw new Error('LruSet: invalid capacity');
  }
  this._capacity = capacity;

  // Elements are stored in a circular array ordered by decreasing age.
  // Start is the index of the oldest element and size is the number of valid
  // elements; the region containing valid elements may wrap around.
  this._elements = new Array(this._capacity);
  this._start = 0;
  this._size = 0;
}

LruSet.prototype._index = function(i) {
  return mod(this._start + i, this._capacity);
};

// Adds an element into the set, possibly replacing an equal element already in
// the set. The element becomes the newest. If the set is at capacity, the
// oldest element is removed. Returns the removed element if it does not equal
// the inserted element, or null otherwise. If the capacity is zero, does
// nothing and returns the element.
LruSet.prototype.add = function(element) {
  if (this._capacity === 0) {
    return element;
  }
  this.remove(element);
  var evictedElement =
      this._size === this._capacity ? this._elements[this._index(0)] : null;
  this._elements[this._index(this._size)] = element;
  if (this._size < this._capacity) {
    this._size++;
  } else {
    this._start = this._index(1);
  }
  return evictedElement;
};

// Removes an element from the set.
// Returns the removed element, or null if the element was not found.
LruSet.prototype.remove = function(element) {
  for (var i = 0; i < this._size; i++) {
    var existingElement = this._elements[this._index(i)];
    if (element.equals(existingElement)) {
      for (var j = i; j < this._size - 1; j++) {
        this._elements[this._index(j)] = this._elements[this._index(j + 1)];
      }
      this._size--;
      return existingElement;
    }
  }
  return null;
};

// Returns whether an element is in the set.
LruSet.prototype.has = function(element) {
  for (var i = 0; i < this._size; i++) {
    if (element.equals(this._elements[this._index(i)])) {
      return true;
    }
  }
  return false;
};

// Returns the number of elements in the set.
LruSet.prototype.size = function() {
  return this._size;
};

// Removes all elements from the set.
LruSet.prototype.clear = function() {
  this._elements.length = 0;
  this._start = 0;
  this._size = 0;
};

// Calls fn(element) for each element in the set, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the set is mutated during iteration.
LruSet.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._size; i++) {
    fn(this._elements[this._index(i)]);
    count += 1;
  }
  return count;
};

module.exports = LruSet;

},{"../util/mod":97}],31:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

var defaultCapacity = 64;

// A map data structure for keys implementing hash() and equals() and arbitrary
// values. The capacity, if given, is just a hint; the map is allowed to exceed
// it, but performance may suffer.
function Map(capacity) {
  if (capacity != null &&
      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
    throw new Error('Map: invalid capacity');
  }
  this._capacity = capacity || defaultCapacity;

  this._keyBuckets = [];
  this._valBuckets = [];
  for (var i = 0; i < this._capacity; i++) {
    this._keyBuckets.push([]);
    this._valBuckets.push([]);
  }
  this._size = 0;
}

// Returns the value associated with the specified key, or null if not found.
Map.prototype.get = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var valBucket = this._valBuckets[h];
      var existingValue = valBucket[i];
      return existingValue;
    }
  }
  return null;
};

// Associates the specified value with the specified key, possibly replacing the
// currently associated value.
// Returns the replaced value, or null if no value was replaced.
Map.prototype.set = function(key, val) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  var valBucket = this._valBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var existingValue = valBucket[i];
      keyBucket[i] = key;
      valBucket[i] = val;
      return existingValue;
    }
  }
  keyBucket.push(key);
  valBucket.push(val);
  this._size++;
  return null;
};

// Removes the key-value pair associated with the specified key.
// Returns the removed value, or null if not found.
Map.prototype.del = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  var valBucket = this._valBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      var existingValue = valBucket[i];
      // Splice manually to avoid Array#splice return value allocation.
      for (var j = i; j < keyBucket.length - 1; j++) {
        keyBucket[j] = keyBucket[j+1];
        valBucket[j] = valBucket[j+1];
      }
      keyBucket.length = keyBucket.length - 1;
      valBucket.length = valBucket.length - 1;
      this._size--;
      return existingValue;
    }
  }
  return null;
};

// Returns whether there is a value associated with the specified key.
Map.prototype.has = function(key) {
  var h = mod(key.hash(), this._capacity);
  var keyBucket = this._keyBuckets[h];
  for (var i = 0; i < keyBucket.length; i++) {
    var existingKey = keyBucket[i];
    if (key.equals(existingKey)) {
      return true;
    }
  }
  return false;
};

// Returns the number of key-value pairs in the map.
Map.prototype.size = function() {
  return this._size;
};

// Removes all key-value pairs from the map.
Map.prototype.clear = function() {
  for (var i = 0; i < this._capacity; i++) {
    this._keyBuckets[i].length = 0;
    this._valBuckets[i].length = 0;
  }
  this._size = 0;
};

// Calls fn(key, value) for each key-value pair in the map, in an unspecified
// order. Returns the number of times fn was called.
// The result is unspecified if the map is mutated during iteration.
Map.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._capacity; i++) {
    var keyBucket = this._keyBuckets[i];
    var valBucket = this._valBuckets[i];
    for (var j = 0; j < keyBucket.length; j++) {
      fn(keyBucket[j], valBucket[j]);
      count += 1;
    }
  }
  return count;
};

module.exports = Map;

},{"../util/mod":97}],32:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mod = require('../util/mod');

var defaultCapacity = 64;

// A set data structure for elements implementing hash() and equals().
// The capacity, if given, is just a hint; the set is allowed to exceed it, but
// performance may suffer.
function Set(capacity) {
  if (capacity != null &&
      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {
    throw new Error('Set: invalid capacity');
  }
  this._capacity = this._capacity || defaultCapacity;

  this._buckets = [];
  for (var i = 0; i < this._capacity; i++) {
    this._buckets.push([]);
  }
  this._size = 0;
}

// Adds an element, replacing an existing element.
// Returns the replaced element, or null if no element was replaced.
Set.prototype.add = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      bucket[i] = element;
      return existingElement;
    }
  }
  bucket.push(element);
  this._size++;
  return null;
};

// Removes an element.
// Returns the removed element, or null if the element was not found.
Set.prototype.remove = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      // Splice manually to avoid Array#splice return value allocation.
      for (var j = i; j < bucket.length - 1; j++) {
        bucket[j] = bucket[j+1];
      }
      bucket.length = bucket.length - 1;
      this._size--;
      return existingElement;
    }
  }
  return null;
};

// Returns whether an element is in the set.
Set.prototype.has = function(element) {
  var h = mod(element.hash(), this._capacity);
  var bucket = this._buckets[h];
  for (var i = 0; i < bucket.length; i++) {
    var existingElement = bucket[i];
    if (element.equals(existingElement)) {
      return true;
    }
  }
  return false;
};

// Returns the number of elements in the set.
Set.prototype.size = function() {
  return this._size;
};

// Removes all elements from the set.
Set.prototype.clear = function() {
  for (var i = 0; i < this._capacity; i++) {
    this._buckets[i].length = 0;
  }
  this._size = 0;
};

// Calls fn(element) for each element in the set, in an unspecified order.
// Returns the number of times fn was called.
// The result is unspecified if the set is mutated during iteration.
Set.prototype.forEach = function(fn) {
  var count = 0;
  for (var i = 0; i < this._capacity; i++) {
    var bucket = this._buckets[i];
    for (var j = 0; j < bucket.length; j++) {
      fn(bucket[j]);
      count += 1;
    }
  }
  return count;
};

module.exports = Set;

},{"../util/mod":97}],33:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WorkQueue = require('./WorkQueue');
var mod = require('../util/mod');


function WorkPool(opts) {
  this._concurrency = opts && opts.concurrency || 1;
  this._paused = opts && !!opts.paused || false;

  this._pool = [];
  for (var i = 0; i < this._concurrency; i++) {
    this._pool.push(new WorkQueue(opts));
  }

  this._next = 0;
}


WorkPool.prototype.length = function() {
  var len = 0;
  for (var i = 0; i < this._pool.length; i++) {
    len += this._pool[i].length();
  }
  return len;
};


WorkPool.prototype.push = function(fn, cb) {
  var i = this._next;
  var cancel = this._pool[i].push(fn, cb);
  this._next = mod(this._next + 1, this._concurrency);
  return cancel;
};


WorkPool.prototype.pause = function() {
  if (!this._paused) {
    this._paused = true;
    for (var i = 0; i < this._concurrency; i++) {
      this._pool[i].pause();
    }
  }
};


WorkPool.prototype.resume = function() {
  if (this._paused) {
    this._paused = false;
    for (var i = 0; i < this._concurrency; i++) {
      this._pool[i].resume();
    }
  }
};


module.exports = WorkPool;

},{"../util/mod":97,"./WorkQueue":34}],34:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var now = require('../util/now');


function WorkTask(fn, cb) {
  this.fn = fn;
  this.cb = cb;
  this.cfn = null;
}


function WorkQueue(opts) {
  this._queue = [];
  this._delay = opts && opts.delay || 0;
  this._paused = opts && !!opts.paused || false;
  this._currentTask = null;
  this._lastFinished = null;
}


WorkQueue.prototype.length = function() {
  return this._queue.length;
};


WorkQueue.prototype.push = function(fn, cb) {

  var task = new WorkTask(fn, cb);

  var cancel = this._cancel.bind(this, task);

  // Push the task into the queue.
  this._queue.push(task);

  // Run the task if idle.
  this._next();

  return cancel;

};


WorkQueue.prototype.pause = function() {
  if (!this._paused) {
    this._paused = true;
  }
};


WorkQueue.prototype.resume = function() {
  if (this._paused) {
    this._paused = false;
    this._next();
  }
};


WorkQueue.prototype._start = function(task) {

  // Consistency check.
  if (this._currentTask) {
    throw new Error('WorkQueue: called start while running task');
  }

  // Mark queue as busy, so that concurrent tasks wait.
  this._currentTask = task;

  // Execute the task.
  var finish = this._finish.bind(this, task);
  task.cfn = task.fn(finish);

  // Detect when a non-cancellable function has been queued.
  if (typeof task.cfn !== 'function') {
    throw new Error('WorkQueue: function is not cancellable');
  }

};


WorkQueue.prototype._finish = function(task) {

  var args = Array.prototype.slice.call(arguments, 1);

  // Consistency check.
  if (this._currentTask !== task) {
    throw new Error('WorkQueue: called finish on wrong task');
  }

  // Call the task callback on the return values.
  task.cb.apply(null, args);

  // Mark as not busy and record task finish time, then advance to next task.
  this._currentTask = null;
  this._lastFinished = now();
  this._next();

};


WorkQueue.prototype._cancel = function(task) {

  var args = Array.prototype.slice.call(arguments, 1);

  if (this._currentTask === task) {

    // Cancel running task. Because cancel passes control to the _finish
    // callback we passed into fn, the cleanup logic will be handled there.
    task.cfn.apply(null, args);

  } else {

    // Remove task from queue.
    var pos = this._queue.indexOf(task);
    if (pos >= 0) {
      this._queue.splice(pos, 1);
      task.cb.apply(null, args);
    }

  }

};


WorkQueue.prototype._next = function() {

  if (this._paused) {
    // Do not start tasks while paused.
    return;
  }

  if (!this._queue.length) {
    // No tasks to run.
    return;
  }

  if (this._currentTask) {
    // Will be called again when the current task finishes.
    return;
  }

  if (this._lastFinished != null) {
    var elapsed = now() - this._lastFinished;
    var remaining = this._delay - elapsed;
    if (remaining > 0) {
      // Too soon. Run again after the inter-task delay.
      setTimeout(this._next.bind(this), remaining);
      return;
    }
  }

  // Run the next task.
  var task = this._queue.shift();
  this._start(task);

};


module.exports = WorkQueue;

},{"../util/now":99}],35:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var vec4 = require('gl-matrix').vec4;
var mat4 = require('gl-matrix').mat4;

/**
 * Helper functions for color transformation {@link Effects}.
 *
 * References:
 *
 *   - [ColorMatrix Guide](http://docs.rainmeter.net/tips/colormatrix-guide)
 *   - [Matrix Operations for Image Processing](http://www.graficaobscura.com/matrix/index.html)
 *   - [WebGLImageFilter](https://github.com/phoboslab/WebGLImageFilter)
 *   - [glfx.js](https://github.com/evanw/glfx.js)
 *
 * @namespace colorEffects
 */

/**
 * A vector and matrix corresponding to an identity transformation.
 *
 * @param {Object} result Object to store result
 * @param {vec4} result.colorOffset Array with zeroes.
 * @param {mat4} result.colorMatrix Identity matrix.
 *
 * @memberof colorEffects
 */
function identity(resultArg) {
  var result = resultArg || {};
  result.colorOffset = result.colorOffset || vec4.create();
  result.colorMatrix = result.colorMatrix || mat4.create();
  return result;
}

/**
 * Apply color effects to a single pixel
 *
 * @param {vec4} pixel Values in range [0,1]
 * @param {Object} effect
 * @param {vec4} effect.colorOffset
 * @param {mat4} effect.colorMatrix
 * @param {vec4} result Object to store result
 *
 * @memberof colorEffects
 */
function applyToPixel(pixel, effect, result) {
  vec4TransformMat4Transposed(result, pixel, effect.colorMatrix);
  vec4.add(result, result, effect.colorOffset);
}

// Oddly, the colorTransform matrix needs to be transposed to be used with
// vec4.transformMat4. It is strange that transformMat4 dosn't work the same
// way as multiplying on the shader.
// TODO: investigate this further
function vec4TransformMat4Transposed(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[1] * y + m[2] * z + m[3] * w;
  out[1] = m[4] * x + m[5] * y + m[6] * z + m[7] * w;
  out[2] = m[8] * x + m[9] * y + m[10] * z + m[11] * w;
  out[3] = m[12] * x + m[13] * y + m[14] * z + m[15] * w;
  return out;
}

/**
 * Apply color effects to an ImageData
 *
 * @param {ImageData} imageData This object will be mutated
 * @param {Object} effect
 * @param {vec4} effect.colorOffset
 * @param {mat4} effect.colorMatrix
 *
 * @memberof colorEffects
 */
var tmpPixel = vec4.create();
function applyToImageData(imageData, effect) {
  var width = imageData.width;
  var height = imageData.height;
  var data = imageData.data;

  for(var i = 0; i < width * height; i++) {
    vec4.set(tmpPixel, data[i*4+0]/255, data[i*4+1]/255, data[i*4+2]/255, data[i*4+3]/255);
    applyToPixel(tmpPixel, effect, tmpPixel);
    data[i*4+0] = tmpPixel[0]*255;
    data[i*4+1] = tmpPixel[1]*255;
    data[i*4+2] = tmpPixel[2]*255;
    data[i*4+3] = tmpPixel[3]*255;
  }
}

module.exports = {
  identity: identity,
  applyToPixel: applyToPixel,
  applyToImageData: applyToImageData
};

},{"gl-matrix":3}],36:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var now = require('../util/now');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class ControlComposer
 * @classdesc
 *
 * Combines changes in parameters triggered by multiple {@link ControlMethod}
 * instances.
 *
 * @listens ControlMethod#parameterDynamics
 */
function ControlComposer(opts) {
  opts = opts || {};

  this._methods = [];

  this._parameters = [ 'x' ,'y', 'axisScaledX', 'axisScaledY', 'zoom', 'yaw', 'pitch', 'roll' ];

  this._now = opts.nowForTesting || now;

  this._composedOffsets = { };

  this._composeReturn = { offsets: this._composedOffsets, changing: null };
}

eventEmitter(ControlComposer);


ControlComposer.prototype.add = function(instance) {
  if (this.has(instance)) {
    return;
  }

  var dynamics = {};
  this._parameters.forEach(function(parameter) {
    dynamics[parameter] = {
      dynamics: new Dynamics(),
      time: null
    };
  });

  var parameterDynamicsHandler = this._updateDynamics.bind(this, dynamics);

  var method = {
    instance: instance,
    dynamics: dynamics,
    parameterDynamicsHandler: parameterDynamicsHandler
  };

  instance.addEventListener('parameterDynamics', parameterDynamicsHandler);

  this._methods.push(method);
};


ControlComposer.prototype.remove = function(instance) {
  var index = this._indexOfInstance(instance);
  if (index >= 0) {
    var method = this._methods.splice(index, 1)[0];
    method.instance.removeEventListener('parameterDynamics', method.parameterDynamicsHandler);
  }
};


ControlComposer.prototype.has = function(instance) {
  return this._indexOfInstance(instance) >= 0;
};


ControlComposer.prototype._indexOfInstance = function(instance) {
  for (var i = 0; i < this._methods.length; i++) {
    if (this._methods[i].instance === instance) {
      return i;
    }
  }
  return -1;
};


ControlComposer.prototype.list = function() {
  var instances = [];
  for (var i = 0; i < this._methods.length; i++) {
    instances.push(this._methods[i].instance);
  }
  return instances;
};


ControlComposer.prototype._updateDynamics = function(storedDynamics, parameter, dynamics) {
  var parameterDynamics = storedDynamics[parameter];

  if (!parameterDynamics) {
    throw new Error("Unknown control parameter " + parameter);
  }

  var newTime = this._now();
  parameterDynamics.dynamics.update(dynamics, (newTime - parameterDynamics.time)/1000);
  parameterDynamics.time = newTime;

  this.emit('change');
};


ControlComposer.prototype._resetComposedOffsets = function() {
  for (var i = 0; i < this._parameters.length; i++) {
    this._composedOffsets[this._parameters[i]] = 0;
  }
};


ControlComposer.prototype.offsets = function() {
  var parameter;
  var changing = false;

  var currentTime = this._now();

  this._resetComposedOffsets();

  for (var i = 0; i < this._methods.length; i++) {
    var methodDynamics = this._methods[i].dynamics;

    for (var p = 0; p < this._parameters.length; p++) {
      parameter = this._parameters[p];
      var parameterDynamics = methodDynamics[parameter];
      var dynamics = parameterDynamics.dynamics;


      // Add offset to composed offset
      if (dynamics.offset != null) {
        this._composedOffsets[parameter] += dynamics.offset;
        // Reset offset
        dynamics.offset = null;
      }

      // Calculate offset from velocity and add it
      var elapsed = (currentTime - parameterDynamics.time)/1000;
      var offsetFromVelocity = dynamics.offsetFromVelocity(elapsed);

      if(offsetFromVelocity) {
        this._composedOffsets[parameter] += offsetFromVelocity;
      }

      // Update velocity on dynamics
      var currentVelocity = dynamics.velocityAfter(elapsed);
      dynamics.velocity = currentVelocity;

      // If there is still a velocity, set changing
      if(currentVelocity) {
        changing = true;
      }

      parameterDynamics.time = currentTime;
    }
  }

  this._composeReturn.changing = changing;
  return this._composeReturn;
};


ControlComposer.prototype.destroy = function() {
  var instances = this.list();
  for (var i = 0; i < instances.length; i++) {
    this.remove(instances[i]);
  }

  clearOwnProperties(this);
};


module.exports = ControlComposer;

},{"../util/clearOwnProperties":82,"../util/now":99,"./Dynamics":40,"minimal-event-emitter":14}],37:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('../util/defaults');
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOpts = {
  active: 'move',
  inactive: 'default',
  disabled: 'default'
};

/**
 * @class ControlCursor
 * @classdesc
 *
 * Sets the CSS cursor on a DOM element according to the state of a
 * {@link ControlMethod}.
 *
 * @param {Controls} controls Controls instance containing the control method.
 * @param {string} id ID of the control method.
 * @param {Element} element DOM element where the cursor should be set.
 * @param {Object} opts The control cursors. Each field must be a valid value
 *     for the `cursor` CSS property.
 * @param {string} [opts.active='move'] Cursor to set when the control method
 *     is enabled and active.
 * @param {string} [opts.inactive='default'] Cursor to set when the control
 *     method is enabled and inactive.
 * @param {string} [opts.disabled='default'] Cursor to set when the control
 *     method is disabled.
 */
function ControlCursor(controls, id, element, opts) {
  opts = defaults(opts || {}, defaultOpts);

  // TODO: This class may misbehave if the control method is unregistered and a
  // different control method is registered under the same id.

  this._element = element;
  this._controls = controls;
  this._id = id;

  this._attached = false;

  this._setActiveCursor = this._setCursor.bind(this, opts.active);
  this._setInactiveCursor = this._setCursor.bind(this, opts.inactive);
  this._setDisabledCursor = this._setCursor.bind(this, opts.disabled);
  this._setOriginalCursor = this._setCursor.bind(this, this._element.style.cursor);

  this._updateAttachmentHandler = this._updateAttachment.bind(this);

  controls.addEventListener('methodEnabled', this._updateAttachmentHandler);
  controls.addEventListener('methodDisabled', this._updateAttachmentHandler);
  controls.addEventListener('enabled', this._updateAttachmentHandler);
  controls.addEventListener('disabled', this._updateAttachmentHandler);

  this._updateAttachment();
}

/**
 * Destructor.
 */
ControlCursor.prototype.destroy = function() {
  this._detachFromControlMethod(this._controls.method(this._id));
  this._setOriginalCursor();

  this._controls.removeEventListener('methodEnabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('methodDisabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('enabled',
      this._updateAttachmentHandler);
  this._controls.removeEventListener('disabled',
      this._updateAttachmentHandler);

  clearOwnProperties(this);
};

ControlCursor.prototype._updateAttachment = function() {
  var controls = this._controls;
  var id = this._id;
  if (controls.enabled() && controls.method(id).enabled) {
    this._attachToControlMethod(controls.method(id));
  } else {
    this._detachFromControlMethod(controls.method(id));
  }
};

ControlCursor.prototype._attachToControlMethod = function(controlMethod) {
  if (!this._attached) {
    controlMethod.instance.addEventListener('active', this._setActiveCursor);
    controlMethod.instance.addEventListener('inactive', this._setInactiveCursor);

    if (controlMethod.active) {
      this._setActiveCursor();
    } else {
      this._setInactiveCursor();
    }

    this._attached = true;
  }
};

ControlCursor.prototype._detachFromControlMethod = function(controlMethod) {
  if (this._attached) {
    controlMethod.instance.removeEventListener('active', this._setActiveCursor);
    controlMethod.instance.removeEventListener('inactive', this._setInactiveCursor);

    this._setDisabledCursor();

    this._attached = false;
  }
};

ControlCursor.prototype._setCursor = function(cursor) {
  this._element.style.cursor = cursor;
}

module.exports = ControlCursor;

},{"../util/clearOwnProperties":82,"../util/defaults":87}],38:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Composer = require('./Composer');
var clearOwnProperties = require('../util/clearOwnProperties');

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.controls;

/**
 * @class Controls
 * @classdesc
 *
 * Set of controls which affect a view (e.g. keyboard, touch)
 *
 * {@link ControlMethod} instances can be registered on this class. The methods
 * are then combined to calculate the final parameters to change the {@link View}.
 *
 * Controls is attached to a {@link RenderLoop}. Currently it affects the
 * {@link view} of all {@link Layer} on the {@link Stage} of the
 * {@link RenderLoop} it is attached to. A more flexible API may be provided
 * in the future.
 *
 * The ControlMethod instances are registered with an id and may be enabled,
 * disabled and unregistered using that id. The whole Control can also be
 * enabled or disabled.
 *
 */
function Controls(opts) {
  opts = opts || {};

  this._methods = {};
  this._methodGroups = {};
  this._composer = new Composer();

  // Whether the controls are enabled.
  this._enabled = (opts && opts.enabled) ? !!opts.enabled : true;

  // How many control methods are enabled and in the active state.
  this._activeCount = 0;

  this.updatedViews_ = [];

  this._attachedRenderLoop = null;
}

eventEmitter(Controls);

/**
 * Destructor.
 */
Controls.prototype.destroy = function() {
  this.detach();
  this._composer.destroy();
  clearOwnProperties(this);
};


/**
 * @return {ControlMethod[]} List of registered @{link ControlMethod instances}
 */
Controls.prototype.methods = function() {
  var obj = {};
  for (var id in this._methods) {
    obj[id] = this._methods[id];
  }
  return obj;
};

/**
 * @param {String} id
 * @return {ControlMethod}
 */
Controls.prototype.method = function(id) {
  return this._methods[id];
};

/**
 * @param {String} id
 * @param {ControlMethod} instance
 * @param {Boolean} [enable=false]
 */
Controls.prototype.registerMethod = function(id, instance, enable) {
  if (this._methods[id]) {
    throw new Error('Control method already registered with id ' + id);
  }

  this._methods[id] = {
    instance: instance,
    enabled: false,
    active: false,
    activeHandler: this._handleActive.bind(this, id),
    inactiveHandler: this._handleInactive.bind(this, id)
  };

  if(enable) {
    this.enableMethod(id, instance);
  }
};


/**
 * @param {String} id
 */
Controls.prototype.unregisterMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (method.enabled) {
    this.disableMethod(id);
  }
  delete this._methods[id];
};

/**
 * @param {String} id
 */
Controls.prototype.enableMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (method.enabled) {
    return;
  }
  method.enabled = true;
  if (method.active) {
    this._incrementActiveCount();
  }
  this._listen(id);
  this._updateComposer();
  this.emit('methodEnabled', id);
};


/**
 * @param {String} id
 */
Controls.prototype.disableMethod = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('No control method registered with id ' + id);
  }
  if (!method.enabled) {
    return;
  }
  method.enabled = false;
  if (method.active) {
    this._decrementActiveCount();
  }
  this._unlisten(id);
  this._updateComposer();
  this.emit('methodDisabled', id);
};


/**
 * Create a method group, which can be used to more conveniently enable or
 * disable several control methods at once
 * @param {String} groupId
 * @param {String[]} methodIds
 */
Controls.prototype.addMethodGroup = function(groupId, methodIds) {
  this._methodGroups[groupId] = methodIds;
}

/**
 * @param {String} groupId
 */
Controls.prototype.removeMethodGroup = function(id) {
  delete this._methodGroups[id];
}

/**
 * @return {ControlMethodGroup[]} List of control method groups
 */
Controls.prototype.methodGroups = function() {
  var obj = {};
  for (var id in this._methodGroups) {
    obj[id] = this._methodGroups[id];
  }
  return obj;
}

/**
 * Enables all the control methods in the group
 * @param {String} groupId
 */
Controls.prototype.enableMethodGroup = function(id) {
  var self = this;
  self._methodGroups[id].forEach(function(methodId) {
    self.enableMethod(methodId);
  });
}

/**
 * Disables all the control methods in the group
 * @param {String} groupId
 */
Controls.prototype.disableMethodGroup = function(id) {
  var self = this;
  self._methodGroups[id].forEach(function(methodId) {
    self.disableMethod(methodId);
  });
}

/**
 * @returns {Boolean}
 */
Controls.prototype.enabled = function() {
  return this._enabled;
};

/**
 * Enables the controls
 */
Controls.prototype.enable = function() {
  if (this._enabled) {
    return;
  }
  this._enabled = true;
  if (this._activeCount > 0) {
    this.emit('active');
  }
  this.emit('enabled');
  this._updateComposer();
};


/**
 * Disables the controls
 */
Controls.prototype.disable = function() {
  if (!this._enabled) {
    return;
  }
  this._enabled = false;
  if (this._activeCount > 0) {
    this.emit('inactive');
  }
  this.emit('disabled');
  this._updateComposer();
};



/**
 * Attaches the controls to a {@link RenderLoop}. The RenderLoop will be woken
 * up when the controls are activated
 *
 * @param {RenderLoop}
 */
Controls.prototype.attach = function(renderLoop) {
  if (this._attachedRenderLoop) {
    this.detach();
  }

  this._attachedRenderLoop = renderLoop;
  this._beforeRenderHandler = this._updateViewsWithControls.bind(this);
  this._changeHandler = renderLoop.renderOnNextFrame.bind(renderLoop);

  this._attachedRenderLoop.addEventListener('beforeRender', this._beforeRenderHandler);
  this._composer.addEventListener('change', this._changeHandler);
};

/**
 * Detaches the controls
 */
Controls.prototype.detach = function() {
  if (!this._attachedRenderLoop) {
    return;
  }

  this._attachedRenderLoop.removeEventListener('beforeRender', this._beforeRenderHandler);
  this._composer.removeEventListener('change', this._changeHandler);

  this._beforeRenderHandler = null;
  this._changeHandler = null;
  this._attachedRenderLoop = null;
};

/**
 * @param {Boolean}
 */
Controls.prototype.attached = function() {
  return this._attachedRenderLoop != null;
};


Controls.prototype._listen = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  method.instance.addEventListener('active', method.activeHandler);
  method.instance.addEventListener('inactive', method.inactiveHandler);
};


Controls.prototype._unlisten = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  method.instance.removeEventListener('active', method.activeHandler);
  method.instance.removeEventListener('inactive', method.inactiveHandler);
};


Controls.prototype._handleActive = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  if (!method.enabled) {
    throw new Error('Should not receive event from disabled control method');
  }
  if (!method.active) {
    method.active = true;
    this._incrementActiveCount();
  }
};


Controls.prototype._handleInactive = function(id) {
  var method = this._methods[id];
  if (!method) {
    throw new Error('Bad method id');
  }
  if (!method.enabled) {
    throw new Error('Should not receive event from disabled control method');
  }
  if (method.active) {
    method.active = false;
    this._decrementActiveCount();
  }
};


Controls.prototype._incrementActiveCount = function() {
  this._activeCount++;
  if (debug) {
    this._checkActiveCount();
  }
  if (this._enabled && this._activeCount === 1) {
    this.emit('active');
  }
};


Controls.prototype._decrementActiveCount = function() {
  this._activeCount--;
  if (debug) {
    this._checkActiveCount();
  }
  if (this._enabled && this._activeCount === 0) {
    this.emit('inactive');
  }
};


Controls.prototype._checkActiveCount = function() {
  var count = 0;
  for (var id in this._methods) {
    var method = this._methods[id];
    if (method.enabled && method.active) {
      count++;
    }
  }
  if (count != this._activeCount) {
    throw new Error('Bad control state');
  }
};


Controls.prototype._updateComposer = function() {
  var composer = this._composer;

  for (var id in this._methods) {
    var method = this._methods[id];
    var enabled = this._enabled && method.enabled;

    if (enabled && !composer.has(method.instance)) {
      composer.add(method.instance);
    }
    if (!enabled && composer.has(method.instance)) {
      composer.remove(method.instance);
    }
  }
};


Controls.prototype._updateViewsWithControls = function() {
  var controlData = this._composer.offsets();
  if (controlData.changing) {
    this._attachedRenderLoop.renderOnNextFrame();
  }

  // Update each view at most once, even when shared by multiple layers.
  // The number of views is expected to be small, so use an array to keep track.
  this.updatedViews_.length = 0;

  var layers = this._attachedRenderLoop.stage().listLayers();
  for (var i = 0; i < layers.length; i++) {
    var view = layers[i].view();
    if (this.updatedViews_.indexOf(view) < 0) {
      layers[i].view().updateWithControlParameters(controlData.offsets);
      this.updatedViews_.push(view);
    }
  }
};


module.exports = Controls;

},{"../util/clearOwnProperties":82,"./Composer":36,"minimal-event-emitter":14}],39:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var defaults = require('../util/defaults');
var maxFriction = require('./util').maxFriction;
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOptions = {
  friction: 6,
  maxFrictionTime: 0.3,
  hammerEvent: 'pan'
};

var debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.controls;

/**
 * @class DragControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the view by clicking/tapping and dragging.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use (e.g.
 * `mouse` or `touch`).
 * @param {Object} opts
 * @param {number} opts.friction
 * @param {number} opts.maxFrictionTime
 * @param {'pan'|'pinch'} opts.hammerEvent
 */
function DragControlMethod(element, pointerType, opts) {
  this._element = element;

  this._opts = defaults(opts || {}, defaultOptions);

  this._startEvent = null;
  this._lastEvent = null;

  this._active = false;

  this._dynamics = {
    x: new Dynamics(),
    y: new Dynamics()
  };

  this._hammer = HammerGestures.get(element, pointerType);

  this._hammer.on("hammer.input", this._handleHammerEvent.bind(this));

  if (this._opts.hammerEvent != 'pan' && this._opts.hammerEvent != 'pinch') {
    throw new Error(this._opts.hammerEvent + ' is not a hammerEvent managed in DragControlMethod');
  }

  this._hammer.on(this._opts.hammerEvent + 'start', this._handleStart.bind(this));
  this._hammer.on(this._opts.hammerEvent + 'move', this._handleMove.bind(this));
  this._hammer.on(this._opts.hammerEvent + 'end', this._handleEnd.bind(this));
  this._hammer.on(this._opts.hammerEvent + 'cancel', this._handleEnd.bind(this));
}

eventEmitter(DragControlMethod);

/**
 * Destructor.
 */
DragControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};

DragControlMethod.prototype._handleHammerEvent = function(e) {
  if (e.isFirst) {
    if (debug && this._active) {
      throw new Error('DragControlMethod active detected when already active');
    }
    this._active = true;
    this.emit('active');
  }
  if (e.isFinal) {
    if (debug && !this._active) {
      throw new Error('DragControlMethod inactive detected when already inactive');
    }
    this._active = false;
    this.emit('inactive');
  }
};

DragControlMethod.prototype._handleStart = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  this._startEvent = e;
};


DragControlMethod.prototype._handleMove = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  if (this._startEvent) {
    this._updateDynamicsMove(e);
    this.emit('parameterDynamics', 'axisScaledX', this._dynamics.x);
    this.emit('parameterDynamics', 'axisScaledY', this._dynamics.y);
  }
};


DragControlMethod.prototype._handleEnd = function(e) {
  // Prevent this event from dragging other DOM elements, causing
  // unexpected behavior on Chrome.
  e.preventDefault();

  if (this._startEvent) {
    this._updateDynamicsRelease(e);
    this.emit('parameterDynamics', 'axisScaledX', this._dynamics.x);
    this.emit('parameterDynamics', 'axisScaledY', this._dynamics.y);
  }

  this._startEvent = false;
  this._lastEvent = false;
};


DragControlMethod.prototype._updateDynamicsMove = function(e) {
  var x = e.deltaX;
  var y = e.deltaY;

  // When a second finger touches the screen, panstart sometimes has a large
  // offset at start; subtract that offset to prevent a sudden jump.
  var eventToSubtract = this._lastEvent || this._startEvent;

  if (eventToSubtract) {
    x -= eventToSubtract.deltaX;
    y -= eventToSubtract.deltaY;
  }

  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;

  x /= width;
  y /= height;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.offset = -x;
  this._dynamics.y.offset = -y;

  this._lastEvent = e;
};


var tmpReleaseFriction = [ null, null ];
DragControlMethod.prototype._updateDynamicsRelease = function(e) {
  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;

  var x = 1000 * e.velocityX / width;
  var y = 1000 * e.velocityY / height;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.velocity = x;
  this._dynamics.y.velocity = y;

  maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
  this._dynamics.x.friction = tmpReleaseFriction[0];
  this._dynamics.y.friction = tmpReleaseFriction[1];
};


module.exports = DragControlMethod;

},{"../util/clearOwnProperties":82,"../util/defaults":87,"./Dynamics":40,"./HammerGestures":42,"./util":49,"minimal-event-emitter":14}],40:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class Dynamics
 * @classdesc
 *
 * Represents how a control parameter changes. Used in the events emitted by
 * {@link ControlMethod}.
 *
 * @property {number} offset Parameter changed by a fixed value
 * @property {number} velocity Parameter is changing at this velocity
 * @property {number} friction The velocity will decrease at this rate
 */
function Dynamics() {
  this.velocity = null;
  this.friction = null;
  this.offset = null;
}

Dynamics.equals = function(d1, d2) {
  return d1.velocity === d2.velocity && d1.friction === d2.friction && d1.offset === d2.offset;
};

Dynamics.prototype.equals = function(other) {
  return Dynamics.equals(this, other);
};

Dynamics.prototype.update = function(other, elapsed) {
  if (other.offset) {
    // If other has an offset, make this.offset a number instead of null
    this.offset = this.offset || 0;
    this.offset += other.offset;
  }

  var offsetFromVelocity = this.offsetFromVelocity(elapsed);
  if (offsetFromVelocity) {
    // If there is an offset to add from the velocity, make this offset a number instead of null
    this.offset = this.offset || 0;
    this.offset += offsetFromVelocity;
  }

  this.velocity = other.velocity;
  this.friction = other.friction;
};

Dynamics.prototype.reset = function() {
  this.velocity = null;
  this.friction = null;
  this.offset = null;
};


Dynamics.prototype.velocityAfter = function(elapsed) {
  if (!this.velocity) {
    return null;
  }
  if (this.friction) {
    return decreaseAbs(this.velocity, this.friction *elapsed);
  }
  return this.velocity;
};

Dynamics.prototype.offsetFromVelocity = function(elapsed) {
  elapsed = Math.min(elapsed, this.nullVelocityTime());

  var velocityEnd = this.velocityAfter(elapsed);
  var averageVelocity = (this.velocity + velocityEnd) / 2;

  return averageVelocity * elapsed;
};


Dynamics.prototype.nullVelocityTime = function() {
  if (this.velocity == null) {
    return 0;
  }
  if (this.velocity && !this.friction) {
    return Infinity;
  }
  return Math.abs(this.velocity / this.friction);
};

function decreaseAbs(num, dec) {
  if (num < 0) {
    return Math.min(0, num + dec);
  }
  if (num > 0) {
    return Math.max(0, num - dec);
  }
  return 0;
}

module.exports = Dynamics;

},{}],41:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class ElementPressControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter by pressing and
 * unpressing a DOM element.
 *
 * @param {Element} element Element which activates the method when pressed
 * @param {string} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
 * @param {number} velocity Velocity at which the parameter changes. Use a
 * negative number for opposite direction
 * @param {number} friction Friction at which the parameter stops
*/
function ElementPressControlMethod(element, parameter, velocity, friction) {
  if(!element) {
    throw new Error("ElementPressControlMethod: element must be defined");
  }
  if(!parameter) {
    throw new Error("ElementPressControlMethod: parameter must be defined");
  }
  if(!velocity) {
    throw new Error("ElementPressControlMethod: velocity must be defined");
  }
  if(!friction) {
    throw new Error("ElementPressControlMethod: friction must be defined");
  }

  this._element = element;

  this._pressHandler = this._handlePress.bind(this);
  this._releaseHandler = this._handleRelease.bind(this);

  element.addEventListener('mousedown', this._pressHandler);
  element.addEventListener('mouseup', this._releaseHandler);
  element.addEventListener('mouseleave', this._releaseHandler);
  element.addEventListener('touchstart', this._pressHandler);
  element.addEventListener('touchmove', this._releaseHandler);
  element.addEventListener('touchend', this._releaseHandler);

  this._parameter = parameter;
  this._velocity = velocity;
  this._friction = friction;
  this._dynamics = new Dynamics();

  this._pressing = false;
}
eventEmitter(ElementPressControlMethod);

/**
 * Destructor.
 */
ElementPressControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('mousedown', this._pressHandler);
  this._element.removeEventListener('mouseup', this._releaseHandler);
  this._element.removeEventListener('mouseleave', this._releaseHandler);
  this._element.removeEventListener('touchstart', this._pressHandler);
  this._element.removeEventListener('touchmove', this._releaseHandler);
  this._element.removeEventListener('touchend', this._releaseHandler);
  clearOwnProperties(this);
};

ElementPressControlMethod.prototype._handlePress = function() {
  this._pressing = true;

  this._dynamics.velocity = this._velocity;
  this._dynamics.friction = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('active');
};

ElementPressControlMethod.prototype._handleRelease = function() {
  if(this._pressing) {
    this._dynamics.friction = this._friction;
    this.emit('parameterDynamics', this._parameter, this._dynamics);
    this.emit('inactive');
  }

  this._pressing = false;
};

module.exports = ElementPressControlMethod;

},{"../util/clearOwnProperties":82,"./Dynamics":40,"minimal-event-emitter":14}],42:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Hammer = require('hammerjs');

var nextId = 1;
var idProperty = 'MarzipanoHammerElementId';
function getKeyForElementAndType(element, type) {
  if (!element[idProperty]) {
    element[idProperty] = nextId++;
  }
  return type + element[idProperty];
}


/**
 * @class HammerGestures
 * @classdesc
 *
 * Manages Hammer.js instances. One instance is created for each combination of
 * DOM element and pointer type.
 */
function HammerGestures() {
  this._managers = {};
  this._refCount = {};
}


HammerGestures.prototype.get = function(element, type) {
  var key = getKeyForElementAndType(element, type);
  if (!this._managers[key]) {
    this._managers[key] = this._createManager(element, type);
    this._refCount[key] = 0;
  }
  this._refCount[key]++;
  return new HammerGesturesHandle(this, this._managers[key], element, type);
};


HammerGestures.prototype._createManager = function(element, type) {
  var manager = new Hammer.Manager(element);

  // Managers are created with different parameters for different pointer
  // types.
  if (type === 'mouse') {
    manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 0 }));
  }
  else if (type === 'touch' || type === 'pen' || type === 'kinect') {
    // On touch one wants to have both panning and pinching. The panning
    // recognizer needs a threshold to allow the pinch to be recognized.
    manager.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 20, pointers: 1 }));
    manager.add(new Hammer.Pinch());
  }

  return manager;
};


HammerGestures.prototype._releaseHandle = function(element, type) {
  var key = getKeyForElementAndType(element, type);
  if (this._refCount[key]) {
    this._refCount[key]--;
    if (!this._refCount[key]) {
      this._managers[key].destroy();
      delete this._managers[key];
      delete this._refCount[key];
    }
  }
};


function HammerGesturesHandle(hammerGestures, manager, element, type) {
  this._manager = manager;
  this._element = element;
  this._type = type;
  this._hammerGestures = hammerGestures;
  this._eventHandlers = [];
}


HammerGesturesHandle.prototype.on = function(events, handler) {
  var type = this._type;
  var handlerFilteredEvents = function(e) {
    if (type === e.pointerType) {
      handler(e);
    }
  };

  this._eventHandlers.push({ events: events, handler: handlerFilteredEvents });
  this._manager.on(events, handlerFilteredEvents);
};


HammerGesturesHandle.prototype.release = function() {
  for (var i = 0; i < this._eventHandlers.length; i++) {
    var eventHandler = this._eventHandlers[i];
    this._manager.off(eventHandler.events, eventHandler.handler);
  }

  this._hammerGestures._releaseHandle(this._element, this._type);
  this._manager = null;
  this._element = null;
  this._type = null;
  this._hammerGestures = null;
};


HammerGesturesHandle.prototype.manager = function() {
  return this._manager;
};


module.exports = new HammerGestures();

},{"hammerjs":13}],43:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class KeyControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter by pressing and
 * unpressing a key.
 *
 * @param {number} keyCode Key which activates the method when pressed
 * @param {string} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
 * @param {number} velocity Velocity at which the parameter changes. Use a
 * negative number for opposite direction
 * @param {number} friction Friction at which the parameter stops
 * @param {Element} [element=document] DOM element where the key events are listened to
 */
function KeyControlMethod(keyCode, parameter, velocity, friction, element) {
  if(!keyCode) {
    throw new Error("KeyControlMethod: keyCode must be defined");
  }
  if(!parameter) {
    throw new Error("KeyControlMethod: parameter must be defined");
  }
  if(!velocity) {
    throw new Error("KeyControlMethod: velocity must be defined");
  }
  if(!friction) {
    throw new Error("KeyControlMethod: friction must be defined");
  }

  element = element || document;

  this._keyCode = keyCode;
  this._parameter = parameter;
  this._velocity = velocity;
  this._friction = friction;
  this._element = element;

  this._keydownHandler = this._handlePress.bind(this);
  this._keyupHandler = this._handleRelease.bind(this);
  this._blurHandler = this._handleBlur.bind(this);

  this._element.addEventListener('keydown', this._keydownHandler);
  this._element.addEventListener('keyup', this._keyupHandler);
  window.addEventListener('blur', this._blurHandler);

  this._dynamics = new Dynamics();
  this._pressing = false;
}
eventEmitter(KeyControlMethod);

/**
 * Destructor.
 */
KeyControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('keydown', this._keydownHandler);
  this._element.removeEventListener('keyup', this._keyupHandler);
  window.removeEventListener('blur', this._blurHandler);
  clearOwnProperties(this);
};

KeyControlMethod.prototype._handlePress = function(e) {
  if(e.keyCode !== this._keyCode) { return; }

  this._pressing = true;

  this._dynamics.velocity = this._velocity;
  this._dynamics.friction = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('active');
};

KeyControlMethod.prototype._handleRelease = function(e) {
  if(e.keyCode !== this._keyCode) { return; }

  if(this._pressing) {
    this._dynamics.friction = this._friction;
    this.emit('parameterDynamics', this._parameter, this._dynamics);
    this.emit('inactive');
  }

  this._pressing = false;
};

KeyControlMethod.prototype._handleBlur = function() {
  this._dynamics.velocity = 0;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
  this.emit('inactive');

  this._pressing = false;
};

module.exports = KeyControlMethod;

},{"../util/clearOwnProperties":82,"./Dynamics":40,"minimal-event-emitter":14}],44:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class PinchZoomControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Control the view fov/zoom by pinching with two fingers.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use
 * @param {Object} opts
 */
function PinchZoomControlMethod(element, pointerType, opts) {
  this._hammer = HammerGestures.get(element, pointerType);

  this._lastEvent = null;

  this._active = false;

  this._dynamics = new Dynamics();

  this._hammer.on('pinchstart', this._handleStart.bind(this));
  this._hammer.on('pinch', this._handleEvent.bind(this));
  this._hammer.on('pinchend', this._handleEnd.bind(this));
  this._hammer.on('pinchcancel', this._handleEnd.bind(this));
}

eventEmitter(PinchZoomControlMethod);

/**
 * Destructor.
 */
PinchZoomControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};


PinchZoomControlMethod.prototype._handleStart = function() {
  if (!this._active) {
    this._active = true;
    this.emit('active');
  }
};


PinchZoomControlMethod.prototype._handleEnd = function() {
  this._lastEvent = null;

  if (this._active) {
    this._active = false;
    this.emit('inactive');
  }
};


PinchZoomControlMethod.prototype._handleEvent = function(e) {
  var scale = e.scale;

  if (this._lastEvent) {
    scale /= this._lastEvent.scale;
  }

  this._dynamics.offset = (scale - 1) * -1;
  this.emit('parameterDynamics', 'zoom', this._dynamics);

  this._lastEvent = e;
};


module.exports = PinchZoomControlMethod;

},{"../util/clearOwnProperties":82,"./Dynamics":40,"./HammerGestures":42,"minimal-event-emitter":14}],45:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var HammerGestures = require('./HammerGestures');
var defaults = require('../util/defaults');
var maxFriction = require('./util').maxFriction;
var clearOwnProperties = require('../util/clearOwnProperties');


var defaultOptions = {
  speed: 8,
  friction: 6,
  maxFrictionTime: 0.3
};


/**
 * @class QtvrControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the view by holding the mouse button down and moving it.
 * Also known as "QTVR" control mode.
 *
 * @param {Element} element Element to listen for events.
 * @param {string} pointerType Which Hammer.js pointer type to use (e.g.
 * `mouse` or `touch`).
 * @param {Object} opts
 * @param {number} opts.speed
 * @param {number} opts.friction
 * @param {number} opts.maxFrictionTime
 */
// TODO: allow speed not change linearly with distance to click spot.
// Quadratic or other would allow a larger speed range.
function QtvrControlMethod(element, pointerType, opts) {
  this._element = element;

  this._opts = defaults(opts || {}, defaultOptions);

  this._active = false;

  this._hammer = HammerGestures.get(element, pointerType);

  this._dynamics = {
    x: new Dynamics(),
    y: new Dynamics()
  };

  this._hammer.on('panstart', this._handleStart.bind(this));
  this._hammer.on('panmove', this._handleMove.bind(this));
  this._hammer.on('panend', this._handleRelease.bind(this));
  this._hammer.on('pancancel', this._handleRelease.bind(this));
}

eventEmitter(QtvrControlMethod);

/**
 * Destructor.
 */
QtvrControlMethod.prototype.destroy = function() {
  this._hammer.release();
  clearOwnProperties(this);
};


QtvrControlMethod.prototype._handleStart = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  if (!this._active) {
    this._active = true;
    this.emit('active');
  }
};


QtvrControlMethod.prototype._handleMove = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  this._updateDynamics(e, false);
};


QtvrControlMethod.prototype._handleRelease = function(e) {
  // Prevent event dragging other DOM elements and causing strange behavior on Chrome
  e.preventDefault();

  this._updateDynamics(e, true);

  if (this._active) {
    this._active = false;
    this.emit('inactive');
  }
};


var tmpReleaseFriction = [ null, null ];
QtvrControlMethod.prototype._updateDynamics = function(e, release) {
  var elementRect = this._element.getBoundingClientRect();
  var width = elementRect.right - elementRect.left;
  var height = elementRect.bottom - elementRect.top;
  var maxDim = Math.max(width, height);

  var x = e.deltaX / maxDim * this._opts.speed;
  var y = e.deltaY / maxDim * this._opts.speed;

  this._dynamics.x.reset();
  this._dynamics.y.reset();
  this._dynamics.x.velocity = x;
  this._dynamics.y.velocity = y;

  if (release) {
    maxFriction(this._opts.friction, this._dynamics.x.velocity, this._dynamics.y.velocity, this._opts.maxFrictionTime, tmpReleaseFriction);
    this._dynamics.x.friction = tmpReleaseFriction[0];
    this._dynamics.y.friction = tmpReleaseFriction[1];
  }

  this.emit('parameterDynamics', 'x', this._dynamics.x);
  this.emit('parameterDynamics', 'y', this._dynamics.y);
};


module.exports = QtvrControlMethod;

},{"../util/clearOwnProperties":82,"../util/defaults":87,"./Dynamics":40,"./HammerGestures":42,"./util":49,"minimal-event-emitter":14}],46:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var defaults = require('../util/defaults');
var clearOwnProperties = require('../util/clearOwnProperties');

var defaultOptions = {
  frictionTime: 0.2,
  zoomDelta: 0.001
};

/**
 * @class ScrollZoomControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Controls the fov/zoom through the mouse wheel.
 *
 * @param {Element} element Element to listen for events.
 * @param {Object} opts
 * @param {number} [opts.frictionTime=0.2]
 * @param {number} [opts.zoomDelta=0.001]
 */
function ScrollZoomControlMethod(element, opts) {
  this._element = element;
  this._opts = defaults(opts || {}, defaultOptions);
  this._dynamics = new Dynamics();
  this._eventList = [];

  var fn = this._opts.frictionTime ? this.withSmoothing : this.withoutSmoothing;
  this._wheelListener = fn.bind(this);
  
  element.addEventListener('wheel', this._wheelListener);
}

eventEmitter(ScrollZoomControlMethod);

/**
 * Destructor.
 */
ScrollZoomControlMethod.prototype.destroy = function() {
  this._element.removeEventListener('wheel', this._wheelListener);
  clearOwnProperties(this);
};


ScrollZoomControlMethod.prototype.withoutSmoothing = function(e) {
  this._dynamics.offset = wheelEventDelta(e) * this._opts.zoomDelta;
  this.emit('parameterDynamics', 'zoom', this._dynamics);

  e.preventDefault();

  this.emit('active');
  this.emit('inactive');
};


ScrollZoomControlMethod.prototype.withSmoothing = function(e) {
  var currentTime = e.timeStamp;

  // Record event.
  this._eventList.push(e);

  // Remove events whose smoothing has already expired.
  while (this._eventList[0].timeStamp < currentTime - this._opts.frictionTime*1000) {
    this._eventList.shift(0);
  }

  // Get the current velocity from the recorded events.
  // Each wheel movement causes a velocity of change/frictionTime during frictionTime.
  var velocity = 0;
  for (var i = 0; i < this._eventList.length; i++) {
    var zoomChangeFromEvent = wheelEventDelta(this._eventList[i]) * this._opts.zoomDelta;
    velocity += zoomChangeFromEvent / this._opts.frictionTime;
  }

  this._dynamics.velocity = velocity;
  this._dynamics.friction = Math.abs(velocity) / this._opts.frictionTime;

  this.emit('parameterDynamics', 'zoom', this._dynamics);

  e.preventDefault();

  this.emit('active');
  this.emit('inactive');
};


function wheelEventDelta(e) {
  var multiplier = e.deltaMode == 1 ? 20 : 1;
  return e.deltaY * multiplier;
}


module.exports = ScrollZoomControlMethod;

},{"../util/clearOwnProperties":82,"../util/defaults":87,"./Dynamics":40,"minimal-event-emitter":14}],47:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var Dynamics = require('./Dynamics');
var clearOwnProperties = require('../util/clearOwnProperties');

/**
 * @class VelocityControlMethod
 * @implements ControlMethod
 * @classdesc
 *
 * Sets the velocity and friction of a single parameter.
 *
 * The user should emit 'active' and 'inactive' events if required.
 *
 * @param {String} parameter The parameter to be controlled (e.g. `x`, `y` or `zoom`)
*/
function VelocityControlMethod(parameter) {
  if(!parameter) {
    throw new Error("VelocityControlMethod: parameter must be defined");
  }

  this._parameter = parameter;
  this._dynamics = new Dynamics();
}
eventEmitter(VelocityControlMethod);

/**
 * Destructor.
 */
VelocityControlMethod.prototype.destroy = function() {
  clearOwnProperties(this);
};

/**
 * Set the parameter's velocity.
 * @param {Number} velocity
 */
VelocityControlMethod.prototype.setVelocity = function(velocity) {
  this._dynamics.velocity = velocity;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
};

/**
 * Set the parameter's friction.
 * @param {Number} friction
 */
VelocityControlMethod.prototype.setFriction = function(friction) {
  this._dynamics.friction = friction;
  this.emit('parameterDynamics', this._parameter, this._dynamics);
};

module.exports = VelocityControlMethod;

},{"../util/clearOwnProperties":82,"./Dynamics":40,"minimal-event-emitter":14}],48:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaults = require('../util/defaults');
var DragControlMethod = require('./Drag');
var QtvrControlMethod = require('./Qtvr');
var ScrollZoomControlMethod = require('./ScrollZoom');
var PinchZoomControlMethod = require('./PinchZoom');
var KeyControlMethod = require('./Key');

var defaultOptions = {
  mouseViewMode: 'drag',
  dragMode: 'pan'
};

/**
 * Instantiate and register some commonly used {@link ControlMethod} instances.
 *
 * The following instances are registered:
 *   - mouseViewDrag
 *   - mouseViewQtvr
 *   - touchView
 *   - pinch
 *   - arrowKeys
 *   - plusMinusKeys
 *   - wasdKeys
 *   - qeKeys
 *
 * @param {Controls} controls Where to register the instances.
 * @param {Element} element Element to listen for events.
 * @param {'drag'|'qtvr'} opts.mouseViewMode
 * @param {'pan'|'pinch'} opts.dragMode
 * @param {boolean} opts.scrollZoom
 */
function registerDefaultControls(controls, element, opts) {
  opts = defaults(opts || {}, defaultOptions);

  var controlMethods = {
    mouseViewDrag: new DragControlMethod(element, 'mouse'),
    mouseViewQtvr: new QtvrControlMethod(element, 'mouse'),

    leftArrowKey: new KeyControlMethod(37, 'x', -0.7, 3),
    rightArrowKey: new KeyControlMethod(39, 'x', 0.7, 3),
    upArrowKey: new KeyControlMethod(38, 'y', -0.7, 3),
    downArrowKey: new KeyControlMethod(40, 'y', 0.7, 3),
    plusKey: new KeyControlMethod(107, 'zoom', -0.7, 3),
    minusKey: new KeyControlMethod(109, 'zoom', 0.7, 3),

    wKey: new KeyControlMethod(87, 'y', -0.7, 3),
    aKey: new KeyControlMethod(65, 'x', -0.7, 3),
    sKey: new KeyControlMethod(83, 'y', 0.7, 3),
    dKey: new KeyControlMethod(68, 'x', 0.7, 3),
    qKey: new KeyControlMethod(81, 'roll', 0.7, 3),
    eKey: new KeyControlMethod(69, 'roll', -0.7, 3)
  };

  var enabledControls = ['scrollZoom', 'touchView', 'pinch' ];

  if (opts.scrollZoom !== false) {
    controlMethods.scrollZoom = new ScrollZoomControlMethod(element); //{ frictionTime: 0 }
  }

  var controlMethodGroups = {
    arrowKeys: [ 'leftArrowKey', 'rightArrowKey', 'upArrowKey', 'downArrowKey' ],
    plusMinusKeys: [ 'plusKey', 'minusKey' ],
    wasdKeys: [ 'wKey', 'aKey', 'sKey', 'dKey' ],
    qeKeys: [ 'qKey', 'eKey' ]
  };


  switch (opts.dragMode) {
    case 'pinch':
       controlMethods.pinch = new DragControlMethod(element, 'touch', { hammerEvent: 'pinch' });
      break;
    case 'pan':
      controlMethods.touchView = new DragControlMethod(element, 'touch');
      controlMethods.pinch = new PinchZoomControlMethod(element, 'touch');
      break;
    default:
      throw new Error("Unknown drag mode: " + opts.dragMode);
  }

  switch (opts.mouseViewMode) {
    case 'drag':
      enabledControls.push('mouseViewDrag');
      break;
    case 'qtvr':
      enabledControls.push('mouseViewQtvr');
      break;
    default:
      throw new Error("Unknown mouse view mode: " + opts.mouseViewMode);
  }

  for (var id in controlMethods) {
    var method = controlMethods[id];
    controls.registerMethod(id, method);
    if (enabledControls.indexOf(id) >= 0) {
      controls.enableMethod(id);
    }
  }

  for (var groupId in controlMethodGroups) {
    var methodGroup = controlMethodGroups[groupId];
    controls.addMethodGroup(groupId, methodGroup);
  }

  return controlMethods;
}

module.exports = registerDefaultControls;

},{"../util/defaults":87,"./Drag":39,"./Key":43,"./PinchZoom":44,"./Qtvr":45,"./ScrollZoom":46}],49:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function maxFriction(friction, velocityX, velocityY, maxFrictionTime, result) {
  var velocity = Math.sqrt(Math.pow(velocityX,2) + Math.pow(velocityY,2));
  friction = Math.max(friction, velocity/maxFrictionTime);
  changeVectorNorm(velocityX, velocityY, friction, result);
  result[0] = Math.abs(result[0]);
  result[1] = Math.abs(result[1]);
}

function changeVectorNorm(x, y, n, result) {
  var theta = Math.atan(y/x);
  result[0] = n * Math.cos(theta);
  result[1] = n * Math.sin(theta);
}

module.exports = {
  maxFriction: maxFriction,
  changeVectorNorm: changeVectorNorm
};
},{}],50:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var TileSearcher = require('../TileSearcher');
var LruMap = require('../collections/LruMap');
var Level = require('./Level');
var makeLevelList = require('./common').makeLevelList;
var makeSelectableLevelList = require('./common').makeSelectableLevelList;
var clamp = require('../util/clamp');
var cmp = require('../util/cmp');
var type = require('../util/type');
var vec3 = require('gl-matrix').vec3;
var vec4 = require('gl-matrix').vec4;
var mat4 = require('gl-matrix').mat4;

var neighborsCacheSize = 64;

// Initials for cube faces.
var faceList = 'fudlrb';

// Rotation of each face, relative to the front face.
var faceRotation = {
  f: { x: 0, y: 0 },
  b: { x: 0, y: Math.PI },
  l: { x: 0, y: Math.PI/2 },
  r: { x: 0, y: -Math.PI/2 },
  u: { x: Math.PI/2, y: 0 },
  d: { x: -Math.PI/2, y: 0 }
};

// Zero vector.
var origin = vec3.create();

// Rotate a vector in ZXY order.
function rotateVector(vec, z, x, y) {
  if (z) {
    vec3.rotateZ(vec, vec, origin, z);
  }
  if (x) {
    vec3.rotateX(vec, vec, origin, x);
  }
  if (y) {
    vec3.rotateY(vec, vec, origin, y);
  }
}

// Normalized vectors pointing to the center of each face.
var faceVectors = {};
for (var i = 0; i < faceList.length; i++) {
  var face = faceList[i];
  var rotation = faceRotation[face];
  var v = vec3.fromValues(0,  0, -1);
  rotateVector(v, 0, rotation.x, rotation.y);
  faceVectors[face] = v;
}

// Map each face to its adjacent faces.
// The order is as suggested by the front face.
var adjacentFace = {
  f: [ 'l', 'r', 'u', 'd' ],
  b: [ 'r', 'l', 'u', 'd' ],
  l: [ 'b', 'f', 'u', 'd' ],
  r: [ 'f', 'b', 'u', 'd' ],
  u: [ 'l', 'r', 'b', 'f' ],
  d: [ 'l', 'r', 'f', 'b' ]
};

// Offsets to apply to the (x,y) coordinates of a tile to get its neighbors.
var neighborOffsets = [
  [  0,  1 ], // top
  [  1,  0 ], // right
  [  0, -1 ], // bottom
  [ -1,  0 ]  // left
];


/**
 * @class CubeTile
 * @implements Tile
 * @classdesc
 *
 * A tile in a @{CubeGeometry}.
 */
function CubeTile(face, x, y, z, geometry) {
  this.face = face;
  this.x = x;
  this.y = y;
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


CubeTile.prototype.rotX = function() {
  return faceRotation[this.face].x;
};


CubeTile.prototype.rotY = function() {
  return faceRotation[this.face].y;
};


CubeTile.prototype.centerX = function() {
  return (this.x + 0.5) / this._level.numHorizontalTiles() - 0.5;
};


CubeTile.prototype.centerY = function() {
  return 0.5 - (this.y + 0.5) / this._level.numVerticalTiles();
};


CubeTile.prototype.scaleX = function() {
  return 1 / this._level.numHorizontalTiles();
};


CubeTile.prototype.scaleY = function() {
  return 1 / this._level.numVerticalTiles();
};


CubeTile.prototype.vertices = function(result) {
  if (!result) {
    result = [vec3.create(), vec3.create(), vec3.create(), vec3.create()];
  }

  var rot = faceRotation[this.face];

  function makeVertex(vec, x, y) {
    vec3.set(vec, x, y, -0.5);
    rotateVector(vec, 0, rot.x, rot.y);
  }

  var left = this.centerX() - this.scaleX() / 2;
  var right = this.centerX() + this.scaleX() / 2;
  var bottom = this.centerY() - this.scaleY() / 2;
  var top = this.centerY() + this.scaleY() / 2;

  makeVertex(result[0], left, top);
  makeVertex(result[1], right, top);
  makeVertex(result[2], right, bottom);
  makeVertex(result[3], left, bottom);

  return result;
};


CubeTile.prototype.parent = function() {

  if (this.z === 0) {
    return null;
  }

  var face = this.face;
  var z = this.z;
  var x = this.x;
  var y = this.y;

  var geometry = this._geometry;
  var level = geometry.levelList[z];
  var parentLevel = geometry.levelList[z-1];

  var tileX = Math.floor(x / level.numHorizontalTiles() * parentLevel.numHorizontalTiles());
  var tileY = Math.floor(y / level.numVerticalTiles() * parentLevel.numVerticalTiles());
  var tileZ = z-1;

  return new CubeTile(face, tileX, tileY, tileZ, geometry);

};


CubeTile.prototype.children = function(result) {

  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }

  var face = this.face;
  var z = this.z;
  var x = this.x;
  var y = this.y;

  var geometry = this._geometry;
  var level = geometry.levelList[z];
  var childLevel = geometry.levelList[z+1];

  var nHoriz = childLevel.numHorizontalTiles() / level.numHorizontalTiles();
  var nVert = childLevel.numVerticalTiles() / level.numVerticalTiles();

  result = result || [];

  for (var h = 0; h < nHoriz; h++) {
    for (var v = 0; v < nVert; v++) {
      var tileX = nHoriz * x + h;
      var tileY = nVert * y + v;
      var tileZ = z+1;
      result.push(new CubeTile(face, tileX, tileY, tileZ, geometry));
    }
  }

  return result;

};


CubeTile.prototype.neighbors = function() {

  var geometry = this._geometry;
  var cache = geometry._neighborsCache;

  // Satisfy from cache when available.
  var cachedResult = cache.get(this);
  if (cachedResult) {
    return cachedResult;
  }

  var vec = geometry._vec;

  var face = this.face;
  var x = this.x;
  var y = this.y;
  var z = this.z;
  var level = this._level;

  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  var result = [];

  for (var i = 0; i < neighborOffsets.length; i++) {
    var xOffset = neighborOffsets[i][0];
    var yOffset = neighborOffsets[i][1];

    var newX = x + xOffset;
    var newY = y + yOffset;
    var newZ = z;
    var newFace = face;

    if (newX < 0 || newX >= numX || newY < 0 || newY >= numY) {

      // If the neighboring tile belongs to a different face, calculate a
      // vector pointing to the edge between the two faces at the point the
      // tile and its neighbor meet, and convert it into tile coordinates for
      // the neighboring face.

      var xCoord = this.centerX();
      var yCoord = this.centerY();

      // First, calculate the vector as if the initial tile belongs to the
      // front face, so that the tile x,y coordinates map directly into the
      // x,y axes.

      if (newX < 0) {
        vec3.set(vec, -0.5, yCoord, -0.5);
        newFace = adjacentFace[face][0];
      } else if (newX >= numX) {
        vec3.set(vec, 0.5, yCoord, -0.5);
        newFace = adjacentFace[face][1];
      } else if (newY < 0) {
        vec3.set(vec, xCoord, 0.5, -0.5);
        newFace = adjacentFace[face][2];
      } else if (newY >= numY) {
        vec3.set(vec, xCoord, -0.5, -0.5);
        newFace = adjacentFace[face][3];
      }

      var rot;

      // Then, rotate the vector into the actual face the initial tile
      // belongs to.

      rot = faceRotation[face];
      rotateVector(vec, 0, rot.x, rot.y);

      // Finally, rotate the vector from the neighboring face into the front
      // face. Again, this is so that the neighboring tile x,y coordinates
      // map directly into the x,y axes.

      rot = faceRotation[newFace];
      rotateVector(vec, 0, -rot.x, -rot.y);

      // Calculate the neighboring tile coordinates.

      newX = clamp(Math.floor((0.5 + vec[0]) * numX), 0, numX - 1);
      newY = clamp(Math.floor((0.5 - vec[1]) * numY), 0, numY - 1);
    }

    result.push(new CubeTile(newFace, newX, newY, newZ, geometry));
  }

  // Store into cache to satisfy future requests.
  cache.set(this, result);

  return result;

};


CubeTile.prototype.hash = function() {
  return hash(faceList.indexOf(this.face), this.z, this.y, this.x);
};


CubeTile.prototype.equals = function(that) {
  return (this._geometry === that._geometry &&
      this.face === that.face &&
      this.z === that.z &&
      this.y === that.y &&
      this.x === that.x);
};


CubeTile.prototype.cmp = function(that) {
  return (cmp(this.z, that.z) ||
  cmp(faceList.indexOf(this.face), faceList.indexOf(that.face)) ||
  cmp(this.y, that.y) || cmp(this.x, that.x));
};


CubeTile.prototype.str = function() {
  return 'CubeTile(' + tile.face + ', ' + tile.x + ', ' + tile.y + ', ' + tile.z + ')';
};


function CubeLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);

  this._size = levelProperties.size;
  this._tileSize = levelProperties.tileSize;

  if (this._size % this._tileSize !== 0) {
    throw new Error('Level size is not multiple of tile size: ' +
                    this._size + ' ' + this._tileSize);
  }
}

inherits(CubeLevel, Level);


CubeLevel.prototype.width = function() {
  return this._size;
};


CubeLevel.prototype.height = function() {
  return this._size;
};


CubeLevel.prototype.tileWidth = function() {
  return this._tileSize;
};


CubeLevel.prototype.tileHeight = function() {
  return this._tileSize;
};


CubeLevel.prototype._validateWithParentLevel = function(parentLevel) {

  var width = this.width();
  var height = this.height();
  var tileWidth = this.tileWidth();
  var tileHeight = this.tileHeight();
  var numHorizontal = this.numHorizontalTiles();
  var numVertical = this.numVerticalTiles();

  var parentWidth = parentLevel.width();
  var parentHeight = parentLevel.height();
  var parentTileWidth = parentLevel.tileWidth();
  var parentTileHeight = parentLevel.tileHeight();
  var parentNumHorizontal = parentLevel.numHorizontalTiles();
  var parentNumVertical = parentLevel.numVerticalTiles();

  if (width % parentWidth !== 0) {
    throw new Error('Level width must be multiple of parent level: ' +
                    width + ' vs. ' + parentWidth);
  }

  if (height % parentHeight !== 0) {
    throw new Error('Level height must be multiple of parent level: ' +
                    height + ' vs. ' + parentHeight);
  }

  if (numHorizontal % parentNumHorizontal !== 0) {
    throw new Error('Number of horizontal tiles must be multiple of parent level: ' +
      numHorizontal + " (" + width + '/' + tileWidth + ')' + " vs. " +
      parentNumHorizontal + " (" + parentWidth + '/' + parentTileWidth + ')');
  }

  if (numVertical % parentNumVertical !== 0) {
    throw new Error('Number of vertical tiles must be multiple of parent level: ' +
      numVertical + " (" + height + '/' + tileHeight + ')' + " vs. " +
      parentNumVertical + " (" + parentHeight + '/' + parentTileHeight + ')');
  }

};


/**
 * @class CubeGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for tiled cube images with
 * multiple resolution levels.
 *
 * The following restrictions apply:
 *   - All tiles in a level must be square and form a rectangular grid;
 *   - The size of a level must be a multiple of the tile size;
 *   - The size of a level must be a multiple of the parent level size;
 *   - The number of tiles in a level must be a multiple of the number of tiles
 *     in the parent level.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].size Cube face size in pixels
 * @param {number} levelPropertiesList[].tileSize Tile size in pixels
 */
function CubeGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = makeLevelList(levelPropertiesList, CubeLevel);
  this.selectableLevelList = makeSelectableLevelList(this.levelList);

  for (var i = 1; i < this.levelList.length; i++) {
    this.levelList[i]._validateWithParentLevel(this.levelList[i-1]);
  }

  this._tileSearcher = new TileSearcher(this);

  this._neighborsCache = new LruMap(neighborsCacheSize);

  this._vec = vec4.create();

  this._viewSize = {};
}


CubeGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


CubeGeometry.prototype.levelTiles = function(level, result) {

  var levelIndex = this.levelList.indexOf(level);
  var maxX = level.numHorizontalTiles() - 1;
  var maxY = level.numVerticalTiles() - 1;

  result = result || [];

  for (var f = 0; f < faceList.length; f++) {
    var face = faceList[f];
    for (var x = 0; x <= maxX; x++) {
      for (var y = 0; y <= maxY; y++) {
        result.push(new CubeTile(face, x, y, levelIndex, this));
      }
    }
  }

  return result;

};


CubeGeometry.prototype._closestTile = function(view, level) {
  var ray = this._vec;

  // Compute a view ray into the central screen point.
  vec4.set(ray, 0, 0, 0, 1);
  var matrix = mat4.create()
  mat4.multiply(matrix, view.inverseViewMatrix(), view.inverseProjection());
  vec4.transformMat4(ray, ray, matrix);

  var minAngle = Infinity;
  var closestFace = null;

  // Find the face whose vector makes a minimal angle with the view ray.
  // This is the face into which the view ray points.
  for (var face in faceVectors) {
    var vector = faceVectors[face];
    // For a small angle between two normalized vectors, angle ~ 1-cos(angle).
    var angle = 1 - vec3.dot(vector, ray);
    if (angle < minAngle) {
      minAngle = angle;
      closestFace = face;
    }
  }

  // Project view ray onto cube, i.e., normalize the coordinate with
  // largest absolute value to 0.5.
  var max = Math.max(Math.abs(ray[0]), Math.abs(ray[1]), Math.abs(ray[2])) / 0.5;
  for (var i = 0; i < 3; i++) {
    ray[i] = ray[i] / max;
  }

  // Rotate view ray into front face.
  var rot = faceRotation[closestFace];
  rotateVector(ray, 0, -rot.x, -rot.y);

  // Get the desired zoom level.
  var tileZ = this.levelList.indexOf(level);
  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  // Find the coordinates of the tile that the view ray points into.
  var tileX = clamp(Math.floor((0.5 + ray[0]) * numX), 0, numX - 1);
  var tileY = clamp(Math.floor((0.5 - ray[1]) * numY), 0, numY - 1);

  return new CubeTile(closestFace, tileX, tileY, tileZ, this);
};


CubeGeometry.prototype.visibleTiles = function(view, level, result) {
  var viewSize = this._viewSize;
  var tileSearcher = this._tileSearcher;

  result = result || [];

  view.size(viewSize);
  if (viewSize.width === 0 || viewSize.height === 0) {
    // No tiles are visible if the viewport is empty.
    return result;
  }

  var startingTile = this._closestTile(view, level);
  var count = tileSearcher.search(view, startingTile, result);
  if (!count) {
    //throw new Error('Starting tile is not visible');
  }

  return result;
};


CubeGeometry.Tile = CubeGeometry.prototype.Tile = CubeTile;
CubeGeometry.type = CubeGeometry.prototype.type = 'cube';
CubeTile.type = CubeTile.prototype.type = 'cube';


module.exports = CubeGeometry;

},{"../TileSearcher":23,"../collections/LruMap":29,"../util/clamp":81,"../util/cmp":83,"../util/hash":94,"../util/inherits":95,"../util/type":107,"./Level":53,"./common":54,"gl-matrix":3}],51:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var cmp = require('../util/cmp');
var common = require('./common');
var Level = require('./Level');
var type = require('../util/type');


/**
 * @class EquirectTile
 * @implements Tile
 * @classdesc
 *
 * A tile in an @{EquirectGeometry}.
 */
function EquirectTile(z, geometry) {
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


EquirectTile.prototype.rotX = function() {
  return 0;
};


EquirectTile.prototype.rotY = function() {
  return 0;
};


EquirectTile.prototype.centerX = function() {
  return 0.5;
};


EquirectTile.prototype.centerY = function() {
  return 0.5;
};


EquirectTile.prototype.scaleX = function() {
  return 1;
};


EquirectTile.prototype.scaleY = function() {
  return 1;
};


EquirectTile.prototype.parent = function() {
  if (this.z === 0) {
    return null;
  }
  return new EquirectTile(this.z - 1, this._geometry);
};


EquirectTile.prototype.children = function(result) {
  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }
  result = result || [];
  result.push(new EquirectTile(this.z + 1, this._geometry));
  return result;
};


EquirectTile.prototype.neighbors = function() {
  return [];
};


EquirectTile.prototype.hash = function() {
  return hash(this.z);
};


EquirectTile.prototype.equals = function(that) {
  return this._geometry === that._geometry && this.z === that.z;
};


EquirectTile.prototype.cmp = function(that) {
  return cmp(this.z, that.z);
};


EquirectTile.prototype.str = function() {
  return 'EquirectTile(' + tile.z + ')';
};


function EquirectLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);
  this._width = levelProperties.width;
}

inherits(EquirectLevel, Level);


EquirectLevel.prototype.width = function() {
  return this._width;
};


EquirectLevel.prototype.height = function() {
  return this._width/2;
};


EquirectLevel.prototype.tileWidth = function() {
  return this._width;
};


EquirectLevel.prototype.tileHeight = function() {
  return this._width/2;
};


/**
 * @class EquirectGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for equirectangular images with a
 * 2:1 aspect ratio.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].width Level width in pixels
*/
function EquirectGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = common.makeLevelList(levelPropertiesList, EquirectLevel);
  this.selectableLevelList = common.makeSelectableLevelList(this.levelList);
}


EquirectGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


EquirectGeometry.prototype.levelTiles = function(level, result) {
  var levelIndex = this.levelList.indexOf(level);
  result = result || [];
  result.push(new EquirectTile(levelIndex, this));
  return result;
};


EquirectGeometry.prototype.visibleTiles = function(view, level, result) {
  var tile = new EquirectTile(this.levelList.indexOf(level), this);
  result = result || [];
  result.length = 0;
  result.push(tile);
};


EquirectGeometry.Tile = EquirectGeometry.prototype.Tile = EquirectTile;
EquirectGeometry.type = EquirectGeometry.prototype.type = 'equirect';
EquirectTile.type = EquirectTile.prototype.type = 'equirect';


module.exports = EquirectGeometry;

},{"../util/cmp":83,"../util/hash":94,"../util/inherits":95,"../util/type":107,"./Level":53,"./common":54}],52:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var inherits = require('../util/inherits');
var hash = require('../util/hash');
var TileSearcher = require('../TileSearcher');
var LruMap = require('../collections/LruMap');
var Level = require('./Level');
var makeLevelList = require('./common').makeLevelList;
var makeSelectableLevelList = require('./common').makeSelectableLevelList;
var clamp = require('../util/clamp');
var mod = require('../util/mod');
var cmp = require('../util/cmp');
var type = require('../util/type');
var vec2 = require('gl-matrix').vec2;
var vec4 = require('gl-matrix').vec4;

var neighborsCacheSize = 64;

// Offsets to apply to the (x,y) coordinates of a tile to get its neighbors.
var neighborOffsets = [
  [  0,  1 ], // top
  [  1,  0 ], // right
  [  0, -1 ], // bottom
  [ -1,  0 ]  // left
];


/**
 * @class FlatTile
 * @implements Tile
 * @classdesc
 *
 * A tile in a {@link FlatGeometry}.
 */
function FlatTile(x, y, z, geometry) {
  this.x = x;
  this.y = y;
  this.z = z;
  this._geometry = geometry;
  this._level = geometry.levelList[z];
}


FlatTile.prototype.rotX = function() {
  return 0;
};


FlatTile.prototype.rotY = function() {
  return 0;
};


FlatTile.prototype.centerX = function() {
  var levelWidth = this._level.width();
  var tileWidth = this._level.tileWidth();
  return (this.x * tileWidth + 0.5 * this.width()) / levelWidth - 0.5;
};


FlatTile.prototype.centerY = function() {
  var levelHeight = this._level.height();
  var tileHeight = this._level.tileHeight();
  return 0.5 - (this.y * tileHeight + 0.5 * this.height()) / levelHeight;
};


FlatTile.prototype.scaleX = function() {
  var levelWidth = this._level.width();
  return this.width() / levelWidth;
};


FlatTile.prototype.scaleY = function() {
  var levelHeight = this._level.height();
  return this.height() / levelHeight;
};


FlatTile.prototype.width = function() {
  var levelWidth = this._level.width();
  var tileWidth = this._level.tileWidth();
  if (this.x === this._level.numHorizontalTiles() - 1) {
    var widthRemainder = mod(levelWidth, tileWidth);
    return widthRemainder || tileWidth;
  } else {
    return tileWidth;
  }
};


FlatTile.prototype.height = function() {
  var levelHeight = this._level.height();
  var tileHeight = this._level.tileHeight();
  if (this.y === this._level.numVerticalTiles() - 1) {
    var heightRemainder = mod(levelHeight, tileHeight);
    return heightRemainder || tileHeight;
  } else {
    return tileHeight;
  }
};


FlatTile.prototype.levelWidth = function() {
  return this._level.width();
};


FlatTile.prototype.levelHeight = function() {
  return this._level.height();
};


FlatTile.prototype.vertices = function(result) {
  if (!result) {
    result = [vec2.create(), vec2.create(), vec2.create(), vec2.create()];
  }

  var left = this.centerX() - this.scaleX() / 2;
  var right = this.centerX() + this.scaleX() / 2;
  var bottom = this.centerY() - this.scaleY() / 2;
  var top = this.centerY() + this.scaleY() / 2;

  vec2.set(result[0], left, top);
  vec2.set(result[1], right, top);
  vec2.set(result[2], right, bottom);
  vec2.set(result[3], left, bottom);

  return result;
};


FlatTile.prototype.parent = function() {


  if (this.z === 0) {
    return null;
  }

  var geometry = this._geometry;

  var z = this.z - 1;
  // TODO: Currently assuming each level is double the size of previous one.
  // Fix to support other multiples.
  var x = Math.floor(this.x / 2);
  var y = Math.floor(this.y / 2);

  return new FlatTile(x, y, z, geometry);

};


FlatTile.prototype.children = function(result) {
  if (this.z === this._geometry.levelList.length - 1) {
    return null;
  }

  var geometry = this._geometry;
  var z = this.z + 1;

  result = result || [];

  // TODO: Currently assuming each level is double the size of previous one.
  // Fix to support other multiples.
  result.push(new FlatTile(2*this.x  , 2*this.y  , z, geometry));
  result.push(new FlatTile(2*this.x  , 2*this.y+1, z, geometry));
  result.push(new FlatTile(2*this.x+1, 2*this.y  , z, geometry));
  result.push(new FlatTile(2*this.x+1, 2*this.y+1, z, geometry));

  return result;

};


FlatTile.prototype.neighbors = function() {

  var geometry = this._geometry;
  var cache = geometry._neighborsCache;

  // Satisfy from cache when available.
  var cachedResult = cache.get(this);
  if (cachedResult) {
    return cachedResult;
  }

  var x = this.x;
  var y = this.y;
  var z = this.z;
  var level = this._level;

  var numX = level.numHorizontalTiles() - 1;
  var numY = level.numVerticalTiles() - 1;

  var result = [];

  for (var i = 0; i < neighborOffsets.length; i++) {
    var xOffset = neighborOffsets[i][0];
    var yOffset = neighborOffsets[i][1];

    var newX = x + xOffset;
    var newY = y + yOffset;
    var newZ = z;

    if (0 <= newX && newX <= numX && 0 <= newY && newY <= numY) {
      result.push(new FlatTile(newX, newY, newZ, geometry));
    }
  }

  // Store into cache to satisfy future requests.
  cache.set(this, result);

  return result;

};


FlatTile.prototype.hash = function() {
  return hash(this.z, this.y, this.x);
};


FlatTile.prototype.equals = function(that) {
  return (this._geometry === that._geometry &&
      this.z === that.z && this.y === that.y && this.x === that.x);
};


FlatTile.prototype.cmp = function(that) {
  return (cmp(this.z, that.z) || cmp(this.y, that.y) || cmp(this.x, that.x));
};


FlatTile.prototype.str = function() {
  return 'FlatTile(' + tile.x + ', ' + tile.y + ', ' + tile.z + ')';
};


function FlatLevel(levelProperties) {
  this.constructor.super_.call(this, levelProperties);

  this._width = levelProperties.width;
  this._height = levelProperties.height;
  this._tileWidth = levelProperties.tileWidth;
  this._tileHeight = levelProperties.tileHeight;
}

inherits(FlatLevel, Level);


FlatLevel.prototype.width = function() {
  return this._width;
};


FlatLevel.prototype.height = function() {
  return this._height;
};


FlatLevel.prototype.tileWidth = function() {
  return this._tileWidth;
};


FlatLevel.prototype.tileHeight = function() {
  return this._tileHeight;
};


FlatLevel.prototype._validateWithParentLevel = function(parentLevel) {

  var width = this.width();
  var height = this.height();
  var tileWidth = this.tileWidth();
  var tileHeight = this.tileHeight();

  var parentWidth = parentLevel.width();
  var parentHeight = parentLevel.height();
  var parentTileWidth = parentLevel.tileWidth();
  var parentTileHeight = parentLevel.tileHeight();

  if (width % parentWidth !== 0) {
    return new Error('Level width must be multiple of parent level: ' +
                     width + ' vs. ' + parentWidth);
  }

  if (height % parentHeight !== 0) {
    return new Error('Level height must be multiple of parent level: ' +
                     height + ' vs. ' + parentHeight);
  }

  if (tileWidth % parentTileWidth !== 0) {
    return new Error('Level tile width must be multiple of parent level: ' +
                     tileWidth + ' vs. ' + parentTileWidth);
  }

  if (tileHeight % parentTileHeight !== 0) {
    return new Error('Level tile height must be multiple of parent level: ' +
                     tileHeight + ' vs. ' + parentTileHeight);
  }

};


/**
 * @class FlatGeometry
 * @implements Geometry
 * @classdesc
 *
 * A {@link Geometry} implementation suitable for tiled flat images with
 * multiple resolution levels.
 *
 * The following restrictions apply:
 *   - All tiles must be square, except when in the last row or column position,
 *     and must form a rectangular grid;
 *   - The width and height of a level must be multiples of the parent level
 *     width and height.
 *
 * @param {Object[]} levelPropertiesList Level description
 * @param {number} levelPropertiesList[].width Level width in pixels
 * @param {number} levelPropertiesList[].tileWidth Tile width in pixels for
 *                 square tiles
 * @param {number} levelPropertiesList[].height Level height in pixels
 * @param {number} levelPropertiesList[].tileHeight Tile height in pixels for
 *                 square tiles
 */
function FlatGeometry(levelPropertiesList) {
  if (type(levelPropertiesList) !== 'array') {
    throw new Error('Level list must be an array');
  }

  this.levelList = makeLevelList(levelPropertiesList, FlatLevel);
  this.selectableLevelList = makeSelectableLevelList(this.levelList);

  for (var i = 1; i < this.levelList.length; i++) {
    this.levelList[i]._validateWithParentLevel(this.levelList[i-1]);
  }

  this._tileSearcher = new TileSearcher(this);

  this._neighborsCache = new LruMap(neighborsCacheSize);

  this._vec = vec4.create();

  this._viewSize = {};
}


FlatGeometry.prototype.maxTileSize = function() {
  var maxTileSize = 0;
  for (var i = 0; i < this.levelList.length; i++) {
    var level = this.levelList[i];
    maxTileSize = Math.max(maxTileSize, level.tileWidth, level.tileHeight);
  }
  return maxTileSize;
};


FlatGeometry.prototype.levelTiles = function(level, result) {

  var levelIndex = this.levelList.indexOf(level);
  var maxX = level.numHorizontalTiles() - 1;
  var maxY = level.numVerticalTiles() - 1;

  if (!result) {
    result = [];
  }

  for (var x = 0; x <= maxX; x++) {
    for (var y = 0; y <= maxY; y++) {
      result.push(new FlatTile(x, y, levelIndex, this));
    }
  }

  return result;

};


FlatGeometry.prototype._closestTile = function(view, level) {
  var ray = this._vec;

  // Compute a view ray into the central screen point.
  vec4.set(ray, 0, 0, 1, 1);
  vec4.transformMat4(ray, ray, view.inverseProjection());

  // Compute the image coordinates that the view ray points into.
  var x = 0.5 + ray[0];
  var y = 0.5 - ray[1];

  // Get the desired zoom level.
  var tileZ = this.levelList.indexOf(level);
  var levelWidth = level.width();
  var levelHeight = level.height();
  var tileWidth = level.tileWidth();
  var tileHeight = level.tileHeight();
  var numX = level.numHorizontalTiles();
  var numY = level.numVerticalTiles();

  // Find the coordinates of the tile that the view ray points into.
  var tileX = clamp(Math.floor(x * levelWidth / tileWidth), 0, numX - 1);
  var tileY = clamp(Math.floor(y * levelHeight / tileHeight), 0, numY - 1);

  return new FlatTile(tileX, tileY, tileZ, this);
};


FlatGeometry.prototype.visibleTiles = function(view, level, result) {
  var viewSize = this._viewSize;
  var tileSearcher = this._tileSearcher;

  result = result || [];

  view.size(viewSize);
  if (viewSize.width === 0 || viewSize.height === 0) {
    // No tiles are visible if the viewport is empty.
    return result;
  }

  var startingTile = this._closestTile(view, level);
  var count = tileSearcher.search(view, startingTile, result);
  if (!count) {
    throw new Error('Starting tile is not visible');
  }

  return result;
};


FlatGeometry.Tile = FlatGeometry.prototype.Tile = FlatTile;
FlatGeometry.type = FlatGeometry.prototype.type = 'flat';
FlatTile.type = FlatTile.prototype.type = 'flat';


module.exports = FlatGeometry;

},{"../TileSearcher":23,"../collections/LruMap":29,"../util/clamp":81,"../util/cmp":83,"../util/hash":94,"../util/inherits":95,"../util/mod":97,"../util/type":107,"./Level":53,"./common":54,"gl-matrix":3}],53:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function Level(levelProperties) {
  this._fallbackOnly = !!levelProperties.fallbackOnly;
}

Level.prototype.numHorizontalTiles = function() {
  return Math.ceil(this.width() / this.tileWidth());
};

Level.prototype.numVerticalTiles = function() {
  return Math.ceil(this.height() / this.tileHeight());
};

Level.prototype.fallbackOnly = function() {
  return this._fallbackOnly;
};

module.exports = Level;
},{}],54:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var cmp = require('../util/cmp');

function makeLevelList(levelPropertiesList, LevelClass) {
  var list = [];

  for (var i = 0; i < levelPropertiesList.length; i++) {
    list.push(new LevelClass(levelPropertiesList[i]));
  }

  list.sort(function(level1, level2) {
    return cmp(level1.width(), level2.width());
  });

  return list;
}

function makeSelectableLevelList(levelList) {
  var list = [];

  for (var i = 0; i < levelList.length; i++) {
    if (!levelList[i]._fallbackOnly) {
      list.push(levelList[i]);
    }
  }

  if (!list.length) {
    throw new Error('No selectable levels in list');
  }

  return list;
}

module.exports = {
  makeLevelList: makeLevelList,
  makeSelectableLevelList: makeSelectableLevelList
};

},{"../util/cmp":83}],55:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = {

  // Stages.
  WebGlStage: require('./stages/WebGl'),

  // Renderers.
  WebGlCubeRenderer: require('./renderers/WebGlCube'),
  WebGlFlatRenderer: require('./renderers/WebGlFlat'),
  WebGlEquirectRenderer: require('./renderers/WebGlEquirect'),
  registerDefaultRenderers: require('./renderers/registerDefaultRenderers'),

  // Geometries.
  CubeGeometry: require('./geometries/Cube'),
  FlatGeometry: require('./geometries/Flat'),
  EquirectGeometry: require('./geometries/Equirect'),

  // Views.
  RectilinearView: require('./views/Rectilinear'),
  FlatView: require('./views/Flat'),

  // Sources.
  ImageUrlSource: require('./sources/ImageUrl'),
  SingleAssetSource: require('./sources/SingleAsset'),

  // Assets.
  StaticAsset: require('./assets/Static'),
  DynamicAsset: require('./assets/Dynamic'),

  // Texture store.
  TextureStore: require('./TextureStore'),

  // Layer.
  Layer: require('./Layer'),

  // Render loop.
  RenderLoop: require('./RenderLoop'),

  // Controls.
  KeyControlMethod: require('./controls/Key'),
  DragControlMethod: require('./controls/Drag'),
  QtvrControlMethod: require('./controls/Qtvr'),
  ScrollZoomControlMethod: require('./controls/ScrollZoom'),
  PinchZoomControlMethod: require('./controls/PinchZoom'),
  VelocityControlMethod: require('./controls/Velocity'),
  ElementPressControlMethod: require('./controls/ElementPress'),
  Controls: require('./controls/Controls'),
  Dynamics: require('./controls/Dynamics'),

  // High-level API.
  Viewer: require('./Viewer'),
  Scene: require('./Scene'),

  // Hotspots.
  Hotspot: require('./Hotspot'),
  HotspotContainer: require('./HotspotContainer'),

  // Effects.
  colorEffects: require('./colorEffects'),

  // Miscellaneous functions.
  registerDefaultControls: require('./controls/registerDefaultControls'),
  autorotate: require('./autorotate'),

  // Utility functions.
  util: {
    async: require('./util/async'),
    cancelize: require('./util/cancelize'),
    chain: require('./util/chain'),
    clamp: require('./util/clamp'),
    clearOwnProperties: require('./util/clearOwnProperties'),
    cmp: require('./util/cmp'),
    compose: require('./util/compose'),
    convertFov: require('./util/convertFov'),
    decimal: require('./util/decimal'),
    defaults: require('./util/defaults'),
    defer: require('./util/defer'),
    degToRad: require('./util/degToRad'),
    delay: require('./util/delay'),
    dom: require('./util/dom'),
    extend: require('./util/extend'),
    hash: require('./util/hash'),
    inherits: require('./util/inherits'),
    mod: require('./util/mod'),
    noop: require('./util/noop'),
    now: require('./util/now'),
    once: require('./util/once'),
    pixelRatio: require('./util/pixelRatio'),
    radToDeg: require('./util/radToDeg'),
    real: require('./util/real'),
    retry: require('./util/retry'),
    tween: require('./util/tween'),
    type: require('./util/type')
  },

  // Expose dependencies for clients to use.
  dependencies: {
    bowser: require('bowser'),
    glMatrix: require('gl-matrix'),
    eventEmitter: require('minimal-event-emitter'),
    hammerjs: require('hammerjs')
  }
};

},{"./Hotspot":16,"./HotspotContainer":17,"./Layer":18,"./RenderLoop":20,"./Scene":21,"./TextureStore":22,"./Viewer":25,"./assets/Dynamic":26,"./assets/Static":27,"./autorotate":28,"./colorEffects":35,"./controls/Controls":38,"./controls/Drag":39,"./controls/Dynamics":40,"./controls/ElementPress":41,"./controls/Key":43,"./controls/PinchZoom":44,"./controls/Qtvr":45,"./controls/ScrollZoom":46,"./controls/Velocity":47,"./controls/registerDefaultControls":48,"./geometries/Cube":50,"./geometries/Equirect":51,"./geometries/Flat":52,"./renderers/WebGlCube":60,"./renderers/WebGlEquirect":62,"./renderers/WebGlFlat":63,"./renderers/registerDefaultRenderers":64,"./sources/ImageUrl":72,"./sources/SingleAsset":73,"./stages/WebGl":76,"./util/async":77,"./util/cancelize":79,"./util/chain":80,"./util/clamp":81,"./util/clearOwnProperties":82,"./util/cmp":83,"./util/compose":84,"./util/convertFov":85,"./util/decimal":86,"./util/defaults":87,"./util/defer":88,"./util/degToRad":89,"./util/delay":90,"./util/dom":91,"./util/extend":92,"./util/hash":94,"./util/inherits":95,"./util/mod":97,"./util/noop":98,"./util/now":99,"./util/once":100,"./util/pixelRatio":101,"./util/radToDeg":103,"./util/real":104,"./util/retry":105,"./util/tween":106,"./util/type":107,"./views/Flat":108,"./views/Rectilinear":109,"bowser":1,"gl-matrix":3,"hammerjs":13,"minimal-event-emitter":14}],56:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var StaticAsset = require('../assets/Static');
var NetworkError = require('../NetworkError');
var browser = require('bowser');
var global = require('../util/global');
var once = require('../util/once');

// TODO: Move the load queue into the loader.

// Whether to use createImageBitmap instead of a canvas for cropping.
// See https://caniuse.com/?search=createimagebitmap
var useCreateImageBitmap = !!global.createImageBitmap && !browser.firefox && !browser.safari;

// Options for createImageBitmap.
var createImageBitmapOpts = {
  imageOrientation: 'flipY',
  premultiplyAlpha: 'premultiply'
};

/**
 * @class HtmlImageLoader
 * @implements ImageLoader
 * @classdesc
 *
 * A {@link Loader} for HTML images.
 *
 * @param {Stage} stage The stage which is going to request images to be loaded.
 */
function HtmlImageLoader(stage) {
  this._stage = stage;
}

/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
HtmlImageLoader.prototype.loadImage = function(url, rect, done) {
  var self = this;

  var img = new Image();

  // Allow cross-domain image loading.
  // This is required to be able to create WebGL textures from images fetched
  // from a different domain. Note that setting the crossorigin attribute to
  // 'anonymous' will trigger a CORS preflight for cross-domain requests, but no
  // credentials (cookies or HTTP auth) will be sent; to do so, the attribute
  // would have to be set to 'use-credentials' instead. Unfortunately, this is
  // not a safe choice, as it causes requests to fail when the response contains
  // an Access-Control-Allow-Origin header with a wildcard. See the section
  // "Credentialed requests and wildcards" on:
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
  img.crossOrigin = 'anonymous';

  var x = rect && rect.x || 0;
  var y = rect && rect.y || 0;
  var width = rect && rect.width || 1;
  var height = rect && rect.height || 1;

  done = once(done);

  img.onload = function() {
    self._handleLoad(img, x, y, width, height, done);
  };

  img.onerror = function() {
    self._handleError(url, done);
  };

  img.src = url;

  function cancel() {
    img.onload = img.onerror = null;
    img.src = '';
    done.apply(null, arguments);
  }

  return cancel;
};

HtmlImageLoader.prototype._handleLoad = function(img, x, y, width, height, done) {
  if (x === 0 && y === 0 && width === 1 && height === 1) {
    // Fast path for when cropping is not needed.
    done(null, new StaticAsset(img));
    return;
  }

  x *= img.naturalWidth;
  y *= img.naturalHeight;
  width *= img.naturalWidth;
  height *= img.naturalHeight;

  if (useCreateImageBitmap) {
    // Prefer to crop using createImageBitmap, which can potentially offload
    // work to another thread and avoid blocking the user interface.
    // Assume that the promise is never rejected.
    global.createImageBitmap(img, x, y, width, height, createImageBitmapOpts)
      .then(function(bitmap) {
        done(null, new StaticAsset(bitmap));
      });
  } else {
    // Fall back to cropping using a canvas, which can potentially block the
    // user interface, but is the best we can do.
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');
    context.drawImage(img, x, y, width, height, 0, 0, width, height);
    done(null, new StaticAsset(canvas));
  }
};

HtmlImageLoader.prototype._handleError = function(url, done) {
  // TODO: is there any way to distinguish a network error from other
  // kinds of errors? For now we always return NetworkError since this
  // prevents images to be retried continuously while we are offline.
  done(new NetworkError('Network error: ' + url));
};

module.exports = HtmlImageLoader;

},{"../NetworkError":19,"../assets/Static":27,"../util/global":93,"../util/once":100,"bowser":1}],57:[function(require,module,exports){
'use strict';

var NetworkError = require('../NetworkError');
var once = require('../util/once');

/**
 * @class HtmlModelLoader
 * @implements ModelLoader
 * @classdesc
 *
 * A {@link Loader} for HTML models.
 *
 * @param {Stage} stage The stage which is going to request images to be loaded.
 */
function HtmlModelLoader(stage) {
  this._stage = stage;
}

/**
 * Loads an {@link Asset} from a 3D model file.
 * @param {string} url The 3D model URL.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
HtmlModelLoader.prototype.loadModel = function (url, done) {
  var self = this;

  done = once(done);

  fetch(url)
    .then(response => response.text())
    .then(data => {
      self._handleLoad(data, done);
    })
    .catch(error => {
      self._handleError(url, done);
    });

  function cancel() {
    done.apply(null, arguments);
  }

  return cancel;
};

HtmlModelLoader.prototype._handleLoad = function (data, done) {
  const positions = [];
  const indices = [];

  // Split the STL data into lines
  const lines = data.trim().split('\n');

  // Iterate through each line to extract positions and indices
  let vertexIndex = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const parts = line.split(' ');

    if (parts[0] === 'vertex') {
      // Parse vertex position and add it to the positions array
      const vertex = line.trim().split(/\s+/).slice(1).map(parseFloat);

      const x = vertex[0];
      const z = vertex[1];
      const y = vertex[2];

      //positions.push(x, y, z);
      positions.push(z, y, x);
      //positions.push(-x, -y, -z);
      vertexIndex++;
    } else if (parts[0] === 'facet') {
      // Skip the facet normal line
      i++;
    } else if (parts[0] === 'endloop') {
      // Create face by adding vertex indices
      indices.push(vertexIndex - 3, vertexIndex - 2, vertexIndex - 1);
    }
  }

  done(null, { positions, indices });
};

HtmlModelLoader.prototype._handleError = function (url, done) {
  // TODO: is there any way to distinguish a network error from other
  // kinds of errors? For now we always return NetworkError since this
  // prevents images to be retried continuously while we are offline.
  done(new NetworkError('Network error: ' + url));
};

module.exports = HtmlModelLoader;
},{"../NetworkError":19,"../util/once":100}],58:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mat4 = require('gl-matrix').mat4;
var vec3 = require('gl-matrix').vec3;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;

var vertexSrc = require('../shaders/vertexNormal');
var fragmentSrc = require('../shaders/fragmentNormal');

var vertexIndices = [0, 1, 2, 0, 2, 3];
var vertexPositions = [-0.5, -0.5, 0.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, -0.5, 0.5, 0.0];
var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];

var attribList = ['aVertexPosition', 'aTextureCoord'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uProjMatrix', 'uViewMatrix', 'uModelMatrix', 'uViewportMatrix',
  'uColorOffset', 'uColorMatrix'
];


function WebGlBaseRenderer(gl) {
  this.gl = gl;

  // The projection matrix positions the tiles in world space.
  // We compute it in Javascript because lack of precision in the vertex shader
  // causes seams to appear between adjacent tiles at large zoom levels.
  this.projMatrix = mat4.create();

  // TODO Why save this value here? the same question to the projMatrix.
  this.viewMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  // Translation and scale vectors for tiles.
  this.translateVector = vec3.create();
  this.scaleVector = vec3.create();

  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlBaseRenderer.prototype.destroy = function() {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};

WebGlBaseRenderer.prototype.startLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);
  gl.vertexAttribPointer(shaderProgram.aTextureCoord, 2, gl.FLOAT, gl.FALSE, 0, 0);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};


WebGlBaseRenderer.prototype.endLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};


WebGlBaseRenderer.prototype.renderTile = function(tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var projMatrix = this.projMatrix;
  var viewMatrix = this.viewMatrix;
  var translateVector = this.translateVector;
  var scaleVector = this.scaleVector;

  mat4.copy(projMatrix, layer.view().projection());
  gl.uniformMatrix4fv(shaderProgram.uProjMatrix, false, projMatrix);

  mat4.copy(viewMatrix, layer.view().viewMatrix());
  gl.uniformMatrix4fv(shaderProgram.uViewMatrix, false, viewMatrix);
  
  // Generate ModelMatrix.
  // TODO Cache the matrix in the tile object?
  translateVector[0] = tile.centerX();
  translateVector[1] = tile.centerY();
  translateVector[2] = -0.5;

  scaleVector[0] = tile.scaleX();
  scaleVector[1] = tile.scaleY();
  scaleVector[2] = 1.0;

  var modelMatrix = mat4.create();
  mat4.rotateX(modelMatrix, modelMatrix, tile.rotX());
  mat4.rotateY(modelMatrix, modelMatrix, tile.rotY());
  mat4.translate(modelMatrix, modelMatrix, translateVector);
  mat4.scale(modelMatrix, modelMatrix, scaleVector);

  gl.uniformMatrix4fv(shaderProgram.uModelMatrix, false, modelMatrix);

  setDepth(gl, shaderProgram, layerZ, tile.z);
  setTexture(gl, shaderProgram, texture);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};


module.exports = WebGlBaseRenderer;

},{"../shaders/fragmentNormal":67,"../shaders/vertexNormal":71,"../util/clearOwnProperties":82,"./WebGlCommon":59,"gl-matrix":3}],59:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// These are used to set the WebGl depth for a tile.
var MAX_LAYERS = 256; // Max number of layers per stage.
var MAX_LEVELS = 256; // Max number of levels per layer.

var clamp = require('../util/clamp');
var vec4 = require('gl-matrix').vec4;
var vec3 = require('gl-matrix').vec3;
var mat4 = require('gl-matrix').mat4;


function createShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw gl.getShaderInfoLog(shader);
  }
  return shader;
}


function createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList) {

  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

  var shaderProgram = gl.createProgram();

  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    throw gl.getProgramInfoLog(shaderProgram);
  }

  for (var i = 0; i < attribList.length; i++) {
    var attrib = attribList[i];
    shaderProgram[attrib] = gl.getAttribLocation(shaderProgram, attrib);
    if (shaderProgram[attrib] === -1) {
      throw new Error('Shader program has no ' + attrib + ' attribute');
    }
  }

  for (var j = 0; j < uniformList.length; j++) {
    var uniform = uniformList[j];
    shaderProgram[uniform] = gl.getUniformLocation(shaderProgram, uniform);
    if (shaderProgram[uniform] === -1) {
      throw new Error('Shader program has no ' + uniform + ' uniform');
    }
  }

  return shaderProgram;
}


function destroyShaderProgram(gl, shaderProgram) {
  var shaderList = gl.getAttachedShaders(shaderProgram);
  for (var i = 0; i < shaderList.length; i++) {
    var shader = shaderList[i];
    gl.detachShader(shaderProgram, shader);
    gl.deleteShader(shader);
  }
  gl.deleteProgram(shaderProgram);
}


function createConstantBuffer(gl, target, usage, value) {
  var buffer = gl.createBuffer();
  gl.bindBuffer(target, buffer);
  gl.bufferData(target, value, usage);
  return buffer;
}


function createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords) {
  return {
    vertexIndices: createConstantBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW, new Uint16Array(vertexIndices)),
    vertexPositions: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(vertexPositions)),
    textureCoords: createConstantBuffer(gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW, new Float32Array(textureCoords))
  };
}


function destroyConstantBuffers(gl, constantBuffers) {
  gl.deleteBuffer(constantBuffers.vertexIndices);
  gl.deleteBuffer(constantBuffers.vertexPositions);
  gl.deleteBuffer(constantBuffers.textureCoords);
}


function enableAttributes(gl, shaderProgram) {
  var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttrs; i++) {
    gl.enableVertexAttribArray(i);
  }
}


function disableAttributes(gl, shaderProgram) {
  var numAttrs = gl.getProgramParameter(shaderProgram, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttrs; i++) {
    gl.disableVertexAttribArray(i);
  }
}


function setTexture(gl, shaderProgram, texture) {
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture._texture);
  gl.uniform1i(shaderProgram.uSampler, 0);
}

function setDepthmapTexture(gl, shaderProgram, texture) {
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, texture._texture);
  gl.uniform1i(shaderProgram.uDepthmap, 1);
}

function setDepthmapCubeTexture(gl, shaderProgram, texture) {
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
  gl.uniform1i(shaderProgram.uDepthmap, 1);
}

function setDepth(gl, shaderProgram, layerZ, tileZ) {
  var depth = (((layerZ + 1) * MAX_LEVELS) - tileZ) / (MAX_LEVELS * MAX_LAYERS);
  gl.uniform1f(shaderProgram.uDepth, depth);
}


var defaultOpacity = 1.0;
var defaultColorOffset = vec4.create();
var defaultColorMatrix = mat4.create();
mat4.identity(defaultColorMatrix);

function setupPixelEffectUniforms(gl, effects, uniforms) {
  var opacity = defaultOpacity;
  if (effects && effects.opacity != null) {
    opacity = effects.opacity;
  }
  gl.uniform1f(uniforms.opacity, opacity);

  var colorOffset = defaultColorOffset;
  if (effects && effects.colorOffset) {
    colorOffset = effects.colorOffset;
  }
  gl.uniform4fv(uniforms.colorOffset, colorOffset);

  var colorMatrix = defaultColorMatrix;
  if (effects && effects.colorMatrix) {
    colorMatrix = effects.colorMatrix;
  }
  gl.uniformMatrix4fv(uniforms.colorMatrix, false, colorMatrix);
}


// Temporary vectors for setViewport.
var translateVector = vec3.create();
var scaleVector = vec3.create();


// Sets the WebGL viewport and returns a viewport clamping compensation matrix.
//
// Negative viewport origin coordinates cause rendering issues. Letting the
// viewport dimensions extend beyond the visible area do not seem to cause
// rendering issues, but they may still have an impact on performance.
// Therefore, when the scene's rect is not fully contained in the rendering
// area, we clamp the viewport to the rendering area, and return a compensation
// matrix to scale and translate vertices accordingly.
function setViewport(gl, layer, rect, viewportMatrix) {
  if (rect.x === 0 && rect.width === 1 && rect.y === 0 && rect.height === 1) {
    // Fast path for full rect.
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    mat4.identity(viewportMatrix);
    return;
  }

  var offsetX = rect.x;
  var clampedOffsetX = clamp(offsetX, 0, 1);
  var leftExcess = clampedOffsetX - offsetX;
  var maxClampedWidth = 1 - clampedOffsetX;
  var clampedWidth = clamp(rect.width - leftExcess, 0, maxClampedWidth);
  var rightExcess = rect.width - clampedWidth;

  var offsetY = 1 - rect.height - rect.y;
  var clampedOffsetY = clamp(offsetY, 0, 1);
  var bottomExcess = clampedOffsetY - offsetY;
  var maxClampedHeight = 1 - clampedOffsetY;
  var clampedHeight = clamp(rect.height - bottomExcess, 0, maxClampedHeight);
  var topExcess = rect.height - clampedHeight;

  vec3.set(
    scaleVector,
    rect.width / clampedWidth,
    rect.height / clampedHeight,
    1);

  vec3.set(
    translateVector,
    (rightExcess - leftExcess) / clampedWidth,
    (topExcess - bottomExcess) / clampedHeight,
    0);

  mat4.identity(viewportMatrix);
  mat4.translate(viewportMatrix, viewportMatrix, translateVector);
  mat4.scale(viewportMatrix, viewportMatrix, scaleVector);

  gl.viewport(gl.drawingBufferWidth * clampedOffsetX,
              gl.drawingBufferHeight * clampedOffsetY,
              gl.drawingBufferWidth * clampedWidth,
              gl.drawingBufferHeight * clampedHeight);
}

module.exports = {
  createShaderProgram: createShaderProgram,
  destroyShaderProgram: destroyShaderProgram,
  createConstantBuffers: createConstantBuffers,
  destroyConstantBuffers: destroyConstantBuffers,
  enableAttributes: enableAttributes,
  disableAttributes: disableAttributes,
  setTexture: setTexture,
  setDepthmapTexture: setDepthmapTexture,
  setDepthmapCubeTexture: setDepthmapCubeTexture,
  setDepth: setDepth,
  setViewport: setViewport,
  setupPixelEffectUniforms: setupPixelEffectUniforms
};

},{"../util/clamp":81,"gl-matrix":3}],60:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlBaseRenderer = require('./WebGlBase');
var inherits = require('../util/inherits');

/**
 * @class WebGlCubeRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link CubeGeometry} and {@link RectilinearView}, appropriate
 * for a {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlCubeRenderer() {
  this.constructor.super_.apply(this, arguments);
}

inherits(WebGlCubeRenderer, WebGlBaseRenderer);

module.exports = WebGlCubeRenderer;

},{"../util/inherits":95,"./WebGlBase":58}],61:[function(require,module,exports){
'use strict';

var mat4 = require('gl-matrix').mat4;
var vec3 = require('gl-matrix').vec3;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;
var setDepthmapTexture = WebGlCommon.setDepthmapTexture;
var setDepthmapCubeTexture = WebGlCommon.setDepthmapCubeTexture;

var vertexSrc = require('../shaders/vertexCubeDepth');
var fragmentSrc = require('../shaders/fragmentCubeDepth');
var vertexSTLSrc = require('../shaders/vertexCubeDepthSTL');

// Initialize arrays for vertexIndices, vertexPositions, and textureCoords
var vertexIndices = [];
var vertexPositions = [];
var textureCoords = [];

var defaultWidthSegments = 40;
var defaultHeightSegments = 40;

function createVertexDatas(widthSegments, heightSegments) {

  // Loop through each row and column to generate vertices, texture coordinates, and indices
  for (var row = 0; row <= heightSegments; row++) {
    var v = row / heightSegments;
    for (var col = 0; col <= widthSegments; col++) {
      var u = col / widthSegments;

      // Calculate vertex positions
      var x = u - 0.5;
      var y = v - 0.5;
      var z = 0.0;
      vertexPositions.push(x, y, z);

      // Calculate texture coordinates
      textureCoords.push(u, v);

      // Calculate vertex indices
      if (row < heightSegments && col < widthSegments) {
        var a = row * (widthSegments + 1) + col;
        var b = a + 1;
        var c = (row + 1) * (widthSegments + 1) + col;
        var d = c + 1;
        vertexIndices.push(a, b, c, b, d, c);
      }
    }
  }
}

var attribList = ['aVertexPosition', 'aTextureCoord'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uDepthmap', 'uProjMatrix', 'uViewMatrix',
  'uModelMatrix', 'uViewportMatrix', 'uColorOffset', 'uColorMatrix'
];



/**
 * @class WebGlCubeDepthRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link CubeGeometry} and {@link RectilinearView} with depthmap, appropriate
 * for a {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlCubeDepthRenderer(gl, opts) {
  this.gl = gl;

  // The projection matrix positions the tiles in world space.
  // We compute it in Javascript because lack of precision in the vertex shader
  // causes seams to appear between adjacent tiles at large zoom levels.
  this.projMatrix = mat4.create();

  // TODO Why save this value here? the same question to the projMatrix.
  this.viewMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  // Translation and scale vectors for tiles.
  this.translateVector = vec3.create();
  this.scaleVector = vec3.create();

  var widthSegments = opts && opts.widthSegments ? opts.widthSegments : defaultWidthSegments;
  var heightSegments = opts && opts.heightSegments ? opts.heightSegments : defaultHeightSegments;
  createVertexDatas(widthSegments, heightSegments);
  
  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  if (opts.layer.depthmapStore().sourceType() == 'stl') {
    this.shaderProgram = createShaderProgram(gl, vertexSTLSrc, fragmentSrc, attribList, uniformList);
  } else {
    this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
  }
}

WebGlCubeDepthRenderer.prototype.destroy = function () {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};

WebGlCubeDepthRenderer.prototype.startLayer = function (layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);
  gl.vertexAttribPointer(shaderProgram.aTextureCoord, 2, gl.FLOAT, gl.FALSE, 0, 0);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};

WebGlCubeDepthRenderer.prototype.endLayer = function (layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};

WebGlCubeDepthRenderer.prototype.renderTile = function (tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var projMatrix = this.projMatrix;
  var viewMatrix = this.viewMatrix;
  var translateVector = this.translateVector;
  var scaleVector = this.scaleVector;

  mat4.copy(projMatrix, layer.view().projection());
  gl.uniformMatrix4fv(shaderProgram.uProjMatrix, false, projMatrix);

  mat4.copy(viewMatrix, layer.view().viewMatrix());
  gl.uniformMatrix4fv(shaderProgram.uViewMatrix, false, viewMatrix);

  // Generate ModelMatrix.
  // TODO Cache the matrix in the tile object?
  translateVector[0] = tile.centerX();
  translateVector[1] = tile.centerY();
  translateVector[2] = -0.5;

  scaleVector[0] = tile.scaleX();
  scaleVector[1] = tile.scaleY();
  scaleVector[2] = 1.0;

  var modelMatrix = mat4.create();
  if (layer.depthmapStore().sourceType() != 'stl') {
    mat4.rotateY(modelMatrix, modelMatrix, -Math.PI / 2);
  }
  mat4.rotateX(modelMatrix, modelMatrix, tile.rotX());
  mat4.rotateY(modelMatrix, modelMatrix, tile.rotY());
  mat4.translate(modelMatrix, modelMatrix, translateVector);
  mat4.scale(modelMatrix, modelMatrix, scaleVector);

  gl.uniformMatrix4fv(shaderProgram.uModelMatrix, false, modelMatrix);

  // Depth, Texture.
  setDepth(gl, shaderProgram, layerZ, tile.z);
  setTexture(gl, shaderProgram, texture);

  // DepthmapTexture.
  var depthmapStore = layer.depthmapStore();
  if (depthmapStore.sourceType() == 'stl') {
    setDepthmapCubeTexture(gl, shaderProgram, depthmapStore.cubeTexture());
  } else {
    setDepthmapTexture(gl, shaderProgram, depthmapStore.texture());
  }

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};

module.exports = WebGlCubeDepthRenderer;
},{"../shaders/fragmentCubeDepth":65,"../shaders/vertexCubeDepth":68,"../shaders/vertexCubeDepthSTL":69,"../util/clearOwnProperties":82,"./WebGlCommon":59,"gl-matrix":3}],62:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var mat4 = require('gl-matrix').mat4;
var clearOwnProperties = require('../util/clearOwnProperties');

var WebGlCommon = require('./WebGlCommon');
var createConstantBuffers = WebGlCommon.createConstantBuffers;
var destroyConstantBuffers = WebGlCommon.destroyConstantBuffers;
var createShaderProgram = WebGlCommon.createShaderProgram;
var destroyShaderProgram = WebGlCommon.destroyShaderProgram;
var enableAttributes = WebGlCommon.enableAttributes;
var disableAttributes = WebGlCommon.disableAttributes;
var setViewport = WebGlCommon.setViewport;
var setupPixelEffectUniforms = WebGlCommon.setupPixelEffectUniforms;

var setDepth = WebGlCommon.setDepth;
var setTexture = WebGlCommon.setTexture;

var vertexSrc = require('../shaders/vertexEquirect');
var fragmentSrc = require('../shaders/fragmentEquirect');

var vertexIndices = [0, 1, 2, 0, 2, 3];
var vertexPositions = [-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0];
var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];

var attribList = ['aVertexPosition'];
var uniformList = [
  'uDepth', 'uOpacity', 'uSampler', 'uInvProjMatrix', 'uViewportMatrix',
  'uColorOffset', 'uColorMatrix', 'uTextureX', 'uTextureY', 'uTextureWidth',
  'uTextureHeight'
];


/**
 * @class WebGlEquirectRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link EquirectGeometry} and {@link RectilinearView},
 * appropriate for {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlEquirectRenderer(gl) {
  this.gl = gl;

  // The inverse projection matrix.
  this.invProjMatrix = mat4.create();

  // The viewport matrix responsible for viewport clamping.
  // See setViewport() for an explanation of how it works.
  this.viewportMatrix = mat4.create();

  this.constantBuffers = createConstantBuffers(gl, vertexIndices, vertexPositions, textureCoords);

  this.shaderProgram = createShaderProgram(gl, vertexSrc, fragmentSrc, attribList, uniformList);
}

WebGlEquirectRenderer.prototype.destroy = function() {
  destroyConstantBuffers(this.gl, this.constantBuffers);
  destroyShaderProgram(this.gl, this.shaderProgram);
  clearOwnProperties(this);
};


WebGlEquirectRenderer.prototype.startLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;
  var invProjMatrix = this.invProjMatrix;
  var viewportMatrix = this.viewportMatrix;

  gl.useProgram(shaderProgram);

  enableAttributes(gl, shaderProgram);

  setViewport(gl, layer, rect, viewportMatrix);
  gl.uniformMatrix4fv(shaderProgram.uViewportMatrix, false, viewportMatrix);

  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.vertexPositions);
  gl.vertexAttribPointer(shaderProgram.aVertexPosition, 3, gl.FLOAT, gl.FALSE, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, constantBuffers.textureCoords);

  // Compute and set the inverse projection matrix.
  mat4.copy(invProjMatrix, layer.view().projection());
  mat4.invert(invProjMatrix, invProjMatrix);

  gl.uniformMatrix4fv(shaderProgram.uInvProjMatrix, false, invProjMatrix);

  // Compute and set the texture scale and crop offsets.
  var textureCrop = layer.effects().textureCrop || {};
  var textureX = textureCrop.x != null ? textureCrop.x : 0;
  var textureY = textureCrop.y != null ? textureCrop.y : 0;
  var textureWidth = textureCrop.width != null ? textureCrop.width : 1;
  var textureHeight = textureCrop.height != null ? textureCrop.height : 1;

  gl.uniform1f(shaderProgram.uTextureX, textureX);
  gl.uniform1f(shaderProgram.uTextureY, textureY);
  gl.uniform1f(shaderProgram.uTextureWidth, textureWidth);
  gl.uniform1f(shaderProgram.uTextureHeight, textureHeight);

  setupPixelEffectUniforms(gl, layer.effects(), {
    opacity: shaderProgram.uOpacity,
    colorOffset: shaderProgram.uColorOffset,
    colorMatrix: shaderProgram.uColorMatrix
  });
};


WebGlEquirectRenderer.prototype.endLayer = function(layer, rect) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  disableAttributes(gl, shaderProgram);
};


WebGlEquirectRenderer.prototype.renderTile = function(tile, texture, layer, layerZ) {
  var gl = this.gl;
  var shaderProgram = this.shaderProgram;
  var constantBuffers = this.constantBuffers;

  setDepth(gl, shaderProgram, layerZ, tile.z);

  setTexture(gl, shaderProgram, texture);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, constantBuffers.vertexIndices);
  gl.drawElements(gl.TRIANGLES, vertexIndices.length, gl.UNSIGNED_SHORT, 0);
};


module.exports = WebGlEquirectRenderer;

},{"../shaders/fragmentEquirect":66,"../shaders/vertexEquirect":70,"../util/clearOwnProperties":82,"./WebGlCommon":59,"gl-matrix":3}],63:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlBaseRenderer = require('./WebGlBase');
var inherits = require('../util/inherits');

/**
 * @class WebGlFlatRenderer
 * @implements Renderer
 * @classdesc
 *
 * A renderer for {@link FlatGeometry} and {@link FlatView}, appropriate for a
 * {@link WebGlStage}.
 *
 * Most users do not need to instantiate this class. Renderers are created and
 * destroyed by {@link Stage} as necessary.
 */
function WebGlFlatRenderer() {
  this.constructor.super_.apply(this, arguments);
}

inherits(WebGlFlatRenderer, WebGlBaseRenderer);

module.exports = WebGlFlatRenderer;

},{"../util/inherits":95,"./WebGlBase":58}],64:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var WebGlFlat = require('./WebGlFlat');
var WebGlCube = require('./WebGlCube');
var WebGlCubeDepth = require('./WebGlCubeDepth');
var WebGlEquirect = require('./WebGlEquirect');

/**
 * Registers all known renderers for the given stage type into that stage.
 * Most users will not need to register renderers, as {@link Viewer} does it for
 * them.
 *
 * @param {Stage} stage The stage where the renderers are to be registered.
 * @throws An error if the stage type is unknown.
 */
function registerDefaultRenderers(stage) {
  switch (stage.type) {
    case 'webgl':
      stage.registerRenderer('flat', 'flat', WebGlFlat);
      stage.registerRenderer('cube', 'rectilinear', WebGlCube);
      stage.registerRenderer('cube+depth', 'rectilinear', WebGlCubeDepth);
      stage.registerRenderer('equirect', 'rectilinear', WebGlEquirect);
      break;
    default:
      throw new Error('Unknown stage type: ' + stage.type);
  }
}

module.exports = registerDefaultRenderers;

},{"./WebGlCube":60,"./WebGlCubeDepth":61,"./WebGlEquirect":62,"./WebGlFlat":63}],65:[function(require,module,exports){
'use strict';

module.exports = [
  '#ifdef GL_FRAGMENT_PRECISION_HIGH',
  'precision highp float;',
  '#else',
  'precision mediump float;',
  '#endif',

  'uniform sampler2D uSampler;',
  'uniform float uOpacity;',
  'uniform vec4 uColorOffset;',
  'uniform mat4 uColorMatrix;',

  'varying vec2 vTextureCoord;',

  `
  void main(void) {
    //if (!gl_FrontFacing) {
    //  discard; // Discard the front-facing triangles
    //} else {
      vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;
      gl_FragColor = vec4(color.rgba * uOpacity);
    //}
  }
  `
].join('\n');

},{}],66:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'#ifdef GL_FRAGMENT_PRECISION_HIGH',
'precision highp float;',
'#else',
'precision mediump float',
'#endif',

'uniform sampler2D uSampler;',
'uniform float uOpacity;',
'uniform float uTextureX;',
'uniform float uTextureY;',
'uniform float uTextureWidth;',
'uniform float uTextureHeight;',
'uniform vec4 uColorOffset;',
'uniform mat4 uColorMatrix;',

'varying vec4 vRay;',

'const float PI = 3.14159265358979323846264;',

'void main(void) {',
'  float r = inversesqrt(vRay.x * vRay.x + vRay.y * vRay.y + vRay.z * vRay.z);',
'  float phi  = acos(vRay.y * r);',
'  float theta = atan(vRay.x, -1.0*vRay.z);',
'  float s = 0.5 + 0.5 * theta / PI;',
'  float t = 1.0 - phi / PI;',

'  s = s * uTextureWidth + uTextureX;',
'  t = t * uTextureHeight + uTextureY;',

'  vec4 color = texture2D(uSampler, vec2(s, t)) * uColorMatrix + uColorOffset;',
'  gl_FragColor = vec4(color.rgba * uOpacity);',
'}'
].join('\n');

},{}],67:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'#ifdef GL_FRAGMENT_PRECISION_HIGH',
'precision highp float;',
'#else',
'precision mediump float;',
'#endif',

'uniform sampler2D uSampler;',
'uniform float uOpacity;',
'uniform vec4 uColorOffset;',
'uniform mat4 uColorMatrix;',

'varying vec2 vTextureCoord;',

'void main(void) {',

// `
// if (!gl_FrontFacing) {
//   discard; // Discard the front-facing triangles
// } else {
//   vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;
//   gl_FragColor = vec4(color.rgba * uOpacity);
// }
// `,

'  vec4 color = texture2D(uSampler, vTextureCoord) * uColorMatrix + uColorOffset;',
'  gl_FragColor = vec4(color.rgba * uOpacity);',
'}'
].join('\n');

},{}],68:[function(require,module,exports){
'use strict';

module.exports = [
  'attribute vec3 aVertexPosition;',
  'attribute vec2 aTextureCoord;',

  'uniform sampler2D uDepthmap;',
  'uniform float uDepth;',
  'uniform mat4 uViewportMatrix;',
  'uniform mat4 uProjMatrix;',
  'uniform mat4 uViewMatrix;',
  'uniform mat4 uModelMatrix;',

  'varying vec2 vTextureCoord;',

  `
  float i(in float a, in float b) {
    return b == 0.0 ? sign(a)*1.570796 : atan(a, b);
  }

  void main(void) {
    vec3 c = normalize(vec3(uModelMatrix * vec4(aVertexPosition, 1.0)));

    float x = (1.0 - i(-c.z, c.x)/3.141593)*0.5;
    float y = 0.5 - i(-c.y, sqrt(c.x*c.x + c.z*c.z))/3.141593;
    vec4 f = texture2D(uDepthmap, vec2(x, y));

    float j = (f.r*65536.0 + f.g*256.0 + f.b)/65793.0;
    vec3 b = c*(1.0 - j);
    vec3 a = vec3(uViewMatrix * vec4(b.z, b.y, -b.x, 1));

    gl_Position = uViewportMatrix * uProjMatrix * vec4(a, 1.0);
    gl_Position.z = uDepth * gl_Position.w;
    vTextureCoord = aTextureCoord;
  }
  `
].join('\n');

},{}],69:[function(require,module,exports){
'use strict';

module.exports = [
  'attribute vec3 aVertexPosition;',
  'attribute vec2 aTextureCoord;',

  'uniform samplerCube uDepthmap;',
  'uniform float uDepth;',
  'uniform mat4 uViewportMatrix;',
  'uniform mat4 uProjMatrix;',
  'uniform mat4 uViewMatrix;',
  'uniform mat4 uModelMatrix;',

  'varying vec2 vTextureCoord;',

  `
  void main(void) {
    vec3 a = vec3(uModelMatrix * vec4(aVertexPosition, 1.0));
    vec3 b = normalize(a);

    vec4 e = textureCube(uDepthmap, a);

    float h = (e.r * 256.0 * 256.0 + e.g * 256.0 + e.b)/65025.0;
    b = b * 1.5 * (1.0 - h);
    a = vec3(uViewMatrix * vec4(b, 1));

    gl_Position = uViewportMatrix * uProjMatrix * vec4(a, 1.0);
    gl_Position.z = uDepth * gl_Position.w;
    vTextureCoord = aTextureCoord;
  }
  `
].join('\n');

},{}],70:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'attribute vec3 aVertexPosition;',

'uniform float uDepth;',
'uniform mat4 uViewportMatrix;',
'uniform mat4 uInvProjMatrix;',

'varying vec4 vRay;',

'void main(void) {',
'  vRay = uInvProjMatrix * vec4(aVertexPosition.xy, 1.0, 1.0);',
'  gl_Position = uViewportMatrix * vec4(aVertexPosition.xy, uDepth, 1.0);',
'}'
].join('\n');

},{}],71:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

module.exports = [
'attribute vec3 aVertexPosition;',
'attribute vec2 aTextureCoord;',

'uniform float uDepth;',
'uniform mat4 uViewportMatrix;',
'uniform mat4 uProjMatrix;',
'uniform mat4 uViewMatrix;',
'uniform mat4 uModelMatrix;',

'varying vec2 vTextureCoord;',

'void main(void) {',
'  gl_Position = uViewportMatrix * uProjMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);',
'  gl_Position.z = uDepth * gl_Position.w;',
'  vTextureCoord = aTextureCoord;',
'}'
].join('\n');

},{}],72:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var NetworkError = require('../NetworkError');
var WorkPool = require('../collections/WorkPool');
var chain = require('../util/chain');
var delay = require('../util/delay');
var now = require('../util/now');


// Map template properties to their corresponding tile properties.
var templateProperties = {
  x: 'x',
  y: 'y',
  z: 'z',
  f: 'face'
};

// Default face order for cube maps.
var defaultCubeMapFaceOrder = 'bdflru';

// Default maximum number of concurrent requests.
var defaultConcurrency = 4;

// Default milliseconds to wait before retrying failed requests.
var defaultRetryDelay = 10000;


/**
 * @class ImageUrlSource
 * @implements Source
 * @classdesc
 *
 * A {@link Source} that loads {@link Asset assets} from images given a URL and
 * a crop rectangle.
 *
 * @param {Function} sourceFromTile Function that receives a tile and returns
 * a `{ url, rect }` object, where `url` is an image URL and `rect`, when
 * present, is an `{ x, y, width, height }` object in normalized coordinates
 * denoting the portion of the image to use.
 * @param {Object} opts
 * @param {number} [opts.concurrency=4] Maximum number of tiles to request at
 *     the same time. The limit is per {@link ImageSourceUrl} instance.
 * @param {number} [opts.retryDelay=10000] Time in milliseconds to wait before
 *     retrying a failed request.
 */
function ImageUrlSource(sourceFromTile, opts) {

  opts = opts ? opts : {};

  this._loadPool = new WorkPool({
    concurrency: opts.concurrency || defaultConcurrency
  });

  this._retryDelay = opts.retryDelay || defaultRetryDelay;
  this._retryMap = {};

  this._sourceFromTile = sourceFromTile;
}

eventEmitter(ImageUrlSource);


ImageUrlSource.prototype.loadAsset = function(stage, tile, done) {

  var self = this;

  var retryDelay = this._retryDelay;
  var retryMap = this._retryMap;

  var tileSource = this._sourceFromTile(tile);
  var url = tileSource.url;
  var rect = tileSource.rect;

  var loadImage = stage.loadImage.bind(stage, url, rect);

  var loadFn = function(done) {
    // TODO: Deduplicate load requests for the same URL. Although the browser
    // might be smart enough to avoid duplicate requests, they are still unduly
    // impacted by the concurrency parameter.
    return self._loadPool.push(loadImage, function(err, asset) {
      if (err) {
        if (err instanceof NetworkError) {
          // If a network error occurred, wait before retrying.
          retryMap[url] = now();
          self.emit('networkError', err, tile);
        }
        done(err, tile);
      } else {
        // On a successful fetch, forget the previous timeout.
        delete retryMap[url];
        done(null, tile, asset);
      }
    });
  };

  // Check whether we are retrying a failed request.
  var delayAmount;
  var lastTime = retryMap[url];
  if (lastTime != null) {
    var currentTime = now();
    var elapsed = currentTime - lastTime;
    if (elapsed < retryDelay) {
      // Wait before retrying.
      delayAmount = retryDelay - elapsed;
    } else {
      // Retry timeout expired; perform the request at once.
      delayAmount = 0;
      delete retryMap[url];
    }
  }

  var delayFn = delay.bind(null, delayAmount);

  return chain(delayFn, loadFn)(done);
};


/**
 * Creates an ImageUrlSource from a string template.
 *
 * @param {String} url Tile URL template, which may contain the following
 *    placeholders:
 *    - `{f}` : tile face (one of `b`, `d`, `f`, `l`, `r`, `u`)
 *    - `{z}` : tile level index (0 is the smallest level)
 *    - `{x}` : tile horizontal index
 *    - `{y}` : tile vertical index
 * @param {Object} opts In addition to the options already supported by the
 *     {@link ImageUrlSource} constructor.
 * @param {String} opts.cubeMapPreviewUrl URL to use as the preview level.
 *     This must be a single image containing six cube faces laid out
 *     vertically according to the face order parameter.
 * @param {String} [opts.cubeMapPreviewFaceOrder='bdflru'] Face order within
 *     the preview image.
 */
ImageUrlSource.fromString = function(url, opts) {
  opts = opts || {};

  var faceOrder = opts && opts.cubeMapPreviewFaceOrder || defaultCubeMapFaceOrder;

  var urlFn = opts.cubeMapPreviewUrl ? withPreview : withoutPreview;

  return new ImageUrlSource(urlFn, opts);

  function withoutPreview(tile) {
    var tileUrl = url;

    for (var property in templateProperties) {
      var templateProperty = templateProperties[property];
      var regExp = propertyRegExp(property);
      var valueFromTile = tile.hasOwnProperty(templateProperty) ? tile[templateProperty] : '';
      tileUrl = tileUrl.replace(regExp, valueFromTile);
    }

    return { url: tileUrl };
  }

  function withPreview(tile) {
    if (tile.z === 0) {
      return cubeMapUrl(tile);
    }
    else {
      return withoutPreview(tile);
    }
  }

  function cubeMapUrl(tile) {
    var y = faceOrder.indexOf(tile.face) / 6;
    return {
      url: opts.cubeMapPreviewUrl,
      rect: { x: 0, y: y, width: 1, height: 1/6 }
    };
  }
};

function propertyRegExp(property) {
  var regExpStr = '\\{(' + property + ')\\}';
  return new RegExp(regExpStr, 'g');
}

module.exports = ImageUrlSource;

},{"../NetworkError":19,"../collections/WorkPool":33,"../util/chain":80,"../util/delay":90,"../util/now":99,"minimal-event-emitter":14}],73:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class SingleAssetSource
 * @implements Source
 * @classdesc
 *
 * A {@link Source} that always provides the same {@link Asset}.
 *
 * @param {Asset} asset The asset.
*/
function SingleAssetSource(asset) {
  this._asset = asset;
}

SingleAssetSource.prototype.asset = function() {
  return this._asset;
};

SingleAssetSource.prototype.loadAsset = function(stage, tile, done) {
  var self = this;

  var timeout = setTimeout(function() {
    done(null, tile, self._asset);
  }, 0);

  function cancel() {
    clearTimeout(timeout);
    done.apply(null, arguments);
  }

  return cancel;
};

module.exports = SingleAssetSource;

},{}],74:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @class RendererRegistry
 * @classdesc
 *
 * A RendererRegistry maps pairs of {@link Geometry} and {@link View} type into
 * the appropriate {@link Renderer} class. It is used by a {@link Stage} to
 * determine the appropriate renderer for a {@link Layer}.
 *
 * See also {@link Stage#registerRenderer}.
 */
function RendererRegistry() {
  this._renderers = {};
}

/**
 * Registers a renderer for the given geometry and view type.
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class.
 */
RendererRegistry.prototype.set = function(geometryType, viewType, Renderer) {
  if (!this._renderers[geometryType]) {
    this._renderers[geometryType] = {};
  }
  this._renderers[geometryType][viewType] = Renderer;
};

/**
 * Retrieves the renderer for the given geometry and view type.
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class, or null if no such renderer has been
 * registered.
 */
RendererRegistry.prototype.get = function(geometryType, viewType) {
  var Renderer = this._renderers[geometryType] &&
      this._renderers[geometryType][viewType];
  return Renderer || null;
};

module.exports = RendererRegistry;

},{}],75:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var WorkQueue = require('../collections/WorkQueue');
var calcRect = require('../util/calcRect');
var async = require('../util/async');
var cancelize = require('../util/cancelize');
var clearOwnProperties = require('../util/clearOwnProperties');

var RendererRegistry = require('./RendererRegistry');

function forwardTileCmp(t1, t2) {
  return t1.cmp(t2);
}

function reverseTileCmp(t1, t2) {
  return -t1.cmp(t2);
}

/**
 * Signals that the stage has been rendered.
 *
 * @param {boolean} stable Whether all tiles were successfully rendered without
 *     missing textures or resorting to fallbacks.
 * @event Stage#renderComplete
 */

/**
 * Signals that the contents of the stage have been invalidated and must be
 * rendered again.
 *
 * This is used by the {@link RenderLoop} implementation.
 *
 * @event Stage#renderInvalid
 */

/**
 * @interface Stage
 * @classdesc
 *
 * A Stage is a container with the ability to render a stack of
 * {@link Layer layers}.
 *
 * This class should never be instantiated directly. Use {@link WebGlStage}
 * instead.
 *
 * @param {Object} opts
 * @param {boolean} [opts.progressive=false]
 *
 * Options listed here may be passed into the `opts` constructor argument of
 * subclasses.
 *
 * The `progressive` option controls whether resolution levels are loaded in
 * order, from lowest to highest. This results in a more pleasing effect when
 * zooming past several levels in a large panoramas, but consumes additional
 * bandwidth.
 */
function Stage(opts) {
  this._progressive = !!(opts && opts.progressive);

  // The list of layers in display order (background to foreground).
  this._layers = [];

  // The list of renderers; the i-th renderer is for the i-th layer.
  this._renderers = [];

  // The lists of tiles to load and render, populated during render().
  this._tilesToLoad = [];
  this._tilesToRender = [];

  // Temporary tile lists.
  this._tmpVisible = [];
  this._tmpChildren = [];

  // Cached stage dimensions.
  // Start with zero, which inhibits rendering until setSize() is called.
  this._width = 0;
  this._height = 0;

  // Temporary variable for rect.
  this._tmpRect = {};

  // Temporary variable for size.
  this._tmpSize = {};

  // Work queue for createTexture.
  this._createTextureWorkQueue = new WorkQueue();

  // Function to emit event when render parameters have changed.
  this._emitRenderInvalid = this._emitRenderInvalid.bind(this);

  // The renderer registry maps each geometry/view pair into the respective
  // Renderer class.
  this._rendererRegistry = new RendererRegistry();
}

eventEmitter(Stage);


/**
 * Destructor.
 */
Stage.prototype.destroy = function() {
  this.removeAllLayers();
  clearOwnProperties(this);
};


/**
 * Registers a {@link Renderer} for the given {@link Geometry} and {@link View}
 * type.
 *
 * The {@link registerDefaultRenderers} utility function may be used to
 * register all known renderers for a stage type into that stage. Most users
 * will not need to register renderers, as {@link Viewer} does it for them.
 *
 * @param {string} geometryType The geometry type, as given by
 *     {@link Geometry#type}.
 * @param {string} viewType The view type, as given by {@link View#type}.
 * @param {*} Renderer The renderer class.
 */
Stage.prototype.registerRenderer = function(geometryType, viewType, Renderer) {
  return this._rendererRegistry.set(geometryType, viewType, Renderer);
};


/**
 * Returns the underlying DOM element.
 *
 * Must be overridden by subclasses.
 *
 * @return {Element}
 */
Stage.prototype.domElement = function() {
  throw new Error('Stage implementation must override domElement');
};


/**
 * Get the stage width.
 * @return {number}
 */
Stage.prototype.width = function() {
  return this._width;
};


/**
 * Get the stage height.
 * @return {number}
 */
Stage.prototype.height = function() {
  return this._height;
};


/**
 * Get the stage dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 *
 * @param {Size=} size
 */
Stage.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Set the stage dimensions.
 *
 * This contains the size update logic common to all stage types. Subclasses
 * must define the {@link Stage#setSizeForType} method to perform their own
 * logic.
 *
 * @param {Size} size
 */
Stage.prototype.setSize = function(size) {
  this._width = size.width;
  this._height = size.height;

  this.setSizeForType(); // must be defined by subclasses.

  this.emit('resize');
  this._emitRenderInvalid();
};


/**
 * Call {@link Stage#setSize} instead.
 *
 * This contains the size update logic specific to a stage type. It is called by
 * {@link Stage#setSize} after the base class has been updated to reflect the
 * new size, but before any events are emitted.
 *
 * @param {Size} size
 */
Stage.prototype.setSizeForType = function(size) {
  throw new Error('Stage implementation must override setSizeForType');
};


/**
 * Loads an {@link Asset} from an image.
 * @param {string} url The image URL.
 * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null
 *     to use the full image.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
Stage.prototype.loadImage = function() {
  throw new Error('Stage implementation must override loadImage');
};

/**
 * Loads an {@link Asset} from a 3D model file, only support STL for now.
 * @param {string} url The STL file URL.
 * @param {function(?Error, Asset)} done The callback.
 * @return {function()} A function to cancel loading.
 */
Stage.prototype.loadModel = function() {
  throw new Error('Stage implementation must override loadSTLModel');
};

Stage.prototype._emitRenderInvalid = function() {
  this.emit('renderInvalid');
};


/**
 * Verifies that the layer is valid for this stage, throwing an exception
 * otherwise.
 *
 * @param {Layer} layer
 * @throws {Error} If the layer is not valid for this stage.
 */
Stage.prototype.validateLayer = function(layer) {
  throw new Error('Stage implementation must override validateLayer');
};


/**
 * Returns a list of all {@link Layer layers} belonging to the stage. The
 * returned list is in display order, background to foreground.
 * @return {Layer[]}
 */
Stage.prototype.listLayers = function() {
  // Return a copy to prevent unintended mutation by the caller.
  return [].concat(this._layers);
};


/**
 * Return whether a {@link Layer layer} belongs to the stage.
 * @param {Layer} layer
 * @return {boolean}
 */
Stage.prototype.hasLayer = function(layer) {
  return this._layers.indexOf(layer) >= 0;
};


/**
 * Adds a {@link Layer layer} into the stage.
 * @param {Layer} layer The layer to add.
 * @param {number|undefined} i The optional position, where 0  i  n and n is
 *     the current number of layers. The default is n, which inserts at the
 *     top of the display stack.
 * @throws An error if the layer already belongs to the stage or if the position
 *     is invalid.
 */
Stage.prototype.addLayer = function(layer, i) {
  if (this._layers.indexOf(layer) >= 0) {
    throw new Error('Layer already in stage');
  }

  if (i == null) {
    i = this._layers.length;
  }
  if (i < 0 || i > this._layers.length) {
    throw new Error('Invalid layer position');
  }

  this.validateLayer(layer); // must be defined by subclasses.

  var geometryType = layer.geometry().type;
  if (layer.depthmap()) {
    geometryType += '+depth';
  }
  var viewType = layer.view().type;
  var rendererClass = this._rendererRegistry.get(geometryType, viewType);
  if (!rendererClass) {
    throw new Error('No ' + this.type + ' renderer avaiable for ' +
        geometryType + ' geometry and ' + viewType + ' view');
  }
  var renderer = this.createRenderer(rendererClass, { layer });

  this._layers.splice(i, 0, layer);
  this._renderers.splice(i, 0, renderer);

  // Listeners for render invalid.
  layer.addEventListener('viewChange', this._emitRenderInvalid);
  layer.addEventListener('effectsChange', this._emitRenderInvalid);
  layer.addEventListener('fixedLevelChange', this._emitRenderInvalid);
  layer.addEventListener('textureStoreChange', this._emitRenderInvalid);

  this._emitRenderInvalid();
};


/**
 * Moves a {@link Layer layer} into a different position in the display stack.
 * @param {Layer} layer The layer to move.
 * @param {number} i The position, where 0  i  n-1 and n is the current number
 *     of layers.
 * @throws An error if the layer does not belong to the stage or if the position
 *     is invalid.
 */
Stage.prototype.moveLayer = function(layer, i) {
  var index = this._layers.indexOf(layer);
  if (index < 0) {
    throw new Error('No such layer in stage');
  }

  if (i < 0 || i >= this._layers.length) {
    throw new Error('Invalid layer position');
  }

  layer = this._layers.splice(index, 1)[0];
  var renderer = this._renderers.splice(index, 1)[0];

  this._layers.splice(i, 0, layer);
  this._renderers.splice(i, 0, renderer);

  this._emitRenderInvalid();
};


/**
 * Removes a {@link Layer} from the stage.
 * @param {Layer} layer The layer to remove.
 * @throws An error if the layer does not belong to the stage.
 */
Stage.prototype.removeLayer = function(layer) {
  var index = this._layers.indexOf(layer);
  if (index < 0) {
    throw new Error('No such layer in stage');
  }

  var removedLayer = this._layers.splice(index, 1)[0];
  var renderer = this._renderers.splice(index, 1)[0];

  this.destroyRenderer(renderer);

  removedLayer.removeEventListener('viewChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('effectsChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('fixedLevelChange', this._emitRenderInvalid);
  removedLayer.removeEventListener('textureStoreChange', this._emitRenderInvalid);

  this._emitRenderInvalid();
};


/**
 * Removes all {@link Layer layers} from the stage.
 */
Stage.prototype.removeAllLayers = function() {
  while (this._layers.length > 0) {
    this.removeLayer(this._layers[0]);
  }
};


/**
 * Called before a frame is rendered.
 *
 * Must be overridden by subclasses.
 */
Stage.prototype.startFrame = function() {
  throw new Error('Stage implementation must override startFrame');
};


/**
 * Called after a frame is rendered.
 *
 * Must be overridden by subclasses.
 */
Stage.prototype.endFrame = function() {
  throw new Error('Stage implementation must override endFrame');
};


/**
 * Render the current frame. Usually called from a {@link RenderLoop}.
 *
 * This contains the rendering logic common to all stage types. Subclasses
 * define the startFrame() and endFrame() methods to perform their own logic.
 */
Stage.prototype.render = function() {
  var i, j;

  var tilesToLoad = this._tilesToLoad;
  var tilesToRender = this._tilesToRender;

  var stableStage = true;
  var stableLayer;

  // Get the stage dimensions.
  var width = this._width;
  var height = this._height;

  var rect = this._tmpRect;
  var size = this._tmpSize;

  if (width <= 0 || height <= 0) {
    return;
  }

  this.startFrame(); // defined by subclasses

  // Signal start of frame to the texture stores.
  for (i = 0; i < this._layers.length; i++) {
    this._layers[i].textureStore().startFrame();
  }

  // Render layers.
  for (i = 0; i < this._layers.length; i++) {
    var layer = this._layers[i];
    var effects = layer.effects();
    var view = layer.view();
    var textureStore = layer.textureStore();
    var renderer = this._renderers[i];
    var depth = this._layers.length - i;
    var tile, texture;

    // Convert the rect effect into a normalized rect.
    // TODO: avoid doing this on every frame.
    calcRect(width, height, effects && effects.rect, rect);

    if (rect.width <= 0 || rect.height <= 0) {
      // Skip rendering on a null viewport.
      continue;
    }

    // Update the view size.
    size.width = rect.width * this._width;
    size.height = rect.height * this._height;
    view.setSize(size);

    // Signal start of layer to the renderer.
    renderer.startLayer(layer, rect);

    // We render with both alpha blending and depth testing enabled. Thus, when
    // rendering a subsequent pixel at the same location than an existing one,
    // the subsequent pixel gets discarded unless it has smaller depth, and is
    // otherwise composited with the existing pixel.
    //
    // When using fallback tiles to fill a gap in the preferred resolution
    // level, we prefer higher resolution fallbacks to lower resolution ones.
    // However, where fallbacks overlap, we want higher resolution ones to
    // prevail, and we don't want multiple fallbacks to be composited with each
    // other, as that would produce a bad result when semitransparent textures
    // are involved.
    //
    // In order to achieve this within the constraints of alpha blending and
    // depth testing, the depth of a tile must be inversely proportional to its
    // resolution, and higher-resolution tiles must be rendered before lower-
    // resolution ones.

    // Collect the lists of tiles to load and render.
    stableLayer = this._collectTiles(layer, textureStore);

    // Mark all the tiles whose textures must be loaded.
    // This will either trigger loading (for textures not yet loaded) or
    // prevent unloading (for textures already loaded).
    for (j = 0; j < tilesToLoad.length; j++) {
      tile = tilesToLoad[j];
      textureStore.markTile(tile);
    }

    // Render tiles.
    for (j = 0; j < tilesToRender.length; j++) {
      tile = tilesToRender[j];
      texture = textureStore.texture(tile);
      renderer.renderTile(tile, texture, layer, depth);
    }

    layer.emit('renderComplete', stableLayer);
    if (!stableLayer) {
      stableStage = false;
    }

    // Signal end of layer to the renderer.
    renderer.endLayer(layer, rect);
  }

  // Signal end of frame to the texture stores.
  for (i = 0; i < this._layers.length; i++) {
    this._layers[i].textureStore().endFrame();
  }

  this.endFrame(); // defined by subclasses

  this.emit('renderComplete', stableStage);
};

Stage.prototype._collectTiles = function(layer, textureStore) {
  var tilesToLoad = this._tilesToLoad;
  var tilesToRender = this._tilesToRender;
  var tmpVisible = this._tmpVisible;

  tilesToLoad.length = 0;
  tilesToRender.length = 0;
  tmpVisible.length = 0;

  layer.visibleTiles(tmpVisible);

  var isStable = true;

  for (var i = 0; i < tmpVisible.length; i++) {
    var tile = tmpVisible[i];
    var needsFallback;
    this._collectTileToLoad(tile);
    if (textureStore.texture(tile)) {
      // The preferred texture is available.
      // No fallback is required.
      needsFallback = false;
      this._collectTileToRender(tile);
    } else {
      // The preferred texture is unavailable.
      // Collect children for rendering as a fallback.
      needsFallback = this._collectChildren(tile, textureStore);
      isStable = false;
    }
    // Collect all parents for loading, and the closest parent for rendering if
    // a fallback is required.
    this._collectParents(tile, textureStore, needsFallback);
  }

  // Sort tiles to load in ascending resolution order.
  tilesToLoad.sort(forwardTileCmp);

  // Sort tiles to render in descending resolution order.
  tilesToRender.sort(reverseTileCmp);

  return isStable;
};

Stage.prototype._collectChildren = function(tile, textureStore) {
  var tmpChildren = this._tmpChildren;

  var needsFallback = true;

  // Fall back as many levels as necessary on single-child geometries, but do
  // not go beyond immediate children on multiple-child geometries, to avoid
  // exploring an exponential number of tiles.
  do {
    tmpChildren.length = 0;
    if (!tile.children(tmpChildren)) {
      break;
    }
    needsFallback = false;
    for (var i = 0; i < tmpChildren.length; i++) {
      tile = tmpChildren[i];
      if (textureStore.texture(tile)) {
        this._collectTileToLoad(tile);
        this._collectTileToRender(tile);
      } else {
        needsFallback = true;
      }
    }
  } while (needsFallback && tmpChildren.length === 1)

  return needsFallback;
};

Stage.prototype._collectParents = function(tile, textureStore, needsFallback) {
  // Recursively visit parent tiles until:
  //   - all parents have been marked for loading, if progressive rendering is
  //     enabled; and
  //   - at least one parent has been marked for both loading and rendering, if
  //     a fallback is required.
  var needsLoading = this._progressive;
  while ((needsLoading || needsFallback) && (tile = tile.parent()) != null) {
    if (needsFallback) {
      if (textureStore.texture(tile)) {
        this._collectTileToRender(tile);
        needsFallback = false;
      } else if (!this._progressive) {
        continue;
      }
    }
    if (!this._collectTileToLoad(tile)) {
      needsLoading = false;
    }
  }
  return needsFallback;
};

Stage.prototype._collectTileToLoad = function(tile) {
  return this._collectTileIntoList(tile, this._tilesToLoad);
};

Stage.prototype._collectTileToRender = function(tile) {
  return this._collectTileIntoList(tile, this._tilesToRender);
};

Stage.prototype._collectTileIntoList = function(tile, tileList) {
  // TODO: Investigate whether it's worth it to make this better than O(n).
  var found = false;
  for (var i = 0; i < tileList.length; i++) {
    if (tile.equals(tileList[i])) {
      found = true;
      break;
    }
  }
  if (!found) {
    tileList.push(tile);
  }
  return !found;
};

/**
 * Create a texture for the given tile and asset. Called by {@link TextureStore} and {@link DepthmapStore}.
 * @param {Tile} tile
 * @param {Asset} asset
 * @param {Function} done
 */
Stage.prototype.createTexture = function(tile, asset, done) {

  var self = this;

  function makeTexture() {
    return new self.TextureClass(self, tile, asset);
  }

  var fn = cancelize(async(makeTexture));

  return this._createTextureWorkQueue.push(fn, function(err, texture) {
    done(err, tile, asset, texture);
  });

};

/**
 * The stage type, used to determine the appropriate renderer for a given
 * geometry and view.
 *
 * The sole known value is `"webgl".
 *
 * See also {@link Stage#registerRenderer}.
 *
 * @property {string}
 * @name Stage#type
 */

module.exports = Stage;

},{"../collections/WorkQueue":34,"../util/async":77,"../util/calcRect":78,"../util/cancelize":79,"../util/clearOwnProperties":82,"./RendererRegistry":74,"minimal-event-emitter":14}],76:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var Stage = require('./Stage');
var HtmlImageLoader = require('../loaders/HtmlImage');
var HtmlModelLoader = require('../loaders/HtmlModel');
var browser = require('bowser');
var inherits = require('../util/inherits');
var pixelRatio = require('../util/pixelRatio');
var ispot = require('../util/ispot');
var setAbsolute = require('../util/dom').setAbsolute;
var setFullSize = require('../util/dom').setFullSize;
var clearOwnProperties = require('../util/clearOwnProperties');

// TODO(tjgq): Unify Stage and WebGlStage.

// Browser-specific workarounds.
var browserQuirks = {
  // Whether to use texImage2D instead of texSubImage2D when repainting an
  // existing texture from a video element. On most browsers texSubImage2D is
  // faster, but on Chrome the performance degrades significantly. See:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=612542
  videoUseTexImage2D: browser.chrome
};


function initWebGlContext(canvas, opts) {
  var options = {
    alpha: true,
    premultipliedAlpha: true,
    antialias: !!(opts && opts.antialias),
    preserveDrawingBuffer: !!(opts && opts.preserveDrawingBuffer)
  };

  var gl = (canvas.getContext) && (canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options));

  if (!gl) {
    throw new Error('Could not get WebGL context');
  }

  // Enable back-face culling
  gl.enable(gl.CULL_FACE);
  gl.frontFace(gl.CW);
  gl.cullFace(gl.FRONT); // Discard front-facing triangles
  
  if (opts.wrapContext) {
    gl = opts.wrapContext(gl);
  }

  return gl;
}

/**
 * @class WebGlStage
 * @extends Stage
 * @classdesc
 *
 * A {@link Stage} implementation using WebGl.
 *
 * @param {Object} opts
 * @param {boolean} [opts.antialias=false]
 * @param {boolean} [opts.preserveDrawingBuffer=false]
 * @param {boolean} [opts.generateMipmaps=false]
 * @param {function} [opts.wrapContext]
 *
 * The `antialias` and `preserveDrawingBuffer` options control the WebGL
 * context attributes of the same name. The `alpha` and `premultipliedAlpha`
 * WebGL context attributes are set to their default true value and cannot
 * be overriden; this allows semitransparent textures to be composited with
 * the page. See:
 * https://www.khronos.org/registry/webgl/specs/1.0/#WEBGLCONTEXTATTRIBUTES
 *
 * The `generateMipmaps` option controls texture mipmap generation. Mipmaps
 * may improve rendering quality, at the cost of increased memory usage.
 * Due to technical limitations, they are only generated for textures whose
 * dimensions are a power of two. See:
 * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
 *
 * The `wrapContext` option is a function that receives and returns a
 * WebGLRenderingContext. The stage will use its return value as the context.
 * This is useful when used together with WebGLDebugUtils to debug WebGL issues.
 * See https://www.khronos.org/webgl/wiki/Debugging.
 *
 * Also see the available {@link Stage} options.
 */
function WebGlStage(opts) {
  opts = opts || {};

  var self = this;

  this.constructor.super_.call(this, opts);

  this._generateMipmaps = opts.generateMipmaps != null ?
    opts.generateMipmaps : false;

  this._loader = new HtmlImageLoader(this);
  this._modelLoader = new HtmlModelLoader(this);

  this._domElement = document.createElement('canvas');

  setAbsolute(this._domElement);
  setFullSize(this._domElement);

  this._gl = initWebGlContext(this._domElement, opts);

  this._handleContextLoss = function() {
    self.emit('webglcontextlost');
    self._gl = null;
  };

  // Handle WebGl context loss.
  this._domElement.addEventListener('webglcontextlost', this._handleContextLoss);

  // WebGl renderers are singletons for a given stage. This list stores the
  // existing renderers so they can be reused across layers with the same
  // geometry and view type.
  this._rendererInstances = [];

  // Width and Height segments for depthmap mesh.
  this._widthSegments = opts.widthSegments ? opts.widthSegments : undefined;
  this._heightSegments = opts.heightSegments ? opts.heightSegments : undefined;
}

inherits(WebGlStage, Stage);


/**
 * Destructor.
 */
WebGlStage.prototype.destroy = function() {
  this._domElement.removeEventListener('webglcontextlost', this._handleContextLoss);
  // Delegate clearing own properties to the Stage destructor.
  this.constructor.super_.prototype.destroy.call(this);
};


/**
 * Returns the underlying DOM element.
 *
 * @return {Element}
 */
WebGlStage.prototype.domElement = function() {
  return this._domElement;
};


/**
 * Returns the underlying WebGL rendering context.
 *
 * @return {WebGLRenderingContext }
 */
WebGlStage.prototype.webGlContext = function() {
  return this._gl;
};


WebGlStage.prototype.setSizeForType = function() {
  // Update the size of the canvas coordinate space.
  //
  // The size is obtained by taking the stage dimensions, which are set in CSS
  // pixels, and multiplying them by the device pixel ratio. Crucially, this
  // must be the only place where the WebGL rendering pipeline accesses the
  // pixel ratio; subsequent uses should reference the `drawingBufferWidth` and
  // `drawingBufferHeight` properties on the WebGLRenderingContext. Failing to
  // do so will break the rendering if the pixel ratio changes but the stage
  // size does not, e.g. when moving the window across screens.
  var ratio = pixelRatio();
  this._domElement.width = ratio * this._width;
  this._domElement.height = ratio * this._height;
};


WebGlStage.prototype.loadImage = function(url, rect, done) {
  return this._loader.loadImage(url, rect, done);
};

WebGlStage.prototype.loadModel = function(url, done) {
  return this._modelLoader.loadModel(url, done);
};

WebGlStage.prototype.maxTextureSize = function() {
  return this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);
};


WebGlStage.prototype.validateLayer = function(layer) {
  var tileSize = layer.geometry().maxTileSize();
  var maxTextureSize = this.maxTextureSize();
  if (tileSize > maxTextureSize) {
    throw new Error('Layer has level with tile size larger than maximum texture size (' + tileSize + ' vs. ' + maxTextureSize + ')');
  }
};


WebGlStage.prototype.createRenderer = function(Renderer, opts) {
  var rendererInstances = this._rendererInstances;
  for (var i = 0; i < rendererInstances.length; i++) {
    if (rendererInstances[i] instanceof Renderer) {
      return rendererInstances[i];
    }
  }
  var renderer = new Renderer(this._gl, {
    widthSegments: this._widthSegments,
    heightSegments: this._heightSegments,
    ...opts
  });
  rendererInstances.push(renderer);
  return renderer;
};


WebGlStage.prototype.destroyRenderer = function(renderer) {
  var rendererInstances = this._rendererInstances;
  if (this._renderers.indexOf(renderer) < 0) {
    renderer.destroy();
    var index = rendererInstances.indexOf(renderer);
    if (index >= 0) {
      rendererInstances.splice(index, 1);
    }
  }
};


WebGlStage.prototype.startFrame = function() {

  var gl = this._gl;

  if (!gl) {
    throw new Error('Bad WebGL context - maybe context was lost?');
  }

  // Set the WebGL viewport.
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

  // Clear framebuffer.
  gl.clearColor(0.0, 0.0, 0.0, 0.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Enable depth testing.
  gl.enable(gl.DEPTH_TEST);

  // Enable blending. ONE and ONE_MINUS_SRC_ALPHA are the right choices for
  // premultiplied textures.
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

};


WebGlStage.prototype.endFrame = function() {};


WebGlStage.prototype.takeSnapshot = function(options) {

  // Validate passed argument
  if (typeof options !== 'object' || options == null) {
    options = {};
  }

  var quality = options.quality;

  // Set default quality if it is not passed
  if (typeof quality == 'undefined') {
    quality = 75;
  }

  // Throw if quality is of invlid type or out of bounds
  if (typeof quality !== 'number' || quality < 0 || quality > 100) {
    throw new Error('WebGLStage: Snapshot quality needs to be a number between 0 and 100');
  }

  // Canvas method "toDataURL" needs to be called in the same
  // context as where the actual rendering is done. Hence this.
  this.render();

  // Return the snapshot
  return this._domElement.toDataURL('image/jpeg', quality / 100);
}


WebGlStage.type = WebGlStage.prototype.type = 'webgl';


function WebGlTexture(stage, tile, asset) {
  this._stage = stage;
  this._gl = stage._gl;
  this._texture = null;
  this._timestamp = null;
  this._width = this._height = null;
  this.refresh(tile, asset);
}


WebGlTexture.prototype.refresh = function(tile, asset) {

  var gl = this._gl;
  var stage = this._stage;
  var texture;

  // Check whether the texture needs to be updated.
  var timestamp = asset.timestamp();
  if (timestamp === this._timestamp) {
    return;
  }

  // Get asset element.
  var element = asset.element();

  // Get asset dimensions.
  var width = asset.width();
  var height = asset.height();

  if (width !== this._width || height !== this._height) {

    // If the texture dimensions have changed since the last refresh, create
    // a new texture with the correct size.

    // Check if texture dimensions would exceed the maximum texture size.
    var maxSize = stage.maxTextureSize();
    if (width > maxSize) {
      throw new Error('Texture width larger than max size (' + width + ' vs. ' + maxSize + ')');
    }
    if (height > maxSize) {
      throw new Error('Texture height larger than max size (' + height + ' vs. ' + maxSize + ')');
    }

    // Delete the current texture if it exists.
    // This is necessary for Chrome on Android. If it isn't done the textures
    // do not render when the size changes.
    if (this._texture) {
      gl.deleteTexture(texture);
    }

    // The texture must be premultiplied by alpha to ensure correct blending of
    // semitransparent textures. For details, see:
    // http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/
    texture = this._texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);

  } else {

    // If the texture dimensions remain the same, repaint the existing texture.
    // Repainting with texSubImage2D is usually faster than with texImage2D,
    // except in the case noted in browserQuirks.

    texture = this._texture;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

    if (element instanceof HTMLVideoElement && browserQuirks.videoUseTexImage2D) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, element);
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, element);
    }

  }

  // Generate mipmap if the corresponding stage option is set and the texture
  // dimensions are powers of two.
  if (stage._generateMipmaps && ispot(width) && ispot(height)) {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.generateMipmap(gl.TEXTURE_2D);
  } else {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  }

  // Clamp texture to edges.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // Unbind texture.
  gl.bindTexture(gl.TEXTURE_2D, null);

  // Update texture dimensions and timestamp.
  this._timestamp = timestamp;
  this._width = width;
  this._height = height;

};


WebGlTexture.prototype.destroy = function() {
  if (this._texture) {
    this._gl.deleteTexture(this._texture);
  }
  clearOwnProperties(this);
};


WebGlStage.TextureClass = WebGlStage.prototype.TextureClass = WebGlTexture;


module.exports = WebGlStage;

},{"../loaders/HtmlImage":56,"../loaders/HtmlModel":57,"../util/clearOwnProperties":82,"../util/dom":91,"../util/inherits":95,"../util/ispot":96,"../util/pixelRatio":101,"./Stage":75,"bowser":1}],77:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Transform a synchronous function into an asynchronous one.
function async(fn) {
  return function asynced(done) {
    var err, ret;
    try {
      ret = fn();
    } catch (e) {
      err = e;
    } finally {
      if (err) {
        done(err);
      } else {
        done(null, ret);
      }
    }
  };
}

module.exports = async;

},{}],78:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Converts a {@link RectSpec} into an equivalent {@link Rect}.
 *
 * A {@link RectSpec} is a convenient user API format, providing default values
 * and the flexibility of specifying absolute, relative or mixed dimensions.
 *
 * A {@link Rect} is a more convenient format for the rendering pipeline. It is
 * always expressed in normalized coordinates, and all its properties are
 * guaranteed to be present.
 *
 * @param {number} totalWidth The total width of the rendering area in pixels.
 * @param {number} totalHeight The total height of the rendering area in pixels.
 * @param {RectSpec} spec The input spec, defaulting to the full rendering area
 *     if null or undefined.
 * @param {Rect} result The output spec. If the argument is present, it is
 *     filled in and returned; otherwise, a fresh object is returned.
 */
function calcRect(totalWidth, totalHeight, spec, result) {

  result = result || {};

  var width;
  if (spec != null && spec.absoluteWidth != null) {
    width = spec.absoluteWidth / totalWidth;
  } else if (spec != null && spec.relativeWidth != null) {
    width = spec.relativeWidth;
  } else {
    width = 1;
  }

  var height;
  if (spec && spec.absoluteHeight != null) {
    height = spec.absoluteHeight / totalHeight;
  } else if (spec != null && spec.relativeHeight != null) {
    height = spec.relativeHeight;
  } else {
    height = 1;
  }

  var x;
  if (spec != null && spec.absoluteX != null) {
    x = spec.absoluteX / totalWidth;
  } else if (spec != null && spec.relativeX != null) {
    x = spec.relativeX;
  } else {
    x = 0;
  }

  var y;
  if (spec != null && spec.absoluteY != null) {
    y = spec.absoluteY / totalHeight;
  } else if (spec != null && spec.relativeY != null) {
    y = spec.relativeY;
  } else {
    y = 0;
  }

  result.x = x;
  result.y = y;
  result.width = width;
  result.height = height;

  return result;
}

module.exports = calcRect;

},{}],79:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var once = require('./once');

// A cancelable function is an asynchronous function (i.e., one whose last
// argument is a callback receiving an error plus zero or more return values)
// that (synchronously) returns a cancel() function. Calling cancel() should
// abort the asynchronous operation and call the callback with the arguments
// that were passed into cancel(). Calling cancel() twice, as with callbacks,
// is not guaranteed to be safe.

// Wrap a non-cancellable asynchronous function into a cancelable one.
//
// Calling cancel() on the returned function will not interrupt the execution
// of the original function; it will merely ignore its return value.
//
// Usually, instead of wrapping your function, you want to implement cancel()
// yourself in order to have some abort logic. This utility function provides a
// straighforward solution for cases in which no custom abort logic is required.
function cancelize(fn) {
  return function cancelized() {
    if (!arguments.length) {
      throw new Error('cancelized: expected at least one argument');
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var done = args[args.length - 1] = once(args[args.length - 1]);

    function cancel() {
      done.apply(null, arguments);
    }

    fn.apply(null, args);

    return cancel;
  };
}

module.exports = cancelize;

},{"./once":100}],80:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var noop = require('./noop');

// Return a function that executes its arguments (which should be cancelables)
// in sequence, so that each of them passes its return values to the next.
// Execution is aborted if one of the functions returns an error; in that case
// the last function in the sequence is called with the error.
// See util/cancelize.js for an explanation of what cancelables are.
function chain() {

  // The list of functions to chain together.
  var argList = Array.prototype.slice.call(arguments, 0);

  return function chained() {

    // List of remaining functions to be executed.
    // Make a copy of the original list so we can mutate the former while
    // preserving the latter intact for future invocations of the chain.
    var fnList = argList.slice(0);

    // Currently executing function.
    var fn = null;

    // Cancel method for the currently executing function.
    var cfn = null;

    // Arguments for the first function.
    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];

    // Callback for the chain.
    var done = arguments.length ? arguments[arguments.length - 1] : noop;

    // Execute the next function in the chain.
    // Receives the error and return values from the previous function.
    function exec() {

      // Extract error from arguments.
      var err = arguments[0];

      // Abort chain on error.
      if (err) {
        fn = cfn = null;
        done.apply(null, arguments);
        return;
      }

      // Terminate if there are no functions left in the chain.
      if (!fnList.length) {
        fn = cfn = null;
        done.apply(null, arguments);
        return;
      }

      // Advance to the next function in the chain.
      fn = fnList.shift();
      var _fn = fn;

      // Extract arguments to pass into the next function.
      var ret = Array.prototype.slice.call(arguments, 1);

      // Call next function with previous return value and call back exec.
      ret.push(exec);
      var _cfn = fn.apply(null, ret); // fn(null, ret..., exec)

      // Detect when fn has completed synchronously and do not clobber the
      // internal state in that case. You're not expected to understand this.
      if (_fn !== fn) {
        return;
      }

      // Remember the cancel method for the currently executing function.
      // Detect chaining on non-cancellable function.
      if (typeof _cfn !== 'function') {
        throw new Error('chain: chaining on non-cancellable function');
      } else {
        cfn = _cfn;
      }

    }

    // Cancel chain execution.
    function cancel() {
      if (cfn) {
        cfn.apply(null, arguments);
      }
    }

    // Start chain execution.
    // We call exec as if linking from a previous function in the chain,
    // except that the error is always null. As a consequence, chaining on an
    // empty list yields the identity function.
    args.unshift(null);
    exec.apply(null, args); // exec(null, args...)

    return cancel;

  };

}

module.exports = chain;

},{"./noop":98}],81:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

module.exports = clamp;
},{}],82:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Sets an object's own properties to undefined. This may be called by
// destructors to avoid retaining references and help detect incorrect use of
// destroyed instances.
function clearOwnProperties(obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      obj[prop] = undefined;
    }
  }
}

module.exports = clearOwnProperties;

},{}],83:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function cmp(x, y) {
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
}

module.exports = cmp;
},{}],84:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
  * Compose multiple functions
  *
  * `compose(f, g)` returns `function(x) { return f(g(x)); }`
  *
  * @memberof util
  * @param {Function[]} functions The functions to compose
  * @return {Function}
  */
function compose() {
  var fnList = arguments;
  return function composed(initialArg) {
    var ret = initialArg;
    for (var i = 0; i < fnList.length; i++) {
      var fn = fnList[i];
      ret = fn.call(null, ret);
    }
    return ret;
  };
}

module.exports = compose;
},{}],85:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Convert fov
 *
 * For example, to convert from hfov to vfov one would call 
 * `convert(hfov, width, height)`
 *
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function convert(fov, fromDimension, toDimension) {
  return 2 * Math.atan(toDimension * Math.tan(fov / 2) / fromDimension);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function htov(fov, width, height) {
  return convert(fov, width, height);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function htod(fov, width, height) {
  return convert(fov, width, Math.sqrt(width * width + height * height));
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function vtoh(fov, width, height) {
  return convert(fov, height, width);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function vtod(fov, width, height) {
  return convert(fov, height, Math.sqrt(width * width + height * height));
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function dtoh(fov, width, height) {
  return convert(fov, Math.sqrt(width * width + height * height), width);
}

/**
 * @param {number} fov
 * @param {number} fromDimension
 * @param {number} toDimension
 * @return {number}
 * @memberof util.convertFov
 */
function dtov(fov, width, height) {
  return convert(fov, Math.sqrt(width * width + height * height), height);
}

/**
 * @namespace util.convertFov
 */
module.exports = {
  convert: convert,
  htov: htov,
  htod: htod,
  vtoh: vtoh,
  vtod: vtod,
  dtoh: dtoh,
  dtov: dtov
};

},{}],86:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Convert a number to a string in decimal notation.
function decimal(x) {
  // Double-precision floats have 15 significant decimal digits.
  return x.toPrecision(15);
}

module.exports = decimal;
},{}],87:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function defaults(obj, defaultsObj) {
  for (var key in defaultsObj) {
    if (!(key in obj)) {
      obj[key] = defaultsObj[key];
    }
  }
  return obj;
}

module.exports = defaults;
},{}],88:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function defer(fn, args) {
  function deferred() {
    if (args && args.length > 0) {
      fn.apply(null, args);
    } else {
      fn();
    }
  }
  setTimeout(deferred, 0);
}

module.exports = defer;
},{}],89:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @memberof util
 * @param {number} deg
 * @return {number}
 */
function degToRad(deg) {
  return deg * Math.PI / 180;
}

module.exports = degToRad;
},{}],90:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Perform a cancelable delay.
// See util/cancelize.js for an explanation of what cancelables are.
function delay(ms, done) {

  // Work around IE8 bug whereby a setTimeout callback may still be called
  // after the corresponding clearTimeout is invoked.
  var timer = null;

  function finish() {
    if (timer != null) {
      timer = null;
      done(null);
    }
  }

  function cancel() {
    if (timer != null) {
      clearTimeout(timer);
      timer = null;
      done.apply(null, arguments);
    }
  }

  timer = setTimeout(finish, ms);

  return cancel;

}

module.exports = delay;

},{}],91:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';


function prefixProperty(property) {

  var style = document.documentElement.style;
  var prefixList = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];

  for (var i = 0; i < prefixList.length; i++) {
    var prefix = prefixList[i];
    var capitalizedProperty = property[0].toUpperCase() + property.slice(1);
    var prefixedProperty = prefix + capitalizedProperty;

    if (prefixedProperty in style) {
      return prefixedProperty;
    }
  }

  return property;

}


function getWithVendorPrefix(property) {
  var prefixedProperty = prefixProperty(property);
  return function getPropertyWithVendorPrefix(element) {
    return element.style[prefixedProperty];
  };

}


function setWithVendorPrefix(property) {
  var prefixedProperty = prefixProperty(property);
  return function setPropertyWithVendorPrefix(element, val) {
    return (element.style[prefixedProperty] = val);
  };
}


var setTransform = setWithVendorPrefix('transform');
var setTransformOrigin = setWithVendorPrefix('transformOrigin');


function setNullTransform(element) {
  setTransform(element, 'translateZ(0)');
}


function setNullTransformOrigin(element) {
  setTransformOrigin(element, '0 0 0');
}


function setAbsolute(element) {
  element.style.position = 'absolute';
}


function setPixelPosition(element, x, y) {
  element.style.left = x + 'px';
  element.style.top = y + 'px';
}


function setPixelSize(element, width, height) {
  element.style.width = width + 'px';
  element.style.height = height + 'px';
}


function setNullSize(element) {
  element.style.width = element.style.height = 0;
}


function setFullSize(element) {
  element.style.width = element.style.height = '100%';
}


function setOverflowHidden(element) {
  element.style.overflow = 'hidden';
}


function setOverflowVisible(element) {
  element.style.overflow = 'visible';
}


function setNoPointerEvents(element) {
  element.style.pointerEvents = 'none';
}


module.exports = {
  prefixProperty: prefixProperty,
  getWithVendorPrefix: getWithVendorPrefix,
  setWithVendorPrefix: setWithVendorPrefix,
  setTransform: setTransform,
  setTransformOrigin: setTransformOrigin,
  setNullTransform: setNullTransform,
  setNullTransformOrigin: setNullTransformOrigin,
  setAbsolute: setAbsolute,
  setPixelPosition: setPixelPosition,
  setPixelSize: setPixelSize,
  setNullSize: setNullSize,
  setFullSize: setFullSize,
  setOverflowHidden: setOverflowHidden,
  setOverflowVisible: setOverflowVisible,
  setNoPointerEvents: setNoPointerEvents
};

},{}],92:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function extend(obj, sourceObj) {
  for (var key in sourceObj) {
    obj[key] = sourceObj[key];
  }
  return obj;
}

module.exports = extend;
},{}],93:[function(require,module,exports){
(function (global){(function (){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// The global object.
var globalObject = (function() {
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  return null;
})();

module.exports = globalObject;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],94:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Jenkins one-at-a-time hash
// http://www.burtleburtle.net/bob/hash/doobs.html
// Input: an array of integers
// Output: an integer

function hash() {
  var h = 0;
  for (var i = 0; i < arguments.length; i++) {
    var k = arguments[i];
    h += k;
    h += k << 10;
    h ^= k >> 6;
  }
  h += h << 3;
  h ^= h >> 11;
  h += h << 15;
  return h >= 0 ? h : -h;
}

module.exports = hash;
},{}],95:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Make ctor a subclass of superCtor.
// Do not depend on ES5 Object.create semantics because of older browsers.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function() {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

module.exports = inherits;
},{}],96:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

// Returns whether n is a power of two.
function ispot(n) {
  return (n & (n - 1)) == 0;
}

module.exports = ispot;
},{}],97:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Modulo operation
 *
 * @memberof util
 * @param {Number} dividend
 * @param {Number} divisor
 * @returns {Number} Value in range `[0,divisor[`
 */
function mod(a, b) {
  return (+a % (b = +b) + b) % b;
}

module.exports = mod;
},{}],98:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function noop() {}

module.exports = noop;
},{}],99:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function getNow() {
  if (typeof performance !== 'undefined' && performance.now) {
    return function performanceNow() {
      return performance.now();
    };
  }
  return function dateNow() {
    return Date.now();
  };
}

module.exports = getNow();

},{}],100:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function once(fn) {
  var called = false;
  var value;
  return function onced() {
    if (!called) {
      called = true;
      value = fn.apply(null, arguments);
    }
    return value;
  };
}

module.exports = once;
},{}],101:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var defaultPixelRatio = 1;

function pixelRatio() {
  if (typeof window !== 'undefined') {
    if (window.devicePixelRatio) {
      return window.devicePixelRatio;
    }
    else {
      var screen = window.screen;
      if (screen && screen.deviceXDPI && screen.logicalXDPI) {
        return screen.deviceXDPI / screen.logicalXDPI;
      } else if (screen && screen.systemXDPI && screen.logicalXDPI) {
        return screen.systemXDPI / screen.logicalXDPI;
      }
    }
  }
  return defaultPixelRatio;
}

module.exports = pixelRatio;

},{}],102:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var setTransform = require('./dom').setTransform;
var decimal = require('./decimal');

function positionAbsolutely(element, x, y, extraTransforms) {
  extraTransforms = extraTransforms || '';
  // A translateZ(0) transform improves performance on Chrome by creating a
  // new layer for the element, which prevents unnecessary repaints.
  var transform = 'translateX(' + decimal(x) + 'px) translateY(' + decimal(y) + 'px) translateZ(0) ' + extraTransforms;
  setTransform(element, transform);
}

module.exports = positionAbsolutely;

},{"./decimal":86,"./dom":91}],103:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @memberof util
 * @param {number} rad
 * @return {number}
 */
function radToDeg(rad) {
  return rad * 180 / Math.PI;
}

module.exports = radToDeg;
},{}],104:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function real(x) {
  return typeof x === 'number' && isFinite(x);
}

module.exports = real;
},{}],105:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var noop = require('./noop');

// Return a cancelable function that executes fn in a loop until it returns
// successfully.
function retry(fn) {

  return function retried() {

    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];
    var done = arguments.length ? arguments[arguments.length - 1] : noop;

    var cfn = null;
    var canceled = false;

    function exec() {
      var err = arguments[0];
      if (!err || canceled) {
        done.apply(null, arguments);
      } else {
        cfn = fn.apply(null, args);
      }
    }

    args.push(exec);
    exec(true);

    return function cancel() {
      canceled = true;
      cfn.apply(null, arguments);
    };

  };

}

module.exports = retry;

},{"./noop":98}],106:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var now = require('./now');

function tween(duration, update, done) {
  var cancelled = false;

  var startTime = now();

  function runUpdate() {
    if(cancelled) { return; }
    var tweenVal = (now() - startTime)/duration;
    if(tweenVal < 1) {
      update(tweenVal);
      requestAnimationFrame(runUpdate);
    }
    else {
      update(1);
      done();
    }
  }

  update(0);
  requestAnimationFrame(runUpdate);

  return function cancel() {
    cancelled = true;
    done.apply(null, arguments);
  }
}

module.exports = tween;
},{"./now":99}],107:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

function type(x) {
  var typ = typeof x;
  if (typ === 'object') {
    if (x === null) {
      return 'null';
    }
    if (Object.prototype.toString.call(x) === '[object Array]') {
      return 'array';
    }
    if (Object.prototype.toString.call(x) === '[object RegExp]') {
      return 'regexp';
    }
  }
  return typ;
}

module.exports = type;

},{}],108:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var mat4 = require('gl-matrix').mat4;
var vec4 = require('gl-matrix').vec4;
var pixelRatio = require('../util/pixelRatio');
var real = require('../util/real');
var clamp = require('../util/clamp');
var clearOwnProperties = require('../util/clearOwnProperties');

// Default viewport dimensions.
// Start with zero to ensure that those values are handled correctly.
var defaultWidth = 0;
var defaultHeight = 0;

// Default view parameters.
var defaultX = 0.5;
var defaultY = 0.5;
var defaultZoom = 1;

// Constant values used to simplify the frustum culling logic.
// planeAxes[i] indicates the coordinate value that defines a frustum plane.
// planeCmp[i] indicates how point and plane coordinates should be compared
// to determine whether the point is on the outer side of the plane.
var planeAxes = [
  1, // top
  0, // right
  1, // bottom
  0  // left
];
var planeCmp = [
  -1, // top
  -1, // right
   1, // bottom
   1  // left
];

// A zoom of exactly 0 breaks some computations, so we force a minimum positive
// value. We use 6 decimal places for the epsilon value to avoid broken
// rendering due to loss of precision in floating point computations.
var zoomLimitEpsilon = 0.000001;


/**
 * @interface FlatViewParams
 *
 * A camera configuration for a {@link FlatView}.
 *
 * @property {number} x The horizontal coordinate of the image point displayed
 *     at the viewport center, in the [0, 1] range.
 *     When `x === 0.5`, the image is centered horizontally.
 *     When `x === 0`, the left edge of the image is at the viewport center.
 *     When `x === 1`, the right edge of the image is at the viewport center.
 * @property {number} y The vertical coordinate of the image point displayed at
 *     the viewport center, in the [0, 1] range.
 *     When `y === 0.5`, the image is centered vertically.
 *     When `y === 0`, the top edge of the image is at the viewport center.
 *     When `y === 1`, the bottom edge of the image is at the viewport center.
 * @property {number} zoom The horizontal zoom, in the [0, ) range.
 *     When `zoom === 1`, the viewport is as wide as the image.
 *     When `zoom < 1`, the image is zoomed in.
 *     When `zoom > 1`, the image is zoomed out.
 * @property {number} mediaAspectRatio The image aspect ratio.
 *     When `mediaAspectRatio === 1`, the image width equals its height.
 *     When `mediaAspectRatio < 1`, the image width is less than its height.
 *     When `mediaAspectRatio > 1`, the image height is less than its width.
 */


/**
 * @interface FlatViewCoords
 *
 * The position of a point in a flat image.
 *
 * @property {number} x The horizontal coordinate, in the [0, 1] range.
 * @property {number} y The vertical coordinate, in the [0, 1] range.
 */


/**
 * @typedef {function} FlatViewLimiter
 *
 * View limiter for a {@link FlatView}.
 *
 * A view limiter is a function that receives a {@link FlatViewParams} object,
 * optionally modifies it in place, and returns it. It can be used to enforce
 * constraints on the view parameters.
 *
 * See {@link FlatView.limit} for commonly used limiters. They may be composed
 * together or with user-defined limiters with {@link util.compose}.
 *
 * @param {FlatViewParams} params
 * @return {FlatViewParams}
 */


/**
 * @class FlatView
 * @implements View
 * @classdesc
 *
 * A {@link View} implementing an orthogonal projection for flat images.
 *
 * @param {FlatViewParams} params The initial view parameters. The
 *     `mediaAspectRatio` parameter must always be set. The other parameters
 *     default to `{x: 0.5, y: 0.5, z: 1 }` if unspecified.
 * @param {FlatViewLimiter=} limiter The view limiter. If unspecified, no view
 *     limiting is applied. See {@link FlatView.limit} for commonly used
 *     limiters.
 */
function FlatView(params, limiter) {
  // Require an aspect ratio to be specified.
  if (!(params && params.mediaAspectRatio != null)) {
    throw new Error('mediaAspectRatio must be defined');
  }

  // The initial values for the view parameters.
  this._x = params && params.x != null ? params.x : defaultX;
  this._y = params && params.y != null ? params.y : defaultY;
  this._zoom = params && params.zoom != null ? params.zoom : defaultZoom;
  this._mediaAspectRatio = params.mediaAspectRatio;
  this._width = params && params.width != null ?
    params.width : defaultWidth;
  this._height = params && params.height != null ?
    params.height : defaultHeight;

  // The initial value for the view limiter.
  this._limiter = limiter || null;

  // The last calculated projection matrix and its inverse.
  this._projMatrix = mat4.create();
  this._invProjMatrix = mat4.create();

  // The last calculated view frustum.
  this._frustum = [
    0, // top
    0, // right
    0, // bottom
    0  // left
  ];

  // Whether the projection matrices and view frustum need to be updated.
  this._projectionChanged = true;

  // Temporary variables used for calculations.
  this._params = {};
  this._vec = vec4.create();

  // Force view limiting on initial parameters.
  this._update();
}

eventEmitter(FlatView);


/**
 * Destructor.
 */
FlatView.prototype.destroy = function() {
  clearOwnProperties(this);
};


/**
 * Get the x parameter.
 * @return {number}
 */
FlatView.prototype.x = function() {
  return this._x;
};


/**
 * Get the y parameter.
 * @return {number}
 */
FlatView.prototype.y = function() {
  return this._y;
};


/**
 * Get the zoom value.
 * @return {number}
 */
FlatView.prototype.zoom = function() {
  return this._zoom;
};


/**
 * Get the media aspect ratio.
 * @return {number}
 */
FlatView.prototype.mediaAspectRatio = function() {
  return this._mediaAspectRatio;
};


/**
 * Get the viewport width.
 * @return {number}
 */
FlatView.prototype.width = function() {
  return this._width;
};


/**
 * Get the viewport height.
 * @return {number}
 */
FlatView.prototype.height = function() {
  return this._height;
};


/**
 * Get the viewport dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {Size=} size
 * @return {Size}
 */
FlatView.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Get the view parameters. If an argument is supplied, it is filled in with the
 * result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {FlatViewParams=} params
 * @return {FlatViewParams}
 */
FlatView.prototype.parameters = function(params) {
  params = params || {};
  params.x = this._x;
  params.y = this._y;
  params.zoom = this._zoom;
  params.mediaAspectRatio = this._mediaAspectRatio;
  return params;
};


/**
 * Get the view limiter, or null if unset.
 * @return {?FlatViewLimiter}
 */
FlatView.prototype.limiter = function() {
  return this._limiter;
};


/**
 * Set the x parameter.
 * @param {number} x
 */
FlatView.prototype.setX = function(x) {
  this._resetParams();
  this._params.x = x;
  this._update(this._params);
};


/**
 * Set the y parameter.
 * @param {number} y
 */
FlatView.prototype.setY = function(y) {
  this._resetParams();
  this._params.y = y;
  this._update(this._params);
};


/**
 * Set the zoom value.
 * @param {number} zoom
 */
FlatView.prototype.setZoom = function(zoom) {
  this._resetParams();
  this._params.zoom = zoom;
  this._update(this._params);
};


/**
 * Add xOffset to the x parameter.
 * @param {number} xOffset
 */
FlatView.prototype.offsetX = function(xOffset) {
  this.setX(this._x + xOffset);
};


/**
 * Add yOffset to the y parameter.
 * @param {number} yOffset
 */
FlatView.prototype.offsetY = function(yOffset)
{
  this.setY(this._y + yOffset);
};


/**
 * Add zoomOffset to the zoom value.
 * @param {number} zoomOffset
 */
FlatView.prototype.offsetZoom = function(zoomOffset) {
  this.setZoom(this._zoom + zoomOffset);
};


/**
 * Set the media aspect ratio.
 * @param {number} mediaAspectRatio
 */
FlatView.prototype.setMediaAspectRatio = function(mediaAspectRatio) {
  this._resetParams();
  this._params.mediaAspectRatio = mediaAspectRatio;
  this._update(this._params);
};


/**
 * Set the viewport dimensions.
 * @param {Size} size
 */
FlatView.prototype.setSize = function(size) {
  this._resetParams();
  this._params.width = size.width;
  this._params.height = size.height;
  this._update(this._params);
};


/**
 * Set the view parameters. Unspecified parameters are left unchanged.
 * @param {FlatViewParameters} params
 */
FlatView.prototype.setParameters = function(params) {
  this._resetParams();
  this._params.x = params.x;
  this._params.y = params.y;
  this._params.zoom = params.zoom;
  this._params.mediaAspectRatio = params.mediaAspectRatio;
  this._update(this._params);
};


/**
 * Set the view limiter.
 * @param {?FlatViewLimiter} limiter The new limiter, or null to unset.
 */
FlatView.prototype.setLimiter = function(limiter) {
  this._limiter = limiter || null;
  this._update();
};


FlatView.prototype._resetParams = function() {
  var params = this._params;
  params.x = null;
  params.y = null;
  params.zoom = null;
  params.mediaAspectRatio = null;
  params.width = null;
  params.height = null;
};


FlatView.prototype._update = function(params) {

  // Avoid object allocation when no parameters are supplied.
  if (params == null) {
    this._resetParams();
    params = this._params;
  }

  // Save old parameters for later comparison.
  var oldX = this._x;
  var oldY = this._y;
  var oldZoom = this._zoom;
  var oldMediaAspectRatio = this._mediaAspectRatio;
  var oldWidth = this._width;
  var oldHeight = this._height;

  // Fill in object with the new set of parameters to pass into the limiter.
  params.x = params.x != null ? params.x : oldX;
  params.y = params.y != null ? params.y : oldY;
  params.zoom = params.zoom != null ? params.zoom : oldZoom;
  params.mediaAspectRatio = params.mediaAspectRatio != null ?
    params.mediaAspectRatio : oldMediaAspectRatio;
  params.width = params.width != null ? params.width : oldWidth;
  params.height = params.height != null ? params.height : oldHeight;

  // Apply view limiting when defined.
  if (this._limiter) {
    params = this._limiter(params);
    if (!params) {
      throw new Error('Bad view limiter');
    }
  }

  // Grab the limited parameters.
  var newX = params.x;
  var newY = params.y;
  var newZoom = params.zoom;
  var newMediaAspectRatio = params.mediaAspectRatio;
  var newWidth = params.width;
  var newHeight = params.height;

  // Consistency check.
  if (!real(newX) || !real(newY) || !real(newZoom) ||
      !real(newMediaAspectRatio) || !real(newWidth) || !real(newHeight)) {
    throw new Error('Bad view - suspect a broken limiter');
  }

  // Constrain zoom.
  newZoom = clamp(newZoom, zoomLimitEpsilon, Infinity);

  // Update parameters.
  this._x = newX;
  this._y = newY;
  this._zoom = newZoom;
  this._mediaAspectRatio = newMediaAspectRatio;
  this._width = newWidth;
  this._height = newHeight;

  // Check whether the parameters changed and emit the corresponding events.
  if (newX !== oldX || newY !== oldY || newZoom !== oldZoom ||
      newMediaAspectRatio !== oldMediaAspectRatio ||
      newWidth !== oldWidth || newHeight !== oldHeight) {
    this._projectionChanged = true;
    this.emit('change');
  }
  if (newWidth !== oldWidth || newHeight !== oldHeight) {
    this.emit('resize');
  }

};


FlatView.prototype._zoomX = function() {
  return this._zoom;
};


FlatView.prototype._zoomY = function() {
  var mediaAspectRatio = this._mediaAspectRatio;
  var aspect = this._width / this._height;
  var zoomX = this._zoom;
  var zoomY = zoomX * mediaAspectRatio / aspect;
  if (isNaN(zoomY)) {
    zoomY = zoomX;
  }
  return zoomY;
};


FlatView.prototype.updateWithControlParameters = function(parameters) {
  var scale = this.zoom();
  var zoomX = this._zoomX();
  var zoomY = this._zoomY();

  // TODO: should the scale be the same for both axes?
  this.offsetX(parameters.axisScaledX * zoomX + parameters.x * scale);
  this.offsetY(parameters.axisScaledY * zoomY + parameters.y * scale);
  this.offsetZoom(parameters.zoom * scale);
};


FlatView.prototype._updateProjection = function() {
  var projMatrix = this._projMatrix;
  var invProjMatrix = this._invProjMatrix;
  var frustum = this._frustum;

  // Recalculate projection matrix when required.
  if (this._projectionChanged) {
    var x = this._x;
    var y = this._y;
    var zoomX = this._zoomX();
    var zoomY = this._zoomY();

    // Recalculate view frustum.
    var top     = frustum[0] = (0.5 - y) + 0.5 * zoomY;
    var right   = frustum[1] = (x - 0.5) + 0.5 * zoomX;
    var bottom  = frustum[2] = (0.5 - y) - 0.5 * zoomY;
    var left    = frustum[3] = (x - 0.5) - 0.5 * zoomX;

    // Recalculate projection matrix and its inverse.
    mat4.ortho(projMatrix, left, right, bottom, top, -1, 1);
    mat4.invert(invProjMatrix, projMatrix);

    this._projectionChanged = false;
  }
};


/**
 * Returns the projection matrix for the current view.
 * @returns {mat4}
 */
FlatView.prototype.projection = function() {
  this._updateProjection();
  return this._projMatrix;
};


/**
 * Returns the inverse projection matrix for the current view.
 * @returns {mat4}
 */
FlatView.prototype.inverseProjection = function() {
  this._updateProjection();
  return this._invProjMatrix;
};


/**
 * Return whether the view frustum intersects the given rectangle.
 *
 * This function may return false positives, but never false negatives.
 * It is used for frustum culling, i.e., excluding invisible tiles from the
 * rendering process.
 *
 * @param {vec3[]} rectangle The vertices of the rectangle.
 */
FlatView.prototype.intersects = function(rectangle) {
  this._updateProjection();

  var frustum = this._frustum;

  // Check whether the rectangle is on the outer side of any of the frustum
  // planes. This is a sufficient condition, though not necessary, for the
  // rectangle to be completely outside the fruouter
  for (var i = 0; i < frustum.length; i++) {
    var limit = frustum[i];
    var axis = planeAxes[i];
    var cmp = planeCmp[i];
    var inside = false;
    for (var j = 0; j < rectangle.length; j++) {
      var vertex = rectangle[j];
      if (cmp < 0 && vertex[axis] < limit || cmp > 0 && vertex[axis] > limit) {
        inside = true;
        break;
      }
    }
    if (!inside) {
      return false;
    }
  }
  return true;
};


/**
 * Select the level that should be used to render the view.
 * @param {Level[]} levelList the list of levels from which to select.
 * @return {Level} the selected level.
 */
FlatView.prototype.selectLevel = function(levels) {

  // Multiply the viewport width by the device pixel ratio to get the required
  // horizontal resolution in pixels.
  //
  // Calculate the fraction of the image that would be visible at the current
  // zoom value. Then, for each level, multiply by the level width to get the
  // width in pixels of the portion that would be visible.
  //
  // Search for the smallest level that satifies the the required width,
  // falling back on the largest level if none do.

  var requiredPixels = pixelRatio() * this.width();
  var zoomFactor = this._zoom;

  for (var i = 0; i < levels.length; i++) {
    var level = levels[i];
    if (zoomFactor * level.width() >= requiredPixels) {
      return level;
    }
  }

  return levels[levels.length - 1];

};


/**
 * Convert view coordinates into screen coordinates. If a result argument is
 * provided, it is filled in and returned. Otherwise, a fresh object is filled
 * in and returned.
 *
 * @param {FlatViewCoords} coords The view coordinates.
 * @param {Coords=} result The result argument for the screen coordinates.
 * @return {Coords}
 */
FlatView.prototype.coordinatesToScreen = function(coords, result) {
  var ray = this._vec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Undefined on a null viewport.
  if (width <= 0 || height <= 0) {
    result.x = null;
    result.y = null;
    return null;
  }

  // Extract coordinates from argument, filling in default values.
  var x = coords && coords.x != null ? coords.x : defaultX;
  var y = coords && coords.y != null ? coords.y : defaultY;

  // Project view ray onto clip space.
  vec4.set(ray, x - 0.5, 0.5 - y, -1, 1);
  vec4.transformMat4(ray, ray, this.projection());

  // Calculate perspective divide.
  for (var i = 0; i < 3; i++) {
    ray[i] /= ray[3];
  }

  // Convert to viewport coordinates and return.
  result.x = width * (ray[0] + 1) / 2;
  result.y = height * (1 - ray[1]) / 2;

  return result;
};


/**
 * Convert screen coordinates into view coordinates. If a result argument is
 * provided, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {Coords} coords The screen coordinates.
 * @param {FlatViewCoords=} result The result argument for the view coordinates.
 * @return {FlatViewCoords}
 */
FlatView.prototype.screenToCoordinates = function(coords, result) {
  var ray = this._vec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Convert viewport coordinates to clip space.
  var vecx = 2 * coords.x / width - 1;
  var vecy = 1 - 2 * coords.y / height;
  vec4.set(ray, vecx, vecy, 1, 1);

  // Project back to world space.
  vec4.transformMat4(ray, ray, this.inverseProjection());

  // Convert to flat coordinates.
  result.x = 0.5 + ray[0];
  result.y = 0.5 - ray[1];

  return result;
};


/**
 * Factory functions for view limiters. See {@link FlatViewLimiter}.
 * @namespace
 */
FlatView.limit = {

  /**
   * Returns a view limiter that constrains the x parameter.
   * @param {number} min The minimum x value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  x: function(min, max) {
    return function limitX(params) {
      params.x = clamp(params.x, min, max);
      return params;
    };
  },

  /**
   * Return a view limiter that constrains the y parameter.
   * @param {number} min The minimum y value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  y: function(min, max) {
    return function limitY(params) {
      params.y = clamp(params.y, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter than constrains the zoom parameter.
   * @param {number} min The minimum zoom value.
   * @param {number} max The maximum zoom value.
   * @return {FlatViewLimiter}
   */
  zoom: function(min, max) {
    return function limitZoom(params) {
      params.zoom = clamp(params.zoom, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that prevents zooming in beyond the given
   * resolution.
   * @param {number} size The image width in pixels.
   * @return {FlatViewLimiter}
   */
  resolution: function(size) {
    return function limitResolution(params) {
      if (params.width <= 0 || params.height <= 0) {
        return params;
      }
      var width = params.width;
      var minZoom = pixelRatio() * width / size;
      params.zoom = clamp(params.zoom, minZoom, Infinity);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the values of the x parameter that
   * are inside the viewport.
   * @param {number} min The minimum x value.
   * @param {number} max The maximum x value.
   * @return {FlatViewLimiter}
   */
  visibleX: function(min, max) {
    return function limitVisibleX(params) {
      // Calculate the zoom value that makes the specified range fully visible.
      var maxZoom = max - min;

      // Clamp zoom to the maximum value.
      if (params.zoom > maxZoom) {
        params.zoom = maxZoom;
      }

      // Bound X such that the image is visible up to the range edges.
      var minX = min + 0.5 * params.zoom;
      var maxX = max - 0.5 * params.zoom;
      params.x = clamp(params.x, minX, maxX);

      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the values of the y parameter that
   * are inside the viewport.
   * @param {number} min The minimum y value.
   * @param {number} max The maximum y value.
   * @return {FlatViewLimiter}
   */
  visibleY: function(min, max) {
    return function limitVisibleY(params) {

      // Do nothing for a null viewport.
      if (params.width <= 0 || params.height <= 0) {
        return params;
      }

      // Calculate the X to Y conversion factor.
      var viewportAspectRatio = params.width / params.height;
      var factor = viewportAspectRatio / params.mediaAspectRatio;

      // Calculate the zoom value that makes the specified range fully visible.
      var maxZoom = (max - min) * factor;

      // Clamp zoom to the maximum value.
      if (params.zoom > maxZoom) {
        params.zoom = maxZoom;
      }

      // Bound Y such that the image is visible up to the range edges.
      var minY = min + 0.5 * params.zoom / factor;
      var maxY = max - 0.5 * params.zoom / factor;
      params.y = clamp(params.y, minY, maxY);

      return params;
    };
  },


  /**
   * Returns a view limiter that constrains the zoom parameter such that
   * zooming out is prevented beyond the point at which the image is fully
   * visible. Unless the image and the viewport have the same aspect ratio,
   * this will cause bands to appear around the image.
   * @return {FlatViewLimiter}
   */
  letterbox: function() {
    return function limitLetterbox(params) {
      if(params.width <= 0 || params.height <= 0) {
        return params;
      }
      var viewportAspectRatio = params.width / params.height;

      var fullWidthZoom = 1.0;
      var fullHeightZoom = viewportAspectRatio / params.mediaAspectRatio;

      // If the image is wider than the viewport, limit the horizontal zoom to
      // the image width.
      if (params.mediaAspectRatio >= viewportAspectRatio) {
        params.zoom = Math.min(params.zoom, fullWidthZoom);
      }

      // If the image is narrower than the viewport, limit the vertical zoom to
      // the image height.
      if (params.mediaAspectRatio <= viewportAspectRatio) {
        params.zoom = Math.min(params.zoom, fullHeightZoom);
      }

      // If the full image width is visible, limit x to the central point.
      // Else, bound x such that image is visible up to the horizontal edges.
      var minX, maxX;
      if (params.zoom > fullWidthZoom) {
        minX = maxX = 0.5;
      } else {
        minX = 0.0 + 0.5 * params.zoom / fullWidthZoom;
        maxX = 1.0 - 0.5 * params.zoom / fullWidthZoom;
      }

      // If the full image height is visible, limit y to the central point.
      // Else, bound y such that image is visible up to the vertical edges.
      var minY, maxY;
      if (params.zoom > fullHeightZoom) {
        minY = maxY = 0.5;
      } else {
        minY = 0.0 + 0.5 * params.zoom / fullHeightZoom;
        maxY = 1.0 - 0.5 * params.zoom / fullHeightZoom;
      }

      // Clamp x and y into the calculated bounds.
      params.x = clamp(params.x, minX, maxX);
      params.y = clamp(params.y, minY, maxY);

      return params;
    };
  }

};


FlatView.type = FlatView.prototype.type = 'flat';


module.exports = FlatView;

},{"../util/clamp":81,"../util/clearOwnProperties":82,"../util/pixelRatio":101,"../util/real":104,"gl-matrix":3,"minimal-event-emitter":14}],109:[function(require,module,exports){
/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var eventEmitter = require('minimal-event-emitter');
var mat4 = require('gl-matrix').mat4;
var vec4 = require('gl-matrix').vec4;
var vec3 = require('gl-matrix').vec3;
var pixelRatio = require('../util/pixelRatio');
var convertFov = require('../util/convertFov');
var mod = require('../util/mod');
var real = require('../util/real');
var clamp = require('../util/clamp');
var decimal = require('../util/decimal');
var compose = require('../util/compose');
var clearOwnProperties = require('../util/clearOwnProperties');

// Default viewport dimensions.
// Start with zero to ensure that those values are handled correctly.
var defaultWidth = 0;
var defaultHeight = 0;

// Default view parameters.
var defaultYaw = 0;
var defaultPitch = 0;
var defaultRoll = 0;
var defaultFov = Math.PI/4;
var defaultProjectionCenterX = 0;
var defaultProjectionCenterY = 0;
var defaultTx = 0;
var defaultTy = 0;
var defaultTz = 0;
var defaultOx = 0;
var defaultOy = 0;
var defaultOz = 0;

// A fov of exactly 0 or  breaks some computations, so we constrain it to the
// [fovLimitEpsilon,  - fovLimitEpsilon] interval. We use 6 decimal places for
// the epsilon value to avoid broken rendering due to loss of precision in
// floating point computations.
var fovLimitEpsilon = 0.000001;


/**
 * @interface RectilinearViewParams
 *
 * A camera configuration for a {@link RectilinearView}.
 *
 * @property {number} yaw The yaw angle, in the [-, ] range.
 *     When `yaw < 0`, the view rotates to the left.
 *     When `yaw > 0`, the view rotates to the right.
 *
 * @property {number} pitch The pitch angle, in the [-, ] range.
 *     When `pitch < 0`, the view rotates downwards.
 *     When `pitch > 0`, the view rotates upwards.
 *
 * @property {number} roll The roll angle, in the [-, ] range.
 *     When `roll < 0`, the view rotates clockwise.
 *     When `roll > 0`, the view rotates counter-clockwise.
 *
 * @property {fov} fov The vertical field of view, in the [0, ] range.
 */


/**
 * @interface RectilinearViewCoords
 *
 * The position of a point in a 360 image.
 *
 * @property {number} yaw The yaw angle, in the [-, ] range.
 * @property {number} pitch The pitch angle, in the [-, ] range.
 */


/**
 * @typedef {function} RectilinearViewLimiter
 *
 * View limiter for a {@link RectilinearView}.
 *
 * A view limiter is a function that receives a {@link RectilinearViewParams}
 * object, optionally modifies it in place, and returns it. It can be used to
 * enforce constraints on the view parameters.
 *
 * See {@link RectilinearView.limit} for commonly used limiters. They may be
 * composed together or with user-defined limiters with {@link util.compose}.
 *
 * @param {RectilinearViewParams} params
 * @return {RectilinearViewParams}
 */

/**
 * @class RectilinearView
 * @implements View
 * @classdesc
 *
 * A {@link View} implementing a rectilinear projection for 360 images.
 *
 * @param {RectilinearViewParams=} params The initial view parameters. If
 *     unspecified, defaults to `{yaw: 0, pitch: 0, roll: 0, fov: Math.PI/4 }`.
 * @param {RectilinearViewLimiter=} limiter The view limiter. If unspecified,
 *     no view limiting is applied. See {@link RectilinearView.limit} for
 *     commonly used limiters.
 */
function RectilinearView(params, limiter) {
  // The initial values for the view parameters.
  this._yaw = params && params.yaw != null ? params.yaw : defaultYaw;
  this._pitch = params && params.pitch != null ? params.pitch : defaultPitch;
  this._roll = params && params.roll != null ? params.roll : defaultRoll;
  this._fov = params && params.fov != null ? params.fov : defaultFov;
  this._width = params && params.width != null ?
    params.width : defaultWidth;
  this._height = params && params.height != null ?
    params.height : defaultHeight;
  this._projectionCenterX = params && params.projectionCenterX != null ?
    params.projectionCenterX : defaultProjectionCenterX;
  this._projectionCenterY = params && params.projectionCenterY != null ?
    params.projectionCenterY : defaultProjectionCenterY;

  // A 3D translation of the viewpoint.
  this._tx = params && params.tx != null ? params.tx : defaultTx;
  this._ty = params && params.ty != null ? params.ty : defaultTy;
  this._tz = params && params.tz != null ? params.tz : defaultTz;

  // An additional 3D translation offset of the viewpoint. 
  // But the viewing rotation will be still from the non-offset point.
  this._ox = params && params.ox != null ? params.ox : defaultOx;
  this._oy = params && params.oy != null ? params.oy : defaultOy;
  this._oz = params && params.oz != null ? params.oz : defaultOz;

  // Invert control.
  this._invertControl = params && params.invertControl != null ? params.invertControl : false;

  // The initial value for the view limiter.
  this._limiter = limiter || null;

  // The last calculated projection matrix and its inverse.
  this._projMatrix = mat4.create();
  this._invProjMatrix = mat4.create();

  // The last calculated view matrix and its inverse.
  this._viewMatrix = mat4.create();
  this._invViewMatrix = mat4.create();

  // The last calculated view frustum.
  this._frustum = [
    vec4.create(), // left
    vec4.create(), // right
    vec4.create(), // bottom
    vec4.create(), // top
    vec4.create()  // camera
  ];

  // Whether the projection matrices and the view frustum need to be updated.
  this._matrixChanged = true;

  // Temporary variables used for calculations.
  this._params = {};
  this._fovs = {};
  this._tmpVec = vec4.create();

  // Force view limiting on initial parameters.
  this._update();
}

eventEmitter(RectilinearView);


/**
 * Destructor.
 */
RectilinearView.prototype.destroy = function() {
  clearOwnProperties(this);
};


/**
 * Get the yaw angle.
 * @return {number}
 */
RectilinearView.prototype.yaw = function() {
  return this._yaw;
};


/**
 * Get the pitch angle.
 * @return {number}
 */
RectilinearView.prototype.pitch = function() {
  return this._pitch;
};


/**
 * Get the roll angle.
 * @return {number}
 */
RectilinearView.prototype.roll = function() {
  return this._roll;
};


RectilinearView.prototype.projectionCenterX = function() {
  return this._projectionCenterX;
};


RectilinearView.prototype.projectionCenterY = function() {
  return this._projectionCenterY;
};

/**
 * Get the fov value.
 * @return {number}
 */
RectilinearView.prototype.fov = function() {
  return this._fov;
};


/**
 * Get the viewport width.
 * @return {number}
 */
RectilinearView.prototype.width = function() {
  return this._width;
};


/**
 * Get the viewport height.
 * @return {number}
 */
RectilinearView.prototype.height = function() {
  return this._height;
};

/**
 * Get the viewpoint's tx.
 * @return {number}
 */
RectilinearView.prototype.tx = function() {
  return this._tx;
};

/**
 * Get the viewpoint's ty.
 * @return {number}
 */
RectilinearView.prototype.ty = function() {
  return this._ty;
};

/**
 * Get the viewpoint's tz.
 * @return {number}
 */
RectilinearView.prototype.tz = function() {
  return this._tz;
};

/**
 * Get the viewpoint's ox.
 * @return {number}
 */
RectilinearView.prototype.ox = function() {
  return this._ox;
};

/**
 * Get the viewpoint's oy.
 * @return {number}
 */
RectilinearView.prototype.oy = function() {
  return this._oy;
};

/**
 * Get the viewpoint's tz.
 * @return {number}
 */
RectilinearView.prototype.oz = function() {
  return this._oz;
};

/**
 * Get the invert control flag.
 * @return {boolean}
 */
RectilinearView.prototype.invertControl = function() {
  return this._invertControl;
};

/**
 * Get the viewport dimensions. If an argument is supplied, it is filled in with
 * the result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {Size=} size
 * @return {Size}
 */
RectilinearView.prototype.size = function(size) {
  size = size || {};
  size.width = this._width;
  size.height = this._height;
  return size;
};


/**
 * Get the view parameters. If an argument is supplied, it is filled in with the
 * result and returned. Otherwise, a fresh object is filled in and returned.
 * @param {RectilinearViewParams=} obj
 * @return {RectilinearViewParams}
 */
RectilinearView.prototype.parameters = function(params) {
  params = params || {};
  params.yaw = this._yaw;
  params.pitch = this._pitch;
  params.roll = this._roll;
  params.fov = this._fov;
  return params;
};


/**
 * Get the view limiter, or null if unset.
 * @return {?RectilinearViewLimiter}
 */
RectilinearView.prototype.limiter = function() {
  return this._limiter;
};


/**
 * Set the yaw angle.
 * @param {number} yaw
 */
RectilinearView.prototype.setYaw = function(yaw) {
  this._resetParams();
  this._params.yaw = yaw;
  this._update(this._params);
};


/**
 * Set the pitch angle.
 * @param {number} pitch
 */
RectilinearView.prototype.setPitch = function(pitch) {
  this._resetParams();
  this._params.pitch = pitch;
  this._update(this._params);
};


/**
 * Set the roll angle.
 * @param {number} roll
 */
RectilinearView.prototype.setRoll = function(roll) {
  this._resetParams();
  this._params.roll = roll;
  this._update(this._params);
};


/**
 * Set the fov value.
 * @param {number} fov
 */
RectilinearView.prototype.setFov = function(fov) {
  this._resetParams();
  this._params.fov = fov;
  this._update(this._params);
};


RectilinearView.prototype.setProjectionCenterX = function(projectionCenterX) {
  this._resetParams();
  this._params.projectionCenterX = projectionCenterX;
  this._update(this._params);
};


RectilinearView.prototype.setProjectionCenterY = function(projectionCenterY) {
  this._resetParams();
  this._params.projectionCenterY = projectionCenterY;
  this._update(this._params);
};


/**
 * Add yawOffset to the current yaw value.
 * @param {number} yawOffset
 */
RectilinearView.prototype.offsetYaw = function(yawOffset) {
  this.setYaw(this._yaw + yawOffset);
};


/**
 * Add pitchOffset to the current pitch value.
 * @param {number} pitchOffset
 */
RectilinearView.prototype.offsetPitch = function(pitchOffset) {
  this.setPitch(this._pitch + pitchOffset);
};


/**
 * Add rollOffset to the current roll value.
 * @param {number} rollOffset
 */
RectilinearView.prototype.offsetRoll = function(rollOffset) {
  this.setRoll(this._roll + rollOffset);
};


/**
 * Add fovOffset to the current fov value.
 * @param {number} fovOffset
 */
RectilinearView.prototype.offsetFov = function(fovOffset) {
  this.setFov(this._fov + fovOffset);
};


/**
 * Set the viewport dimensions.
 * @param {Size} size
 */
RectilinearView.prototype.setSize = function(size) {
  this._resetParams();
  this._params.width = size.width;
  this._params.height = size.height;
  this._update(this._params);
};

/**
 * Set the viewpoint's tx.
 * @param {number} tx
 */
RectilinearView.prototype.setTx = function(tx) {
  this._resetParams();
  this._params.tx = tx;
  this._update(this._params);
}

/**
 * Set the viewpoint's ty.
 * @param {number} ty
 */
RectilinearView.prototype.setTy = function(ty) {
  this._resetParams();
  this._params.ty = ty;
  this._update(this._params);
}

/**
 * Set the viewpoint's tz.
 * @param {number} tz
 */
RectilinearView.prototype.setTz = function(tz) {
  this._resetParams();
  this._params.tz = tz;
  this._update(this._params);
}

/**
 * Set the viewpoint's ox.
 * @param {number} tx
 */
RectilinearView.prototype.setOx = function(ox) {
  this._resetParams();
  this._params.ox = ox;
  this._update(this._params);
}

/**
 * Set the viewpoint's oy.
 * @param {number} oy
 */
RectilinearView.prototype.setOy = function(oy) {
  this._resetParams();
  this._params.oy = oy;
  this._update(this._params);
}

/**
 * Set the viewpoint's oz.
 * @param {number} oz
 */
RectilinearView.prototype.setOz = function(oz) {
  this._resetParams();
  this._params.oz = oz;
  this._update(this._params);
}

/**
 * Get the invert control flag.
 * @return {boolean}
 */
RectilinearView.prototype.setInvertControl = function(invertControl) {
  this._invertControl = invertControl;
};

/**
 * Set the view parameters. Unspecified parameters are left unchanged.
 * @param {RectilinearViewParameters} params
 */
RectilinearView.prototype.setParameters = function(params) {
  this._resetParams();
  this._params.yaw = params.yaw;
  this._params.pitch = params.pitch;
  this._params.roll = params.roll;
  this._params.fov = params.fov;
  this._params.projectionCenterX = params.projectionCenterX;
  this._params.projectionCenterY = params.projectionCenterY;
  this._update(this._params);
};


/**
 * Set the view limiter.
 * @param {?RectilinearViewLimiter} limiter The new limiter, or null to unset.
 */
RectilinearView.prototype.setLimiter = function(limiter) {
  this._limiter = limiter || null;
  this._update();
};


RectilinearView.prototype._resetParams = function() {
  var params = this._params;
  params.yaw = null;
  params.pitch = null;
  params.roll = null;
  params.fov = null;
  params.width = null;
  params.height = null;
  params.position = null;
};


RectilinearView.prototype._update = function(params) {

  // Avoid object allocation when no parameters are supplied.
  if (params == null) {
    this._resetParams();
    params = this._params;
  }

  // Save old parameters for later comparison.
  var oldYaw = this._yaw;
  var oldPitch = this._pitch;
  var oldRoll = this._roll;
  var oldFov = this._fov;
  var oldProjectionCenterX = this._projectionCenterX;
  var oldProjectionCenterY = this._projectionCenterY;
  var oldWidth = this._width;
  var oldHeight = this._height;
  
  var oldTx = this._tx;
  var oldTy = this._ty;
  var oldTz = this._tz;
  var oldOx = this._ox;
  var oldOy = this._oy;
  var oldOz = this._oz;

  // Fill in object with the new set of parameters to pass into the limiter.
  params.yaw = params.yaw != null ? params.yaw : oldYaw;
  params.pitch = params.pitch != null ? params.pitch : oldPitch;
  params.roll = params.roll != null ? params.roll : oldRoll;
  params.fov = params.fov != null ? params.fov : oldFov;
  params.width = params.width != null ? params.width : oldWidth;
  params.height = params.height != null ? params.height : oldHeight;
  params.projectionCenterX = params.projectionCenterX != null ?
    params.projectionCenterX : oldProjectionCenterX;
  params.projectionCenterY = params.projectionCenterY != null ?
    params.projectionCenterY : oldProjectionCenterY;

  params.tx = params.tx != null ? params.tx : oldTx;
  params.ty = params.ty != null ? params.ty : oldTy;
  params.tz = params.tz != null ? params.tz : oldTz;
  params.ox = params.ox != null ? params.ox : oldOx;
  params.oy = params.oy != null ? params.oy : oldOy;
  params.oz = params.oz != null ? params.oz : oldOz;

  // Apply view limiting when defined.
  if (this._limiter) {
    params = this._limiter(params);
    if (!params) {
      throw new Error('Bad view limiter');
    }
  }

  // Normalize parameters.
  params = this._normalize(params);

  // Grab the limited parameters.
  var newYaw = params.yaw;
  var newPitch = params.pitch;
  var newRoll = params.roll;
  var newFov = params.fov;
  var newWidth = params.width;
  var newHeight = params.height;
  var newProjectionCenterX = params.projectionCenterX;
  var newProjectionCenterY = params.projectionCenterY;

  var newTx = params.tx;
  var newTy = params.ty;
  var newTz = params.tz;
  var newOx = params.ox;
  var newOy = params.oy;
  var newOz = params.oz;

  // Consistency check.
  if (!real(newYaw) || !real(newPitch) || !real(newRoll) ||
      !real(newFov) || !real(newWidth) || !real(newHeight) ||
      !real(newProjectionCenterX) || !real(newProjectionCenterY)) {
    throw new Error('Bad view - suspect a broken limiter');
  }

  // Update parameters.
  this._yaw = newYaw;
  this._pitch = newPitch;
  this._roll = newRoll;
  this._fov = newFov;
  this._width = newWidth;
  this._height = newHeight;
  this._projectionCenterX = newProjectionCenterX;
  this._projectionCenterY = newProjectionCenterY;
  
  this._tx = newTx;
  this._ty = newTy;
  this._tz = newTz;
  this._ox = newOx;
  this._oy = newOy;
  this._oz = newOz;

  // Check whether the parameters changed and emit the corresponding events.
  if (newYaw !== oldYaw || newPitch !== oldPitch || newRoll !== oldRoll ||
      newFov !== oldFov || newWidth !== oldWidth || newHeight !== oldHeight ||
      newProjectionCenterX !== oldProjectionCenterX ||
      newProjectionCenterY !== oldProjectionCenterY ||
      newTx !== oldTx || newTy !== oldTy || newTz !== oldTz ||
      newOx !== oldOx || newOy !== oldOy || newOz !== oldOz) {
    this._matrixChanged = true;
    this.emit('change');
  }
  if (newWidth !== oldWidth || newHeight !== oldHeight) {
    this.emit('resize');
  }
};


RectilinearView.prototype._normalize = function(params) {

  this._normalizeCoordinates(params);

  // Make sure that neither the horizontal nor the vertical fields of view
  // exceed  - fovLimitEpsilon.
  var hfovPi = convertFov.htov(Math.PI, params.width, params.height);
  var maxFov = isNaN(hfovPi) ? Math.PI : Math.min(Math.PI, hfovPi);
  params.fov = clamp(params.fov, fovLimitEpsilon, maxFov - fovLimitEpsilon);

  return params;
};


RectilinearView.prototype._normalizeCoordinates = function(params) {
  // Constrain yaw, pitch and roll to the [-, ] interval.
  if ('yaw' in params) {
    params.yaw = mod(params.yaw - Math.PI, -2*Math.PI) + Math.PI;
  }
  if ('pitch' in params) {
    params.pitch = mod(params.pitch - Math.PI, -2*Math.PI) + Math.PI;
  }
  if ('roll' in params) {
    params.roll = mod(params.roll - Math.PI, -2*Math.PI) + Math.PI;
  }
  return params;
};


/**
 * Normalize view coordinates so that they are the closest to the current view.
 * Useful for tweening the view through the shortest path. If a result argument
 * is supplied, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {RectilinearViewCoords} result The result argument for the normalized
 *     view coordinates.
 */
RectilinearView.prototype.normalizeToClosest = function(coords, result) {

  var viewYaw = this._yaw;
  var viewPitch = this._pitch;

  var coordYaw = coords.yaw;
  var coordPitch = coords.pitch;

  // Check if the yaw is closer after subtracting or adding a full circle.
  var prevYaw = coordYaw - 2*Math.PI;
  var nextYaw = coordYaw + 2*Math.PI;
  if (Math.abs(prevYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
    coordYaw = prevYaw;
  }
  else if (Math.abs(nextYaw - viewYaw) < Math.abs(coordYaw - viewYaw)) {
    coordYaw = nextYaw;
  }

  // Check if the pitch is closer after subtracting or adding a full circle.
  var prevPitch = coordPitch - 2*Math.PI;
  var nextPitch = coordPitch + 2*Math.PI;
  if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
    coordPitch = prevPitch;
  }
  else if (Math.abs(prevPitch - viewPitch) < Math.abs(coordPitch - viewPitch)) {
    coordPitch = nextPitch;
  }

  result = result || {};
  result.yaw = coordYaw;
  result.pitch = coordPitch;
  return result;

};


RectilinearView.prototype.updateWithControlParameters = function(parameters) {
  // axisScaledX and axisScaledY are scaled according to their own axis
  // x and y are scaled by the same value

  // If the viewport dimensions are zero, assume a square viewport
  // when converting from hfov to vfov.
  var vfov = this._fov;
  var hfov = convertFov.vtoh(vfov, this._width, this._height);
  if (isNaN(hfov)) {
    hfov = vfov;
  }

  // TODO: revisit this after we rethink the control parameters.
  this.offsetYaw(parameters.axisScaledX * hfov + parameters.x * 2 * hfov + parameters.yaw);
  this.offsetPitch(parameters.axisScaledY * vfov + parameters.y * 2 * hfov + parameters.pitch);
  this.offsetRoll(-parameters.roll);
  this.offsetFov(parameters.zoom * vfov);
};


RectilinearView.prototype._updateMatrix = function() {
  var projMatrix = this._projMatrix;
  var invProjMatrix = this._invProjMatrix;
  var viewMatrix = this._viewMatrix;
  var invViewMatrix = this._invViewMatrix;
  var frustum = this._frustum;

  if (this._matrixChanged) {
    var width = this._width;
    var height = this._height;

    var vfov = this._fov;
    var hfov = convertFov.vtoh(vfov, width, height);
    var aspect = width / height;

    var projectionCenterX = this._projectionCenterX;
    var projectionCenterY = this._projectionCenterY;

    // Projection Matrix.
    if (projectionCenterX !== 0 || projectionCenterY !== 0) {
      var offsetAngleX = Math.atan(projectionCenterX * 2 * Math.tan(hfov/2));
      var offsetAngleY = Math.atan(projectionCenterY * 2 * Math.tan(vfov/2));
      var fovs = this._fovs;
      fovs.leftDegrees = (hfov/2 + offsetAngleX) * 180/Math.PI;
      fovs.rightDegrees = (hfov/2 - offsetAngleX) * 180/Math.PI;
      fovs.upDegrees = (vfov/2 + offsetAngleY) * 180/Math.PI;
      fovs.downDegrees = (vfov/2 - offsetAngleY) * 180/Math.PI;
      mat4.perspectiveFromFieldOfView(projMatrix, fovs, -1, 1);
    } else {
      mat4.perspective(projMatrix, vfov, aspect, -1, 1);
    }

    mat4.invert(invProjMatrix, projMatrix);

    // View Matrix.
    mat4.identity(viewMatrix);
    mat4.translate(viewMatrix, viewMatrix, vec3.negate(vec3.create(), [this._ox, this._oy, this._oz]));

    // Invert control.
    var roll = this._invertControl ? -this._roll : this._roll;
    var pitch = this._invertControl ? -this._pitch :this._pitch;
    var yaw = this._invertControl ? -this._yaw : this._yaw;
    mat4.rotateZ(viewMatrix, viewMatrix, roll);
    mat4.rotateX(viewMatrix, viewMatrix, pitch);
    mat4.rotateY(viewMatrix, viewMatrix, yaw);

    mat4.translate(viewMatrix, viewMatrix, vec3.negate(vec3.create(), [this._tx, this._ty, this._tz]));

    mat4.invert(invViewMatrix, viewMatrix);

    // Get the frustum planes.
    var matrix = mat4.create();
    mat4.multiply(matrix, projMatrix, viewMatrix);
    this._matrixToFrustum(matrix, frustum);

    this._matrixChanged = false;
  }
};

RectilinearView.prototype._matrixToFrustum = function(p, f) {
  // Extract frustum planes from projection matrix.
  // http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf
  vec4.set(f[0], p[3] + p[0], p[7] + p[4], p[11] + p[8], p[15] + p[12]); // left
  vec4.set(f[1], p[3] - p[0], p[7] - p[4], p[11] - p[8], p[15] - p[12]); // right
  vec4.set(f[2], p[3] + p[1], p[7] + p[5], p[11] + p[9], p[15] + p[13]); // top
  vec4.set(f[3], p[3] - p[1], p[7] - p[5], p[11] - p[9], p[15] - p[13]); // bottom
  vec4.set(f[4], p[3] + p[2], p[7] + p[6], p[11] + p[10], p[15] + p[14]); // camera
};

/**
 * Returns the projection matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.projection = function() {
  this._updateMatrix();
  return this._projMatrix;
};

/**
 * Returns the inverse projection matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.inverseProjection = function() {
  this._updateMatrix();
  return this._invProjMatrix;
};

/**
 * Returns the view matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.viewMatrix = function() {
  this._updateMatrix();
  return this._viewMatrix;
}

/**
 * Returns the inverse view matrix for the current view.
 * @returns {mat4}
 */
RectilinearView.prototype.inverseViewMatrix = function() {
  this._updateMatrix();
  return this._invViewMatrix;
}

/**
 * Return whether the view frustum intersects the given rectangle.
 *
 * This function may return false positives, but never false negatives.
 * It is used for frustum culling, i.e., excluding invisible tiles from the
 * rendering process.
 *
 * @param {vec2[]} rectangle The vertices of the rectangle.
 */
RectilinearView.prototype.intersects = function(rectangle) {
  this._updateMatrix();

  var frustum = this._frustum;
  var vertex = this._tmpVec;

  // Check whether the rectangle is on the outer side of any of the frustum
  // planes. This is a sufficient condition, though not necessary, for the
  // rectangle to be completely outside the frustum.
  for (var i = 0; i < frustum.length; i++) {
    var plane = frustum[i];
    var inside = false;
    for (var j = 0; j < rectangle.length; j++) {
      var corner = rectangle[j];
      vec4.set(vertex, corner[0], corner[1], corner[2], 1.0);
      if (vec4.dot(plane, vertex) >= 0) {
        inside = true;
      }
    }
    if (!inside) {
      return false;
    }
  }
  return true;
};


/**
 * Select the level that should be used to render the view.
 * @param {Level[]} levelList the list of levels from which to select.
 * @return {Level} the selected level.
 */
RectilinearView.prototype.selectLevel = function(levelList) {

  // Multiply the viewport width by the device pixel ratio to get the required
  // horizontal resolution in pixels.
  //
  // Calculate the fraction of a cube face that would be visible given the
  // current vertical field of view. Then, for each level, multiply by the
  // level height to get the height in pixels of the portion that would be
  // visible.
  //
  // Search for the smallest level that satifies the the required height,
  // falling back on the largest level if none do.

  var requiredPixels = pixelRatio() * this._height;
  var coverFactor = Math.tan(0.5 * this._fov);

  for (var i = 0; i < levelList.length; i++) {
    var level = levelList[i];
    if (coverFactor * level.height() >= requiredPixels) {
      return level;
    }
  }

  return levelList[levelList.length - 1];

};


/**
 * Convert view parameters into screen position. If a result argument is
 * provided, it is filled in and returned. Otherwise, a fresh object is filled
 * in and returned.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {Coords=} result The result argument for the screen coordinates.
 * @return {Coords}
 */
RectilinearView.prototype.coordinatesToScreen = function(coords, result) {
  var ray = this._tmpVec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Undefined on a null viewport.
  if (width <= 0 || height <= 0) {
    result.x = null;
    result.y = null;
    return null;
  }

  // Compute view ray pointing into the (yaw, pitch) direction.
  var yaw = coords.yaw;
  var pitch = coords.pitch;
  var x = Math.sin(yaw) * Math.cos(pitch);
  var y = -Math.sin(pitch);
  var z = -Math.cos(yaw) * Math.cos(pitch);
  vec4.set(ray, x, y, z, 1);

  // Project view ray onto clip space.
  vec4.transformMat4(ray, ray, this.projection());

  // w in clip space equals -z in camera space.
  if (ray[3] >= 0) {
    // Point is in front of camera.
    // Convert to viewport coordinates.
    result.x = width * (ray[0] / ray[3] + 1) / 2;
    result.y = height * (1 - ray[1] / ray[3]) / 2;
  } else {
    // Point is behind camera.
    result.x = null;
    result.y = null;
    return null;
  }

  return result;
};


/**
 * Convert screen coordinates into view coordinates. If a result argument is
 * provided, it is filled in with the result and returned. Otherwise, a fresh
 * object is filled in and returned.
 *
 * @param {Coords} coords The screen coordinates.
 * @param {RectilinearViewCoords=} result The view coordinates.
 * @return {RectilinearViewCoords}
 */
RectilinearView.prototype.screenToCoordinates = function(coords, result) {
  var ray = this._tmpVec;

  if (!result) {
    result = {};
  }

  var width = this._width;
  var height = this._height;

  // Convert viewport coordinates to clip space.
  var vecx = 2 * coords.x / width - 1;
  var vecy = 1 - 2 * coords.y / height;
  vec4.set(ray, vecx, vecy, 1, 1);

  // Project back to world space.
  vec4.transformMat4(ray, ray, this.inverseProjection());

  // Convert to spherical coordinates.
  var r = Math.sqrt(ray[0] * ray[0] + ray[1] * ray[1] + ray[2] * ray[2]);
  result.yaw = Math.atan2(ray[0], -ray[2]);
  result.pitch = Math.acos(ray[1] / r) - Math.PI/2;

  this._normalizeCoordinates(result);

  return result;
};


/**
 * Calculate the perspective transform required to position an element with
 * perspective.
 *
 * @param {RectilinearViewCoords} coords The view coordinates.
 * @param {number} radius Radius of the sphere embedding the element.
 * @param {string} extraTransforms Extra transformations to be applied after
 *     the element is positioned. This may be used to rotate the element.
 * @return {string} The CSS 3D transform to be applied to the element.
 */
RectilinearView.prototype.coordinatesToPerspectiveTransform = function(
    coords, radius, extraTransforms) {
  extraTransforms = extraTransforms || "";

  var height = this._height;
  var width = this._width;
  var fov = this._fov;
  var perspective = 0.5 * height / Math.tan(fov / 2);

  var transform = '';

  // Center hotspot in screen.
  transform += 'translateX(' + decimal(width/2) + 'px) ';
  transform += 'translateY(' + decimal(height/2) + 'px) ';
  transform += 'translateX(-50%) translateY(-50%) ';

  // Set the perspective depth.
  transform += 'perspective(' + decimal(perspective) + 'px) ';
  transform += 'translateZ(' + decimal(perspective) + 'px) ';

  // Set the camera rotation.
  transform += 'rotateZ(' + decimal(-this._roll) + 'rad) ';
  transform += 'rotateX(' + decimal(-this._pitch) + 'rad) ';
  transform += 'rotateY(' + decimal(this._yaw) + 'rad) ';

  // Set the hotspot rotation.
  transform += 'rotateY(' + decimal(-coords.yaw) + 'rad) ';
  transform += 'rotateX(' + decimal(coords.pitch) + 'rad) ';

  // Move back to sphere.
  transform += 'translateZ(' + decimal(-radius) + 'px) ';

  // Apply the extra transformations
  transform += extraTransforms + ' ';

  return transform;
};


/**
 * Factory functions for view limiters. See {@link RectilinearViewLimiter}.
 * @namespace
 */
RectilinearView.limit = {

  /**
   * Returns a view limiter that constrains the yaw angle.
   * @param {number} min The minimum yaw value.
   * @param {number} max The maximum yaw value.
   * @return {RectilinearViewLimiter}
   */
  yaw: function(min, max) {
    return function limitYaw(params) {
      params.yaw = clamp(params.yaw, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the pitch angle.
   * @param {number} min The minimum pitch value.
   * @param {number} max The maximum pitch value.
   * @return {RectilinearViewLimiter}
   */
  pitch: function(min, max) {
    return function limitPitch(params) {
      params.pitch = clamp(params.pitch, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the roll angle.
   * @param {number} min The minimum roll value.
   * @param {number} max The maximum roll value.
   * @return {RectilinearViewLimiter}
   */
  roll: function(min, max) {
    return function limitRoll(params) {
      params.roll = clamp(params.roll, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the horizontal field of view.
   * @param {number} min The minimum horizontal field of view.
   * @param {number} max The maximum horizontal field of view.
   * @return {RectilinearViewLimiter}
   */
  hfov: function(min, max) {
    return function limitHfov(params) {
      var width = params.width;
      var height = params.height;
      if (width > 0 && height > 0) {
        var vmin = convertFov.htov(min, width, height);
        var vmax = convertFov.htov(max, width, height);
        params.fov = clamp(params.fov, vmin, vmax);
      }
      return params;
    };
  },

  /**
   * Returns a view limiter that constrains the vertical field of view.
   * @param {number} min The minimum vertical field of view.
   * @param {number} max The maximum vertical field of view.
   * @return {RectilinearViewLimiter}
   */
  vfov: function(min, max) {
    return function limitVfov(params) {
      params.fov = clamp(params.fov, min, max);
      return params;
    };
  },

  /**
   * Returns a view limiter that prevents zooming in beyond the given
   * resolution.
   * @param {number} size The cube face width in pixels or, equivalently, one
   *     fourth of the equirectangular width in pixels.
   * @return {RectilinearViewLimiter}
   */
  resolution: function(size) {
    return function limitResolution(params) {
      var height = params.height;
      if (height) {
        var requiredPixels = pixelRatio() * height;
        var minFov = 2 * Math.atan(requiredPixels / size);
        params.fov = clamp(params.fov, minFov, Infinity);
      }
      return params;
    };
  },

  /**
   * Returns a view limiter that limits the horizontal and vertical field of
   * view, prevents zooming in past the image resolution, and limits the pitch
   * range to prevent the camera wrapping around at the poles. These are the
   * most common view constraints for a 360 panorama.
   * @param {number} maxResolution The cube face width in pixels or,
   *     equivalently, one fourth of the equirectangular width in pixels.
   * @param {number} maxVFov The maximum vertical field of view.
   * @param {number} [maxHFov=maxVFov] The maximum horizontal field of view.
   * @return {RectilinearViewLimiter}
   */
  traditional: function(maxResolution, maxVFov, maxHFov) {
    maxHFov = maxHFov != null ? maxHFov : maxVFov;

    return compose(
      RectilinearView.limit.resolution(maxResolution),
      RectilinearView.limit.vfov(0, maxVFov),
      RectilinearView.limit.hfov(0, maxHFov),
      RectilinearView.limit.pitch(-Math.PI/2, Math.PI/2));
  }

};


RectilinearView.type = RectilinearView.prototype.type = 'rectilinear';


module.exports = RectilinearView;

},{"../util/clamp":81,"../util/clearOwnProperties":82,"../util/compose":84,"../util/convertFov":85,"../util/decimal":86,"../util/mod":97,"../util/pixelRatio":101,"../util/real":104,"gl-matrix":3,"minimal-event-emitter":14}]},{},[55])(55)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYm93c2VyL3NyYy9ib3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL21hdDIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9tYXQyZC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL21hdDMuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy9tYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvcXVhdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL3F1YXQyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9janMvdmVjMi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvY2pzL3ZlYzMuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Nqcy92ZWM0LmpzIiwibm9kZV9tb2R1bGVzL2hhbW1lcmpzL2hhbW1lci5qcyIsIm5vZGVfbW9kdWxlcy9taW5pbWFsLWV2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJzcmMvRGVwdGhtYXBTdG9yZS5qcyIsInNyYy9Ib3RzcG90LmpzIiwic3JjL0hvdHNwb3RDb250YWluZXIuanMiLCJzcmMvTGF5ZXIuanMiLCJzcmMvTmV0d29ya0Vycm9yLmpzIiwic3JjL1JlbmRlckxvb3AuanMiLCJzcmMvU2NlbmUuanMiLCJzcmMvVGV4dHVyZVN0b3JlLmpzIiwic3JjL1RpbGVTZWFyY2hlci5qcyIsInNyYy9UaW1lci5qcyIsInNyYy9WaWV3ZXIuanMiLCJzcmMvYXNzZXRzL0R5bmFtaWMuanMiLCJzcmMvYXNzZXRzL1N0YXRpYy5qcyIsInNyYy9hdXRvcm90YXRlLmpzIiwic3JjL2NvbGxlY3Rpb25zL0xydU1hcC5qcyIsInNyYy9jb2xsZWN0aW9ucy9McnVTZXQuanMiLCJzcmMvY29sbGVjdGlvbnMvTWFwLmpzIiwic3JjL2NvbGxlY3Rpb25zL1NldC5qcyIsInNyYy9jb2xsZWN0aW9ucy9Xb3JrUG9vbC5qcyIsInNyYy9jb2xsZWN0aW9ucy9Xb3JrUXVldWUuanMiLCJzcmMvY29sb3JFZmZlY3RzLmpzIiwic3JjL2NvbnRyb2xzL0NvbXBvc2VyLmpzIiwic3JjL2NvbnRyb2xzL0NvbnRyb2xDdXJzb3IuanMiLCJzcmMvY29udHJvbHMvQ29udHJvbHMuanMiLCJzcmMvY29udHJvbHMvRHJhZy5qcyIsInNyYy9jb250cm9scy9EeW5hbWljcy5qcyIsInNyYy9jb250cm9scy9FbGVtZW50UHJlc3MuanMiLCJzcmMvY29udHJvbHMvSGFtbWVyR2VzdHVyZXMuanMiLCJzcmMvY29udHJvbHMvS2V5LmpzIiwic3JjL2NvbnRyb2xzL1BpbmNoWm9vbS5qcyIsInNyYy9jb250cm9scy9RdHZyLmpzIiwic3JjL2NvbnRyb2xzL1Njcm9sbFpvb20uanMiLCJzcmMvY29udHJvbHMvVmVsb2NpdHkuanMiLCJzcmMvY29udHJvbHMvcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMuanMiLCJzcmMvY29udHJvbHMvdXRpbC5qcyIsInNyYy9nZW9tZXRyaWVzL0N1YmUuanMiLCJzcmMvZ2VvbWV0cmllcy9FcXVpcmVjdC5qcyIsInNyYy9nZW9tZXRyaWVzL0ZsYXQuanMiLCJzcmMvZ2VvbWV0cmllcy9MZXZlbC5qcyIsInNyYy9nZW9tZXRyaWVzL2NvbW1vbi5qcyIsInNyYy9pbmRleC5qcyIsInNyYy9sb2FkZXJzL0h0bWxJbWFnZS5qcyIsInNyYy9sb2FkZXJzL0h0bWxNb2RlbC5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xCYXNlLmpzIiwic3JjL3JlbmRlcmVycy9XZWJHbENvbW1vbi5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xDdWJlLmpzIiwic3JjL3JlbmRlcmVycy9XZWJHbEN1YmVEZXB0aC5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xFcXVpcmVjdC5qcyIsInNyYy9yZW5kZXJlcnMvV2ViR2xGbGF0LmpzIiwic3JjL3JlbmRlcmVycy9yZWdpc3RlckRlZmF1bHRSZW5kZXJlcnMuanMiLCJzcmMvc2hhZGVycy9mcmFnbWVudEN1YmVEZXB0aC5qcyIsInNyYy9zaGFkZXJzL2ZyYWdtZW50RXF1aXJlY3QuanMiLCJzcmMvc2hhZGVycy9mcmFnbWVudE5vcm1hbC5qcyIsInNyYy9zaGFkZXJzL3ZlcnRleEN1YmVEZXB0aC5qcyIsInNyYy9zaGFkZXJzL3ZlcnRleEN1YmVEZXB0aFNUTC5qcyIsInNyYy9zaGFkZXJzL3ZlcnRleEVxdWlyZWN0LmpzIiwic3JjL3NoYWRlcnMvdmVydGV4Tm9ybWFsLmpzIiwic3JjL3NvdXJjZXMvSW1hZ2VVcmwuanMiLCJzcmMvc291cmNlcy9TaW5nbGVBc3NldC5qcyIsInNyYy9zdGFnZXMvUmVuZGVyZXJSZWdpc3RyeS5qcyIsInNyYy9zdGFnZXMvU3RhZ2UuanMiLCJzcmMvc3RhZ2VzL1dlYkdsLmpzIiwic3JjL3V0aWwvYXN5bmMuanMiLCJzcmMvdXRpbC9jYWxjUmVjdC5qcyIsInNyYy91dGlsL2NhbmNlbGl6ZS5qcyIsInNyYy91dGlsL2NoYWluLmpzIiwic3JjL3V0aWwvY2xhbXAuanMiLCJzcmMvdXRpbC9jbGVhck93blByb3BlcnRpZXMuanMiLCJzcmMvdXRpbC9jbXAuanMiLCJzcmMvdXRpbC9jb21wb3NlLmpzIiwic3JjL3V0aWwvY29udmVydEZvdi5qcyIsInNyYy91dGlsL2RlY2ltYWwuanMiLCJzcmMvdXRpbC9kZWZhdWx0cy5qcyIsInNyYy91dGlsL2RlZmVyLmpzIiwic3JjL3V0aWwvZGVnVG9SYWQuanMiLCJzcmMvdXRpbC9kZWxheS5qcyIsInNyYy91dGlsL2RvbS5qcyIsInNyYy91dGlsL2V4dGVuZC5qcyIsInNyYy91dGlsL2dsb2JhbC5qcyIsInNyYy91dGlsL2hhc2guanMiLCJzcmMvdXRpbC9pbmhlcml0cy5qcyIsInNyYy91dGlsL2lzcG90LmpzIiwic3JjL3V0aWwvbW9kLmpzIiwic3JjL3V0aWwvbm9vcC5qcyIsInNyYy91dGlsL25vdy5qcyIsInNyYy91dGlsL29uY2UuanMiLCJzcmMvdXRpbC9waXhlbFJhdGlvLmpzIiwic3JjL3V0aWwvcG9zaXRpb25BYnNvbHV0ZWx5LmpzIiwic3JjL3V0aWwvcmFkVG9EZWcuanMiLCJzcmMvdXRpbC9yZWFsLmpzIiwic3JjL3V0aWwvcmV0cnkuanMiLCJzcmMvdXRpbC90d2Vlbi5qcyIsInNyYy91dGlsL3R5cGUuanMiLCJzcmMvdmlld3MvRmxhdC5qcyIsInNyYy92aWV3cy9SZWN0aWxpbmVhci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3AxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5M0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNodEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy91QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25oQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNycUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNucUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qIVxuICogQm93c2VyIC0gYSBicm93c2VyIGRldGVjdG9yXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGVkL2Jvd3NlclxuICogTUlUIExpY2Vuc2UgfCAoYykgRHVzdGluIERpYXogMjAxNVxuICovXG5cbiFmdW5jdGlvbiAocm9vdCwgbmFtZSwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShuYW1lLCBkZWZpbml0aW9uKVxuICBlbHNlIHJvb3RbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0odGhpcywgJ2Jvd3NlcicsIGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAgKiBTZWUgdXNlcmFnZW50cy5qcyBmb3IgZXhhbXBsZXMgb2YgbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICovXG5cbiAgdmFyIHQgPSB0cnVlXG5cbiAgZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdE1hdGNoKHJlZ2V4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XG4gICAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMV0pIHx8ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlY29uZE1hdGNoKHJlZ2V4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XG4gICAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMl0pIHx8ICcnO1xuICAgIH1cblxuICAgIHZhciBpb3NkZXZpY2UgPSBnZXRGaXJzdE1hdGNoKC8oaXBvZHxpcGhvbmV8aXBhZCkvaSkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBsaWtlQW5kcm9pZCA9IC9saWtlIGFuZHJvaWQvaS50ZXN0KHVhKVxuICAgICAgLCBhbmRyb2lkID0gIWxpa2VBbmRyb2lkICYmIC9hbmRyb2lkL2kudGVzdCh1YSlcbiAgICAgICwgbmV4dXNNb2JpbGUgPSAvbmV4dXNcXHMqWzAtNl1cXHMqL2kudGVzdCh1YSlcbiAgICAgICwgbmV4dXNUYWJsZXQgPSAhbmV4dXNNb2JpbGUgJiYgL25leHVzXFxzKlswLTldKy9pLnRlc3QodWEpXG4gICAgICAsIGNocm9tZW9zID0gL0NyT1MvLnRlc3QodWEpXG4gICAgICAsIHNpbGsgPSAvc2lsay9pLnRlc3QodWEpXG4gICAgICAsIHNhaWxmaXNoID0gL3NhaWxmaXNoL2kudGVzdCh1YSlcbiAgICAgICwgdGl6ZW4gPSAvdGl6ZW4vaS50ZXN0KHVhKVxuICAgICAgLCB3ZWJvcyA9IC8od2VifGhwdykob3wwKXMvaS50ZXN0KHVhKVxuICAgICAgLCB3aW5kb3dzcGhvbmUgPSAvd2luZG93cyBwaG9uZS9pLnRlc3QodWEpXG4gICAgICAsIHNhbXN1bmdCcm93c2VyID0gL1NhbXN1bmdCcm93c2VyL2kudGVzdCh1YSlcbiAgICAgICwgd2luZG93cyA9ICF3aW5kb3dzcGhvbmUgJiYgL3dpbmRvd3MvaS50ZXN0KHVhKVxuICAgICAgLCBtYWMgPSAhaW9zZGV2aWNlICYmICFzaWxrICYmIC9tYWNpbnRvc2gvaS50ZXN0KHVhKVxuICAgICAgLCBsaW51eCA9ICFhbmRyb2lkICYmICFzYWlsZmlzaCAmJiAhdGl6ZW4gJiYgIXdlYm9zICYmIC9saW51eC9pLnRlc3QodWEpXG4gICAgICAsIGVkZ2VWZXJzaW9uID0gZ2V0U2Vjb25kTWF0Y2goL2VkZyhbZWFdfGlvcylcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICAsIHZlcnNpb25JZGVudGlmaWVyID0gZ2V0Rmlyc3RNYXRjaCgvdmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgICwgdGFibGV0ID0gL3RhYmxldC9pLnRlc3QodWEpICYmICEvdGFibGV0IHBjL2kudGVzdCh1YSlcbiAgICAgICwgbW9iaWxlID0gIXRhYmxldCAmJiAvW14tXW1vYmkvaS50ZXN0KHVhKVxuICAgICAgLCB4Ym94ID0gL3hib3gvaS50ZXN0KHVhKVxuICAgICAgLCByZXN1bHRcblxuICAgIGlmICgvb3BlcmEvaS50ZXN0KHVhKSkge1xuICAgICAgLy8gIGFuIG9sZCBPcGVyYVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEnXG4gICAgICAsIG9wZXJhOiB0XG4gICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/Om9wZXJhfG9wcnxvcGlvcylbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9vcHJcXC98b3Bpb3MvaS50ZXN0KHVhKSkge1xuICAgICAgLy8gYSBuZXcgT3BlcmFcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ09wZXJhJ1xuICAgICAgICAsIG9wZXJhOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86b3ByfG9waW9zKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvU2Ftc3VuZ0Jyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZCdcbiAgICAgICAgLCBzYW1zdW5nQnJvd3NlcjogdFxuICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/OlNhbXN1bmdCcm93c2VyKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvV2hhbGUvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTkFWRVIgV2hhbGUgYnJvd3NlcidcbiAgICAgICAgLCB3aGFsZTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OndoYWxlKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9NWkJyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTVogQnJvd3NlcidcbiAgICAgICAgLCBtemJyb3dzZXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpNWkJyb3dzZXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2NvYXN0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ09wZXJhIENvYXN0J1xuICAgICAgICAsIGNvYXN0OiB0XG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86Y29hc3QpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9mb2N1cy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdGb2N1cydcbiAgICAgICAgLCBmb2N1czogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmZvY3VzKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC95YWJyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnWWFuZGV4IEJyb3dzZXInXG4gICAgICAsIHlhbmRleGJyb3dzZXI6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86eWFicm93c2VyKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvdWNicm93c2VyL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBuYW1lOiAnVUMgQnJvd3NlcidcbiAgICAgICAgLCB1Y2Jyb3dzZXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzp1Y2Jyb3dzZXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL214aW9zL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ01heHRob24nXG4gICAgICAgICwgbWF4dGhvbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om14aW9zKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9lcGlwaGFueS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdFcGlwaGFueSdcbiAgICAgICAgLCBlcGlwaGFueTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmVwaXBoYW55KVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9wdWZmaW4vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUHVmZmluJ1xuICAgICAgICAsIHB1ZmZpbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnB1ZmZpbilbXFxzXFwvXShcXGQrKD86XFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2xlaXBuaXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2xlaXBuaXInXG4gICAgICAgICwgc2xlaXBuaXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpzbGVpcG5pcilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvay1tZWxlb24vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnSy1NZWxlb24nXG4gICAgICAgICwga01lbGVvbjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmstbWVsZW9uKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvd3NwaG9uZSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnV2luZG93cyBQaG9uZSdcbiAgICAgICwgb3NuYW1lOiAnV2luZG93cyBQaG9uZSdcbiAgICAgICwgd2luZG93c3Bob25lOiB0XG4gICAgICB9XG4gICAgICBpZiAoZWRnZVZlcnNpb24pIHtcbiAgICAgICAgcmVzdWx0Lm1zZWRnZSA9IHRcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBlZGdlVmVyc2lvblxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5tc2llID0gdFxuICAgICAgICByZXN1bHQudmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2llbW9iaWxlXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvbXNpZXx0cmlkZW50L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0ludGVybmV0IEV4cGxvcmVyJ1xuICAgICAgLCBtc2llOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om1zaWUgfHJ2OikoXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaHJvbWVvcykge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21lJ1xuICAgICAgLCBvc25hbWU6ICdDaHJvbWUgT1MnXG4gICAgICAsIGNocm9tZW9zOiB0XG4gICAgICAsIGNocm9tZUJvb2s6IHRcbiAgICAgICwgY2hyb21lOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC9lZGcoW2VhXXxpb3MpL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ01pY3Jvc29mdCBFZGdlJ1xuICAgICAgLCBtc2VkZ2U6IHRcbiAgICAgICwgdmVyc2lvbjogZWRnZVZlcnNpb25cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3ZpdmFsZGkvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnVml2YWxkaSdcbiAgICAgICAgLCB2aXZhbGRpOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvdml2YWxkaVxcLyhcXGQrKFxcLlxcZCspPykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2FpbGZpc2gpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NhaWxmaXNoJ1xuICAgICAgLCBvc25hbWU6ICdTYWlsZmlzaCBPUydcbiAgICAgICwgc2FpbGZpc2g6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXHM/YnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NlYW1vbmtleVxcLy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTZWFNb25rZXknXG4gICAgICAsIHNlYW1vbmtleTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zZWFtb25rZXlcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9maXJlZm94fGljZXdlYXNlbHxmeGlvcy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdGaXJlZm94J1xuICAgICAgLCBmaXJlZm94OiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVsgXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICAgIGlmICgvXFwoKG1vYmlsZXx0YWJsZXQpO1teXFwpXSpydjpbXFxkXFwuXStcXCkvaS50ZXN0KHVhKSkge1xuICAgICAgICByZXN1bHQuZmlyZWZveG9zID0gdFxuICAgICAgICByZXN1bHQub3NuYW1lID0gJ0ZpcmVmb3ggT1MnXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpbGspIHtcbiAgICAgIHJlc3VsdCA9ICB7XG4gICAgICAgIG5hbWU6ICdBbWF6b24gU2lsaydcbiAgICAgICwgc2lsazogdFxuICAgICAgLCB2ZXJzaW9uIDogZ2V0Rmlyc3RNYXRjaCgvc2lsa1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3BoYW50b20vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUGhhbnRvbUpTJ1xuICAgICAgLCBwaGFudG9tOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3BoYW50b21qc1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NsaW1lcmpzL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NsaW1lckpTJ1xuICAgICAgICAsIHNsaW1lcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3NsaW1lcmpzXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaS50ZXN0KHVhKSB8fCAvcmltXFxzdGFibGV0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0JsYWNrQmVycnknXG4gICAgICAsIG9zbmFtZTogJ0JsYWNrQmVycnkgT1MnXG4gICAgICAsIGJsYWNrYmVycnk6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVtcXGRdK1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2Vib3MpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1dlYk9TJ1xuICAgICAgLCBvc25hbWU6ICdXZWJPUydcbiAgICAgICwgd2Vib3M6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9vc2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9O1xuICAgICAgL3RvdWNocGFkXFwvL2kudGVzdCh1YSkgJiYgKHJlc3VsdC50b3VjaHBhZCA9IHQpXG4gICAgfVxuICAgIGVsc2UgaWYgKC9iYWRhL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0JhZGEnXG4gICAgICAsIG9zbmFtZTogJ0JhZGEnXG4gICAgICAsIGJhZGE6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGl6ZW4pIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1RpemVuJ1xuICAgICAgLCBvc25hbWU6ICdUaXplbidcbiAgICAgICwgdGl6ZW46IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86dGl6ZW5cXHM/KT9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL3F1cHppbGxhL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1F1cFppbGxhJ1xuICAgICAgICAsIHF1cHppbGxhOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86cXVwemlsbGEpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2Nocm9taXVtL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0Nocm9taXVtJ1xuICAgICAgICAsIGNocm9taXVtOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21pdW0pW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspPykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2Nocm9tZXxjcmlvc3xjcm1vL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0Nocm9tZSdcbiAgICAgICAgLCBjaHJvbWU6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFuZHJvaWQpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0FuZHJvaWQnXG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NhZmFyaXxhcHBsZXdlYmtpdC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTYWZhcmknXG4gICAgICAsIHNhZmFyaTogdFxuICAgICAgfVxuICAgICAgaWYgKHZlcnNpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW9zZGV2aWNlKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWUgOiBpb3NkZXZpY2UgPT0gJ2lwaG9uZScgPyAnaVBob25lJyA6IGlvc2RldmljZSA9PSAnaXBhZCcgPyAnaVBhZCcgOiAnaVBvZCdcbiAgICAgIH1cbiAgICAgIC8vIFdURjogdmVyc2lvbiBpcyBub3QgcGFydCBvZiB1c2VyIGFnZW50IGluIHdlYiBhcHBzXG4gICAgICBpZiAodmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmKC9nb29nbGVib3QvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnR29vZ2xlYm90J1xuICAgICAgLCBnb29nbGVib3Q6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZ29vZ2xlYm90XFwvKFxcZCsoXFwuXFxkKykpL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiBnZXRGaXJzdE1hdGNoKC9eKC4qKVxcLyguKikgLyksXG4gICAgICAgIHZlcnNpb246IGdldFNlY29uZE1hdGNoKC9eKC4qKVxcLyguKikgLylcbiAgICAgfTtcbiAgIH1cblxuICAgIC8vIHNldCB3ZWJraXQgb3IgZ2Vja28gZmxhZyBmb3IgYnJvd3NlcnMgYmFzZWQgb24gdGhlc2UgZW5naW5lc1xuICAgIGlmICghcmVzdWx0Lm1zZWRnZSAmJiAvKGFwcGxlKT93ZWJraXQvaS50ZXN0KHVhKSkge1xuICAgICAgaWYgKC8oYXBwbGUpP3dlYmtpdFxcLzUzN1xcLjM2L2kudGVzdCh1YSkpIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIkJsaW5rXCJcbiAgICAgICAgcmVzdWx0LmJsaW5rID0gdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIldlYmtpdFwiXG4gICAgICAgIHJlc3VsdC53ZWJraXQgPSB0XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3VsdC52ZXJzaW9uICYmIHZlcnNpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFyZXN1bHQub3BlcmEgJiYgL2dlY2tvXFwvL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUgfHwgXCJHZWNrb1wiXG4gICAgICByZXN1bHQuZ2Vja28gPSB0XG4gICAgICByZXN1bHQudmVyc2lvbiA9IHJlc3VsdC52ZXJzaW9uIHx8IGdldEZpcnN0TWF0Y2goL2dlY2tvXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgIH1cblxuICAgIC8vIHNldCBPUyBmbGFncyBmb3IgcGxhdGZvcm1zIHRoYXQgaGF2ZSBtdWx0aXBsZSBicm93c2Vyc1xuICAgIGlmICghcmVzdWx0LndpbmRvd3NwaG9uZSAmJiAoYW5kcm9pZCB8fCByZXN1bHQuc2lsaykpIHtcbiAgICAgIHJlc3VsdC5hbmRyb2lkID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdBbmRyb2lkJ1xuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC53aW5kb3dzcGhvbmUgJiYgaW9zZGV2aWNlKSB7XG4gICAgICByZXN1bHRbaW9zZGV2aWNlXSA9IHRcbiAgICAgIHJlc3VsdC5pb3MgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ2lPUydcbiAgICB9IGVsc2UgaWYgKG1hYykge1xuICAgICAgcmVzdWx0Lm1hYyA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnbWFjT1MnXG4gICAgfSBlbHNlIGlmICh4Ym94KSB7XG4gICAgICByZXN1bHQueGJveCA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnWGJveCdcbiAgICB9IGVsc2UgaWYgKHdpbmRvd3MpIHtcbiAgICAgIHJlc3VsdC53aW5kb3dzID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdXaW5kb3dzJ1xuICAgIH0gZWxzZSBpZiAobGludXgpIHtcbiAgICAgIHJlc3VsdC5saW51eCA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnTGludXgnXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93c1ZlcnNpb24gKHMpIHtcbiAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlICdOVCc6IHJldHVybiAnTlQnXG4gICAgICAgIGNhc2UgJ1hQJzogcmV0dXJuICdYUCdcbiAgICAgICAgY2FzZSAnTlQgNS4wJzogcmV0dXJuICcyMDAwJ1xuICAgICAgICBjYXNlICdOVCA1LjEnOiByZXR1cm4gJ1hQJ1xuICAgICAgICBjYXNlICdOVCA1LjInOiByZXR1cm4gJzIwMDMnXG4gICAgICAgIGNhc2UgJ05UIDYuMCc6IHJldHVybiAnVmlzdGEnXG4gICAgICAgIGNhc2UgJ05UIDYuMSc6IHJldHVybiAnNydcbiAgICAgICAgY2FzZSAnTlQgNi4yJzogcmV0dXJuICc4J1xuICAgICAgICBjYXNlICdOVCA2LjMnOiByZXR1cm4gJzguMSdcbiAgICAgICAgY2FzZSAnTlQgMTAuMCc6IHJldHVybiAnMTAnXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPUyB2ZXJzaW9uIGV4dHJhY3Rpb25cbiAgICB2YXIgb3NWZXJzaW9uID0gJyc7XG4gICAgaWYgKHJlc3VsdC53aW5kb3dzKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRXaW5kb3dzVmVyc2lvbihnZXRGaXJzdE1hdGNoKC9XaW5kb3dzICgoTlR8WFApKCBcXGRcXGQ/LlxcZCk/KS9pKSlcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC53aW5kb3dzcGhvbmUpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3dpbmRvd3MgcGhvbmUgKD86b3MpP1xccz8oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0Lm1hYykge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvTWFjIE9TIFggKFxcZCsoW19cXC5cXHNdXFxkKykqKS9pKTtcbiAgICAgIG9zVmVyc2lvbiA9IG9zVmVyc2lvbi5yZXBsYWNlKC9bX1xcc10vZywgJy4nKTtcbiAgICB9IGVsc2UgaWYgKGlvc2RldmljZSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvb3MgKFxcZCsoW19cXHNdXFxkKykqKSBsaWtlIG1hYyBvcyB4L2kpO1xuICAgICAgb3NWZXJzaW9uID0gb3NWZXJzaW9uLnJlcGxhY2UoL1tfXFxzXS9nLCAnLicpO1xuICAgIH0gZWxzZSBpZiAoYW5kcm9pZCkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFsgXFwvLV0oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LndlYm9zKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC8oPzp3ZWJ8aHB3KW9zXFwvKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5ibGFja2JlcnJ5KSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9yaW1cXHN0YWJsZXRcXHNvc1xccyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuYmFkYSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYmFkYVxcLyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQudGl6ZW4pIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3RpemVuW1xcL1xcc10oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH1cbiAgICBpZiAob3NWZXJzaW9uKSB7XG4gICAgICByZXN1bHQub3N2ZXJzaW9uID0gb3NWZXJzaW9uO1xuICAgIH1cblxuICAgIC8vIGRldmljZSB0eXBlIGV4dHJhY3Rpb25cbiAgICB2YXIgb3NNYWpvclZlcnNpb24gPSAhcmVzdWx0LndpbmRvd3MgJiYgb3NWZXJzaW9uLnNwbGl0KCcuJylbMF07XG4gICAgaWYgKFxuICAgICAgICAgdGFibGV0XG4gICAgICB8fCBuZXh1c1RhYmxldFxuICAgICAgfHwgaW9zZGV2aWNlID09ICdpcGFkJ1xuICAgICAgfHwgKGFuZHJvaWQgJiYgKG9zTWFqb3JWZXJzaW9uID09IDMgfHwgKG9zTWFqb3JWZXJzaW9uID49IDQgJiYgIW1vYmlsZSkpKVxuICAgICAgfHwgcmVzdWx0LnNpbGtcbiAgICApIHtcbiAgICAgIHJlc3VsdC50YWJsZXQgPSB0XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgIG1vYmlsZVxuICAgICAgfHwgaW9zZGV2aWNlID09ICdpcGhvbmUnXG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwb2QnXG4gICAgICB8fCBhbmRyb2lkXG4gICAgICB8fCBuZXh1c01vYmlsZVxuICAgICAgfHwgcmVzdWx0LmJsYWNrYmVycnlcbiAgICAgIHx8IHJlc3VsdC53ZWJvc1xuICAgICAgfHwgcmVzdWx0LmJhZGFcbiAgICApIHtcbiAgICAgIHJlc3VsdC5tb2JpbGUgPSB0XG4gICAgfVxuXG4gICAgLy8gR3JhZGVkIEJyb3dzZXIgU3VwcG9ydFxuICAgIC8vIGh0dHA6Ly9kZXZlbG9wZXIueWFob28uY29tL3l1aS9hcnRpY2xlcy9nYnNcbiAgICBpZiAocmVzdWx0Lm1zZWRnZSB8fFxuICAgICAgICAocmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTApIHx8XG4gICAgICAgIChyZXN1bHQueWFuZGV4YnJvd3NlciAmJiByZXN1bHQudmVyc2lvbiA+PSAxNSkgfHxcblx0XHQgICAgKHJlc3VsdC52aXZhbGRpICYmIHJlc3VsdC52ZXJzaW9uID49IDEuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPj0gMjApIHx8XG4gICAgICAgIChyZXN1bHQuc2Ftc3VuZ0Jyb3dzZXIgJiYgcmVzdWx0LnZlcnNpb24gPj0gNCkgfHxcbiAgICAgICAgKHJlc3VsdC53aGFsZSAmJiBjb21wYXJlVmVyc2lvbnMoW3Jlc3VsdC52ZXJzaW9uLCAnMS4wJ10pID09PSAxKSB8fFxuICAgICAgICAocmVzdWx0Lm16YnJvd3NlciAmJiBjb21wYXJlVmVyc2lvbnMoW3Jlc3VsdC52ZXJzaW9uLCAnNi4wJ10pID09PSAxKSB8fFxuICAgICAgICAocmVzdWx0LmZvY3VzICYmIGNvbXBhcmVWZXJzaW9ucyhbcmVzdWx0LnZlcnNpb24sICcxLjAnXSkgPT09IDEpIHx8XG4gICAgICAgIChyZXN1bHQuZmlyZWZveCAmJiByZXN1bHQudmVyc2lvbiA+PSAyMC4wKSB8fFxuICAgICAgICAocmVzdWx0LnNhZmFyaSAmJiByZXN1bHQudmVyc2lvbiA+PSA2KSB8fFxuICAgICAgICAocmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uID49IDEwLjApIHx8XG4gICAgICAgIChyZXN1bHQuaW9zICYmIHJlc3VsdC5vc3ZlcnNpb24gJiYgcmVzdWx0Lm9zdmVyc2lvbi5zcGxpdChcIi5cIilbMF0gPj0gNikgfHxcbiAgICAgICAgKHJlc3VsdC5ibGFja2JlcnJ5ICYmIHJlc3VsdC52ZXJzaW9uID49IDEwLjEpXG4gICAgICAgIHx8IChyZXN1bHQuY2hyb21pdW0gJiYgcmVzdWx0LnZlcnNpb24gPj0gMjApXG4gICAgICAgICkge1xuICAgICAgcmVzdWx0LmEgPSB0O1xuICAgIH1cbiAgICBlbHNlIGlmICgocmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPCAxMCkgfHxcbiAgICAgICAgKHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPCAyMCkgfHxcbiAgICAgICAgKHJlc3VsdC5maXJlZm94ICYmIHJlc3VsdC52ZXJzaW9uIDwgMjAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5zYWZhcmkgJiYgcmVzdWx0LnZlcnNpb24gPCA2KSB8fFxuICAgICAgICAocmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uIDwgMTAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5pb3MgJiYgcmVzdWx0Lm9zdmVyc2lvbiAmJiByZXN1bHQub3N2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA8IDYpXG4gICAgICAgIHx8IChyZXN1bHQuY2hyb21pdW0gJiYgcmVzdWx0LnZlcnNpb24gPCAyMClcbiAgICAgICAgKSB7XG4gICAgICByZXN1bHQuYyA9IHRcbiAgICB9IGVsc2UgcmVzdWx0LnggPSB0XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB2YXIgYm93c2VyID0gZGV0ZWN0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJyA6ICcnKVxuXG4gIGJvd3Nlci50ZXN0ID0gZnVuY3Rpb24gKGJyb3dzZXJMaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicm93c2VyTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGJyb3dzZXJJdGVtID0gYnJvd3Nlckxpc3RbaV07XG4gICAgICBpZiAodHlwZW9mIGJyb3dzZXJJdGVtPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChicm93c2VySXRlbSBpbiBib3dzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHZlcnNpb24gcHJlY2lzaW9ucyBjb3VudFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGdldFZlcnNpb25QcmVjaXNpb24oXCIxLjEwLjNcIikgLy8gM1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZlcnNpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHZlcnNpb24uc3BsaXQoXCIuXCIpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcnJheTo6bWFwIHBvbHlmaWxsXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gbWFwKGFyciwgaXRlcmF0b3IpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIGk7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXApIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYXJyLCBpdGVyYXRvcik7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdG9yKGFycltpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBicm93c2VyIHZlcnNpb24gd2VpZ2h0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4xMC4yLjEnLCAgJzEuOC4yLjEuOTAnXSkgICAgLy8gMVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMDEwLjIuMScsICcxLjA5LjIuMS45MCddKTsgIC8vIDFcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS4xMC4yLjEnXSk7ICAgICAvLyAwXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4xMC4yLjEnLCAgJzEuMDgwMC4yJ10pOyAgICAgLy8gLTFcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gdmVyc2lvbnMgdmVyc2lvbnMgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBhcmlzb24gcmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModmVyc2lvbnMpIHtcbiAgICAvLyAxKSBnZXQgY29tbW9uIHByZWNpc2lvbiBmb3IgYm90aCB2ZXJzaW9ucywgZm9yIGV4YW1wbGUgZm9yIFwiMTAuMFwiIGFuZCBcIjlcIiBpdCBzaG91bGQgYmUgMlxuICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLm1heChnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb25zWzBdKSwgZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uc1sxXSkpO1xuICAgIHZhciBjaHVua3MgPSBtYXAodmVyc2lvbnMsIGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICB2YXIgZGVsdGEgPSBwcmVjaXNpb24gLSBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb24pO1xuXG4gICAgICAvLyAyKSBcIjlcIiAtPiBcIjkuMFwiIChmb3IgcHJlY2lzaW9uID0gMilcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uICsgbmV3IEFycmF5KGRlbHRhICsgMSkuam9pbihcIi4wXCIpO1xuXG4gICAgICAvLyAzKSBcIjkuMFwiIC0+IFtcIjAwMDAwMDAwMFwiXCIsIFwiMDAwMDAwMDA5XCJdXG4gICAgICByZXR1cm4gbWFwKHZlcnNpb24uc3BsaXQoXCIuXCIpLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgyMCAtIGNodW5rLmxlbmd0aCkuam9pbihcIjBcIikgKyBjaHVuaztcbiAgICAgIH0pLnJldmVyc2UoKTtcbiAgICB9KTtcblxuICAgIC8vIGl0ZXJhdGUgaW4gcmV2ZXJzZSBvcmRlciBieSByZXZlcnNlZCBjaHVua3MgYXJyYXlcbiAgICB3aGlsZSAoLS1wcmVjaXNpb24gPj0gMCkge1xuICAgICAgLy8gNCkgY29tcGFyZTogXCIwMDAwMDAwMDlcIiA+IFwiMDAwMDAwMDEwXCIgPSBmYWxzZSAoYnV0IFwiOVwiID4gXCIxMFwiID0gdHJ1ZSlcbiAgICAgIGlmIChjaHVua3NbMF1bcHJlY2lzaW9uXSA+IGNodW5rc1sxXVtwcmVjaXNpb25dKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2h1bmtzWzBdW3ByZWNpc2lvbl0gPT09IGNodW5rc1sxXVtwcmVjaXNpb25dKSB7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IDApIHtcbiAgICAgICAgICAvLyBhbGwgdmVyc2lvbiBjaHVua3MgYXJlIHNhbWVcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYnJvd3NlciBpcyB1bnN1cHBvcnRlZFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGJvd3Nlci5pc1Vuc3VwcG9ydGVkQnJvd3Nlcih7XG4gICAqICAgICBtc2llOiBcIjEwXCIsXG4gICAqICAgICBmaXJlZm94OiBcIjIzXCIsXG4gICAqICAgICBjaHJvbWU6IFwiMjlcIixcbiAgICogICAgIHNhZmFyaTogXCI1LjFcIixcbiAgICogICAgIG9wZXJhOiBcIjE2XCIsXG4gICAqICAgICBwaGFudG9tOiBcIjUzNFwiXG4gICAqICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG1pblZlcnNpb25zIG1hcCBvZiBtaW5pbWFsIHZlcnNpb24gdG8gYnJvd3NlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc3RyaWN0TW9kZSA9IGZhbHNlXSBmbGFnIHRvIHJldHVybiBmYWxzZSBpZiBicm93c2VyIHdhc24ndCBmb3VuZCBpbiBtYXBcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW3VhXSB1c2VyIGFnZW50IHN0cmluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEJyb3dzZXIobWluVmVyc2lvbnMsIHN0cmljdE1vZGUsIHVhKSB7XG4gICAgdmFyIF9ib3dzZXIgPSBib3dzZXI7XG5cbiAgICAvLyBtYWtlIHN0cmljdE1vZGUgcGFyYW0gb3B0aW9uYWwgd2l0aCB1YSBwYXJhbSB1c2FnZVxuICAgIGlmICh0eXBlb2Ygc3RyaWN0TW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVhID0gc3RyaWN0TW9kZTtcbiAgICAgIHN0cmljdE1vZGUgPSB2b2lkKDApO1xuICAgIH1cblxuICAgIGlmIChzdHJpY3RNb2RlID09PSB2b2lkKDApKSB7XG4gICAgICBzdHJpY3RNb2RlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh1YSkge1xuICAgICAgX2Jvd3NlciA9IGRldGVjdCh1YSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSBcIlwiICsgX2Jvd3Nlci52ZXJzaW9uO1xuICAgIGZvciAodmFyIGJyb3dzZXIgaW4gbWluVmVyc2lvbnMpIHtcbiAgICAgIGlmIChtaW5WZXJzaW9ucy5oYXNPd25Qcm9wZXJ0eShicm93c2VyKSkge1xuICAgICAgICBpZiAoX2Jvd3Nlclticm93c2VyXSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWluVmVyc2lvbnNbYnJvd3Nlcl0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgdmVyc2lvbiBpbiB0aGUgbWluVmVyc2lvbiBtYXAgc2hvdWxkIGJlIGEgc3RyaW5nOiAnICsgYnJvd3NlciArICc6ICcgKyBTdHJpbmcobWluVmVyc2lvbnMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBicm93c2VyIHZlcnNpb24gYW5kIG1pbiBzdXBwb3J0ZWQgdmVyc2lvbi5cbiAgICAgICAgICByZXR1cm4gY29tcGFyZVZlcnNpb25zKFt2ZXJzaW9uLCBtaW5WZXJzaW9uc1ticm93c2VyXV0pIDwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpY3RNb2RlOyAvLyBub3QgZm91bmRcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBicm93c2VyIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1pblZlcnNpb25zIG1hcCBvZiBtaW5pbWFsIHZlcnNpb24gdG8gYnJvd3NlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc3RyaWN0TW9kZSA9IGZhbHNlXSBmbGFnIHRvIHJldHVybiBmYWxzZSBpZiBicm93c2VyIHdhc24ndCBmb3VuZCBpbiBtYXBcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW3VhXSB1c2VyIGFnZW50IHN0cmluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2sobWluVmVyc2lvbnMsIHN0cmljdE1vZGUsIHVhKSB7XG4gICAgcmV0dXJuICFpc1Vuc3VwcG9ydGVkQnJvd3NlcihtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpO1xuICB9XG5cbiAgYm93c2VyLmlzVW5zdXBwb3J0ZWRCcm93c2VyID0gaXNVbnN1cHBvcnRlZEJyb3dzZXI7XG4gIGJvd3Nlci5jb21wYXJlVmVyc2lvbnMgPSBjb21wYXJlVmVyc2lvbnM7XG4gIGJvd3Nlci5jaGVjayA9IGNoZWNrO1xuXG4gIC8qXG4gICAqIFNldCBvdXIgZGV0ZWN0IG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0IHNvIHdlIGNhblxuICAgKiByZXVzZSBpdCB0byB0ZXN0IG90aGVyIHVzZXIgYWdlbnRzLlxuICAgKiBUaGlzIGlzIG5lZWRlZCB0byBpbXBsZW1lbnQgZnV0dXJlIHRlc3RzLlxuICAgKi9cbiAgYm93c2VyLl9kZXRlY3QgPSBkZXRlY3Q7XG5cbiAgLypcbiAgICogU2V0IG91ciBkZXRlY3QgcHVibGljIG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0XG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGltcGxlbWVudCBib3dzZXIgaW4gc2VydmVyIHNpZGVcbiAgICovXG4gIGJvd3Nlci5kZXRlY3QgPSBkZXRlY3Q7XG4gIHJldHVybiBib3dzZXJcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNldE1hdHJpeEFycmF5VHlwZSA9IHNldE1hdHJpeEFycmF5VHlwZTtcbmV4cG9ydHMudG9SYWRpYW4gPSB0b1JhZGlhbjtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5SQU5ET00gPSBleHBvcnRzLkFSUkFZX1RZUEUgPSBleHBvcnRzLkVQU0lMT04gPSB2b2lkIDA7XG5cbi8qKlxyXG4gKiBDb21tb24gdXRpbGl0aWVzXHJcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcclxuICovXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xudmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydHMuRVBTSUxPTiA9IEVQU0lMT047XG52YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnRzLkFSUkFZX1RZUEUgPSBBUlJBWV9UWVBFO1xudmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxyXG4gKi9cblxuZXhwb3J0cy5SQU5ET00gPSBSQU5ET007XG5cbmZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIGV4cG9ydHMuQVJSQVlfVFlQRSA9IEFSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcbi8qKlxyXG4gKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gRGVncmVlc1xyXG4gKi9cblxuZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbi8qKlxyXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJndW1lbnRzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSB2YWx1ZSwgd2l0aGluIGFuIGFic29sdXRlXHJcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3NcclxuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIHRlc3QuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn1cblxuaWYgKCFNYXRoLmh5cG90KSBNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgeSA9IDAsXG4gICAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgeSArPSBhcmd1bWVudHNbaV0gKiBhcmd1bWVudHNbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KHkpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52ZWM0ID0gZXhwb3J0cy52ZWMzID0gZXhwb3J0cy52ZWMyID0gZXhwb3J0cy5xdWF0MiA9IGV4cG9ydHMucXVhdCA9IGV4cG9ydHMubWF0NCA9IGV4cG9ydHMubWF0MyA9IGV4cG9ydHMubWF0MmQgPSBleHBvcnRzLm1hdDIgPSBleHBvcnRzLmdsTWF0cml4ID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5leHBvcnRzLmdsTWF0cml4ID0gZ2xNYXRyaXg7XG5cbnZhciBtYXQyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0Mi5qc1wiKSk7XG5cbmV4cG9ydHMubWF0MiA9IG1hdDI7XG5cbnZhciBtYXQyZCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL21hdDJkLmpzXCIpKTtcblxuZXhwb3J0cy5tYXQyZCA9IG1hdDJkO1xuXG52YXIgbWF0MyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL21hdDMuanNcIikpO1xuXG5leHBvcnRzLm1hdDMgPSBtYXQzO1xuXG52YXIgbWF0NCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL21hdDQuanNcIikpO1xuXG5leHBvcnRzLm1hdDQgPSBtYXQ0O1xuXG52YXIgcXVhdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3F1YXQuanNcIikpO1xuXG5leHBvcnRzLnF1YXQgPSBxdWF0O1xuXG52YXIgcXVhdDIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9xdWF0Mi5qc1wiKSk7XG5cbmV4cG9ydHMucXVhdDIgPSBxdWF0MjtcblxudmFyIHZlYzIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWMyLmpzXCIpKTtcblxuZXhwb3J0cy52ZWMyID0gdmVjMjtcblxudmFyIHZlYzMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWMzLmpzXCIpKTtcblxuZXhwb3J0cy52ZWMzID0gdmVjMztcblxudmFyIHZlYzQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi92ZWM0LmpzXCIpKTtcblxuZXhwb3J0cy52ZWM0ID0gdmVjNDtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy50cmFuc3Bvc2UgPSB0cmFuc3Bvc2U7XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbmV4cG9ydHMuYWRqb2ludCA9IGFkam9pbnQ7XG5leHBvcnRzLmRldGVybWluYW50ID0gZGV0ZXJtaW5hbnQ7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuZnJvbVJvdGF0aW9uID0gZnJvbVJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tU2NhbGluZyA9IGZyb21TY2FsaW5nO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmZyb2IgPSBmcm9iO1xuZXhwb3J0cy5MRFUgPSBMRFU7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhciA9IG11bHRpcGx5U2NhbGFyO1xuZXhwb3J0cy5tdWx0aXBseVNjYWxhckFuZEFkZCA9IG11bHRpcGx5U2NhbGFyQW5kQWRkO1xuZXhwb3J0cy5zdWIgPSBleHBvcnRzLm11bCA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDJ4MiBNYXRyaXhcclxuICogQG1vZHVsZSBtYXQyXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQyIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXQgQSBuZXcgMngyIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTEwO1xuICBvdXRbM10gPSBtMTE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlXG4gIC8vIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTEgPSBhWzFdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYTE7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGFbMV07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYTMgKiBkZXQ7XG4gIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgb3V0WzJdID0gLWEyICogZGV0O1xuICBvdXRbM10gPSBhMCAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIHZhciBhMCA9IGFbMF07XG4gIG91dFswXSA9IGFbM107XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBMRFUoTCwgRCwgVSwgYSkge1xuICBMWzJdID0gYVsyXSAvIGFbMF07XG4gIFVbMF0gPSBhWzBdO1xuICBVWzFdID0gYVsxXTtcbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTtcbiAgcmV0dXJuIFtMLCBELCBVXTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDIncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzdWIgPSBzdWJ0cmFjdDtcbmV4cG9ydHMuc3ViID0gc3ViOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbmV4cG9ydHMuZGV0ZXJtaW5hbnQgPSBkZXRlcm1pbmFudDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLmZyb21Sb3RhdGlvbiA9IGZyb21Sb3RhdGlvbjtcbmV4cG9ydHMuZnJvbVNjYWxpbmcgPSBmcm9tU2NhbGluZztcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmZyb2IgPSBmcm9iO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyID0gbXVsdGlwbHlTY2FsYXI7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gbXVsdGlwbHlTY2FsYXJBbmRBZGQ7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuc3ViID0gZXhwb3J0cy5tdWwgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiAyeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0MmRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XHJcbiAqIDxwcmU+XHJcbiAqIFthLCBiLFxyXG4gKiAgYywgZCxcclxuICogIHR4LCB0eV1cclxuICogPC9wcmU+XHJcbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcclxuICogPHByZT5cclxuICogW2EsIGIsIDAsXHJcbiAqICBjLCBkLCAwLFxyXG4gKiAgdHgsIHR5LCAxXVxyXG4gKiA8L3ByZT5cclxuICogVGhlIGxhc3QgY29sdW1uIGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJkXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDJkIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQyZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MmQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYWEgPSBhWzBdLFxuICAgICAgYWIgPSBhWzFdLFxuICAgICAgYWMgPSBhWzJdLFxuICAgICAgYWQgPSBhWzNdO1xuICB2YXIgYXR4ID0gYVs0XSxcbiAgICAgIGF0eSA9IGFbNV07XG4gIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV07XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICBvdXRbNF0gPSBhMCAqIGI0ICsgYTIgKiBiNSArIGE0O1xuICBvdXRbNV0gPSBhMSAqIGI0ICsgYTMgKiBiNSArIGE1O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGEwICogYyArIGEyICogcztcbiAgb3V0WzFdID0gYTEgKiBjICsgYTMgKiBzO1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDtcbiAgb3V0WzFdID0gYTE7XG4gIG91dFsyXSA9IGEyO1xuICBvdXRbM10gPSBhMztcbiAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IHZbMF07XG4gIG91dFs1XSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDJkKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgMSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MmQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MmQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzdWIgPSBzdWJ0cmFjdDtcbmV4cG9ydHMuc3ViID0gc3ViOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuZnJvbU1hdDQgPSBmcm9tTWF0NDtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5hZGpvaW50ID0gYWRqb2ludDtcbmV4cG9ydHMuZGV0ZXJtaW5hbnQgPSBkZXRlcm1pbmFudDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLmZyb21UcmFuc2xhdGlvbiA9IGZyb21UcmFuc2xhdGlvbjtcbmV4cG9ydHMuZnJvbVJvdGF0aW9uID0gZnJvbVJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tU2NhbGluZyA9IGZyb21TY2FsaW5nO1xuZXhwb3J0cy5mcm9tTWF0MmQgPSBmcm9tTWF0MmQ7XG5leHBvcnRzLmZyb21RdWF0ID0gZnJvbVF1YXQ7XG5leHBvcnRzLm5vcm1hbEZyb21NYXQ0ID0gbm9ybWFsRnJvbU1hdDQ7XG5leHBvcnRzLnByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmZyb2IgPSBmcm9iO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyID0gbXVsdGlwbHlTY2FsYXI7XG5leHBvcnRzLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gbXVsdGlwbHlTY2FsYXJBbmRBZGQ7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuc3ViID0gZXhwb3J0cy5tdWwgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiAzeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0M1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVs0XTtcbiAgb3V0WzRdID0gYVs1XTtcbiAgb3V0WzVdID0gYVs2XTtcbiAgb3V0WzZdID0gYVs4XTtcbiAgb3V0WzddID0gYVs5XTtcbiAgb3V0WzhdID0gYVsxMF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyhtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0xMDtcbiAgb3V0WzRdID0gbTExO1xuICBvdXRbNV0gPSBtMTI7XG4gIG91dFs2XSA9IG0yMDtcbiAgb3V0WzddID0gbTIxO1xuICBvdXRbOF0gPSBtMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTEyID0gYVs1XTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYTAxO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYTAyO1xuICAgIG91dFs3XSA9IGExMjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhWzFdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhWzJdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XG4gIHZhciBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICB2YXIgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gIG91dFszXSA9IGIxMSAqIGRldDtcbiAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgb3V0WzZdID0gYjIxICogZGV0O1xuICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIG91dFswXSA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgb3V0WzFdID0gYTAyICogYTIxIC0gYTAxICogYTIyO1xuICBvdXRbMl0gPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIG91dFszXSA9IGExMiAqIGEyMCAtIGExMCAqIGEyMjtcbiAgb3V0WzRdID0gYTAwICogYTIyIC0gYTAyICogYTIwO1xuICBvdXRbNV0gPSBhMDIgKiBhMTAgLSBhMDAgKiBhMTI7XG4gIG91dFs2XSA9IGExMCAqIGEyMSAtIGExMSAqIGEyMDtcbiAgb3V0WzddID0gYTAxICogYTIwIC0gYTAwICogYTIxO1xuICBvdXRbOF0gPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDAgPSBiWzBdLFxuICAgICAgYjAxID0gYlsxXSxcbiAgICAgIGIwMiA9IGJbMl07XG4gIHZhciBiMTAgPSBiWzNdLFxuICAgICAgYjExID0gYls0XSxcbiAgICAgIGIxMiA9IGJbNV07XG4gIHZhciBiMjAgPSBiWzZdLFxuICAgICAgYjIxID0gYls3XSxcbiAgICAgIGIyMiA9IGJbOF07XG4gIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG4gIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG4gIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDA7XG4gIG91dFsxXSA9IGEwMTtcbiAgb3V0WzJdID0gYTAyO1xuICBvdXRbM10gPSBhMTA7XG4gIG91dFs0XSA9IGExMTtcbiAgb3V0WzVdID0gYTEyO1xuICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcbiAgb3V0WzZdID0gYTIwO1xuICBvdXRbN10gPSBhMjE7XG4gIG91dFs4XSA9IGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IHggKiBhWzBdO1xuICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgb3V0WzJdID0geCAqIGFbMl07XG4gIG91dFszXSA9IHkgKiBhWzNdO1xuICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgb3V0WzVdID0geSAqIGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSB2WzBdO1xuICBvdXRbN10gPSB2WzFdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IC1zO1xuICBvdXRbNF0gPSBjO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB2WzFdO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQyZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gYVsyXTtcbiAgb3V0WzRdID0gYVszXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gYVs0XTtcbiAgb3V0WzddID0gYVs1XTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhdChvdXQsIHEpIHtcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB5eCA9IHkgKiB4MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgenggPSB6ICogeDI7XG4gIHZhciB6eSA9IHogKiB5MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgb3V0WzNdID0geXggLSB3ejtcbiAgb3V0WzZdID0genggKyB3eTtcbiAgb3V0WzFdID0geXggKyB3ejtcbiAgb3V0WzRdID0gMSAtIHh4IC0geno7XG4gIG91dFs3XSA9IHp5IC0gd3g7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFs1XSA9IHp5ICsgd3g7XG4gIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsRnJvbU1hdDQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIDJEIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB5b3VyIGdsIGNvbnRleHRcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZ2wgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHByb2plY3Rpb24ob3V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIG91dFswXSA9IDIgLyB3aWR0aDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLTIgLyBoZWlnaHQ7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IC0xO1xuICBvdXRbN10gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIsIFwiICsgYVs4XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCBhWzZdLCBhWzddLCBhWzhdKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQzJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQzJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddLFxuICAgICAgYTggPSBhWzhdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddLFxuICAgICAgYjggPSBiWzhdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBzdWIgPSBzdWJ0cmFjdDtcbmV4cG9ydHMuc3ViID0gc3ViOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5hZGpvaW50ID0gYWRqb2ludDtcbmV4cG9ydHMuZGV0ZXJtaW5hbnQgPSBkZXRlcm1pbmFudDtcbmV4cG9ydHMubXVsdGlwbHkgPSBtdWx0aXBseTtcbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLnJvdGF0ZVggPSByb3RhdGVYO1xuZXhwb3J0cy5yb3RhdGVZID0gcm90YXRlWTtcbmV4cG9ydHMucm90YXRlWiA9IHJvdGF0ZVo7XG5leHBvcnRzLmZyb21UcmFuc2xhdGlvbiA9IGZyb21UcmFuc2xhdGlvbjtcbmV4cG9ydHMuZnJvbVNjYWxpbmcgPSBmcm9tU2NhbGluZztcbmV4cG9ydHMuZnJvbVJvdGF0aW9uID0gZnJvbVJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tWFJvdGF0aW9uID0gZnJvbVhSb3RhdGlvbjtcbmV4cG9ydHMuZnJvbVlSb3RhdGlvbiA9IGZyb21ZUm90YXRpb247XG5leHBvcnRzLmZyb21aUm90YXRpb24gPSBmcm9tWlJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tUXVhdDIgPSBmcm9tUXVhdDI7XG5leHBvcnRzLmdldFRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb247XG5leHBvcnRzLmdldFNjYWxpbmcgPSBnZXRTY2FsaW5nO1xuZXhwb3J0cy5nZXRSb3RhdGlvbiA9IGdldFJvdGF0aW9uO1xuZXhwb3J0cy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZTtcbmV4cG9ydHMuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiA9IGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW47XG5leHBvcnRzLmZyb21RdWF0ID0gZnJvbVF1YXQ7XG5leHBvcnRzLmZydXN0dW0gPSBmcnVzdHVtO1xuZXhwb3J0cy5wZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlO1xuZXhwb3J0cy5wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyA9IHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3O1xuZXhwb3J0cy5vcnRobyA9IG9ydGhvO1xuZXhwb3J0cy5sb29rQXQgPSBsb29rQXQ7XG5leHBvcnRzLnRhcmdldFRvID0gdGFyZ2V0VG87XG5leHBvcnRzLnN0ciA9IHN0cjtcbmV4cG9ydHMuZnJvYiA9IGZyb2I7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc3VidHJhY3QgPSBzdWJ0cmFjdDtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXIgPSBtdWx0aXBseVNjYWxhcjtcbmV4cG9ydHMubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBtdWx0aXBseVNjYWxhckFuZEFkZDtcbmV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleGFjdEVxdWFscztcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5zdWIgPSBleHBvcnRzLm11bCA9IHZvaWQgMDtcblxudmFyIGdsTWF0cml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLyoqXHJcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxyXG4gKiBAbW9kdWxlIG1hdDRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcclxuICpcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICB2YXIgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIG91dFswXSA9IGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKTtcbiAgb3V0WzFdID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICBvdXRbMl0gPSBhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFszXSA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzRdID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICBvdXRbNV0gPSBhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMik7XG4gIG91dFs2XSA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzddID0gYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbOF0gPSBhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSk7XG4gIG91dFs5XSA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgb3V0WzEwXSA9IGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKTtcbiAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgb3V0WzEzXSA9IGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKTtcbiAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgb3V0WzE1XSA9IGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07IC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuXG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbMV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzJdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFszXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbNF07XG4gIGIxID0gYls1XTtcbiAgYjIgPSBiWzZdO1xuICBiMyA9IGJbN107XG4gIG91dFs0XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbNV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzZdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFs3XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbOF07XG4gIGIxID0gYls5XTtcbiAgYjIgPSBiWzEwXTtcbiAgYjMgPSBiWzExXTtcbiAgb3V0WzhdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs5XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMTBdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFsxMV0gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzEyXTtcbiAgYjEgPSBiWzEzXTtcbiAgYjIgPSBiWzE0XTtcbiAgYjMgPSBiWzE1XTtcbiAgb3V0WzEyXSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbMTNdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxNF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzE1XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICB2YXIgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICB2YXIgYTEwLCBhMTEsIGExMiwgYTEzO1xuICB2YXIgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gIGlmIChhID09PSBvdXQpIHtcbiAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgfSBlbHNlIHtcbiAgICBhMDAgPSBhWzBdO1xuICAgIGEwMSA9IGFbMV07XG4gICAgYTAyID0gYVsyXTtcbiAgICBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07XG4gICAgYTExID0gYVs1XTtcbiAgICBhMTIgPSBhWzZdO1xuICAgIGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTtcbiAgICBhMjEgPSBhWzldO1xuICAgIGEyMiA9IGFbMTBdO1xuICAgIGEyMyA9IGFbMTFdO1xuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuICAgIG91dFszXSA9IGEwMztcbiAgICBvdXRbNF0gPSBhMTA7XG4gICAgb3V0WzVdID0gYTExO1xuICAgIG91dFs2XSA9IGExMjtcbiAgICBvdXRbN10gPSBhMTM7XG4gICAgb3V0WzhdID0gYTIwO1xuICAgIG91dFs5XSA9IGEyMTtcbiAgICBvdXRbMTBdID0gYTIyO1xuICAgIG91dFsxMV0gPSBhMjM7XG4gICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICoqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgICB5ID0gYXhpc1sxXSxcbiAgICAgIHogPSBheGlzWzJdO1xuICB2YXIgbGVuID0gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbiAgdmFyIHMsIGMsIHQ7XG4gIHZhciBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIHZhciBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIHZhciBhMjAsIGEyMSwgYTIyLCBhMjM7XG4gIHZhciBiMDAsIGIwMSwgYjAyO1xuICB2YXIgYjEwLCBiMTEsIGIxMjtcbiAgdmFyIGIyMCwgYjIxLCBiMjI7XG5cbiAgaWYgKGxlbiA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjO1xuICBhMDAgPSBhWzBdO1xuICBhMDEgPSBhWzFdO1xuICBhMDIgPSBhWzJdO1xuICBhMDMgPSBhWzNdO1xuICBhMTAgPSBhWzRdO1xuICBhMTEgPSBhWzVdO1xuICBhMTIgPSBhWzZdO1xuICBhMTMgPSBhWzddO1xuICBhMjAgPSBhWzhdO1xuICBhMjEgPSBhWzldO1xuICBhMjIgPSBhWzEwXTtcbiAgYTIzID0gYVsxMV07IC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuXG4gIGIwMCA9IHggKiB4ICogdCArIGM7XG4gIGIwMSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIGIxMSA9IHkgKiB5ICogdCArIGM7XG4gIGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICBiMjAgPSB4ICogeiAqIHQgKyB5ICogcztcbiAgYjIxID0geSAqIHogKiB0IC0geCAqIHM7XG4gIGIyMiA9IHogKiB6ICogdCArIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF07XG4gIHZhciBhMjEgPSBhWzldO1xuICB2YXIgYTIyID0gYVsxMF07XG4gIHZhciBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XTtcbiAgdmFyIGExMSA9IGFbNV07XG4gIHZhciBhMTIgPSBhWzZdO1xuICB2YXIgYTEzID0gYVs3XTtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHYpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgICB5ID0gYXhpc1sxXSxcbiAgICAgIHogPSBheGlzWzJdO1xuICB2YXIgbGVuID0gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbiAgdmFyIHMsIGMsIHQ7XG5cbiAgaWYgKGxlbiA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjOyAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IHggKiB4ICogdCArIGM7XG4gIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIG91dFs1XSA9IHkgKiB5ICogdCArIGM7XG4gIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogcztcbiAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHM7XG4gIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21YUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAtcztcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tWlJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLXM7XG4gIG91dFs1XSA9IGM7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBsZXQgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgb3V0WzFdID0geHkgKyB3ejtcbiAgb3V0WzJdID0geHogLSB3eTtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geHkgLSB3ejtcbiAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgb3V0WzZdID0geXogKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geHogKyB3eTtcbiAgb3V0WzldID0geXogLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXTtcbiAgb3V0WzEzXSA9IHZbMV07XG4gIG91dFsxNF0gPSB2WzJdO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgZnJvbSBhIGR1YWwgcXVhdC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgTWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybnMge21hdDR9IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVF1YXQyKG91dCwgYSkge1xuICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgdmFyIG1hZ25pdHVkZSA9IGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiArIGJ3ICogYnc7IC8vT25seSBzY2FsZSBpZiBpdCBtYWtlcyBzZW5zZVxuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDIgLyBtYWduaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIH1cblxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIGEsIHRyYW5zbGF0aW9uKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cclxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcclxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cclxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlXHJcbiAqICB3aXRoIGEgbm9ybWFsaXplZCBRdWF0ZXJuaW9uIHBhcmFtdGVyLCB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmVcclxuICogIHRoZSBzYW1lIGFzIHRoZSBzY2FsaW5nIHZlY3RvclxyXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cclxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXHJcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTY2FsaW5nKG91dCwgbWF0KSB7XG4gIHZhciBtMTEgPSBtYXRbMF07XG4gIHZhciBtMTIgPSBtYXRbMV07XG4gIHZhciBtMTMgPSBtYXRbMl07XG4gIHZhciBtMjEgPSBtYXRbNF07XG4gIHZhciBtMjIgPSBtYXRbNV07XG4gIHZhciBtMjMgPSBtYXRbNl07XG4gIHZhciBtMzEgPSBtYXRbOF07XG4gIHZhciBtMzIgPSBtYXRbOV07XG4gIHZhciBtMzMgPSBtYXRbMTBdO1xuICBvdXRbMF0gPSBNYXRoLmh5cG90KG0xMSwgbTEyLCBtMTMpO1xuICBvdXRbMV0gPSBNYXRoLmh5cG90KG0yMSwgbTIyLCBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLmh5cG90KG0zMSwgbTMyLCBtMzMpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcclxuICogIG9mIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoXHJcbiAqICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbiwgdGhlIHJldHVybmVkIHF1YXRlcm5pb24gd2lsbCBiZSB0aGVcclxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cclxuICogQHBhcmFtIHtxdWF0fSBvdXQgUXVhdGVybmlvbiB0byByZWNlaXZlIHRoZSByb3RhdGlvbiBjb21wb25lbnRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXHJcbiAqIEByZXR1cm4ge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsIG1hdCkge1xuICB2YXIgc2NhbGluZyA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBnZXRTY2FsaW5nKHNjYWxpbmcsIG1hdCk7XG4gIHZhciBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgdmFyIGlzMiA9IDEgLyBzY2FsaW5nWzFdO1xuICB2YXIgaXMzID0gMSAvIHNjYWxpbmdbMl07XG4gIHZhciBzbTExID0gbWF0WzBdICogaXMxO1xuICB2YXIgc20xMiA9IG1hdFsxXSAqIGlzMjtcbiAgdmFyIHNtMTMgPSBtYXRbMl0gKiBpczM7XG4gIHZhciBzbTIxID0gbWF0WzRdICogaXMxO1xuICB2YXIgc20yMiA9IG1hdFs1XSAqIGlzMjtcbiAgdmFyIHNtMjMgPSBtYXRbNl0gKiBpczM7XG4gIHZhciBzbTMxID0gbWF0WzhdICogaXMxO1xuICB2YXIgc20zMiA9IG1hdFs5XSAqIGlzMjtcbiAgdmFyIHNtMzMgPSBtYXRbMTBdICogaXMzO1xuICB2YXIgdHJhY2UgPSBzbTExICsgc20yMiArIHNtMzM7XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFsyXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICB9IGVsc2UgaWYgKHNtMTEgPiBzbTIyICYmIHNtMTEgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICBvdXRbM10gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgICBvdXRbMF0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKG91dCwgcSwgdiwgcykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlT3JpZ2luKG91dCwgcSwgdiwgcywgbykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICB2YXIgb3ggPSBvWzBdO1xuICB2YXIgb3kgPSBvWzFdO1xuICB2YXIgb3ogPSBvWzJdO1xuICB2YXIgb3V0MCA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICB2YXIgb3V0MSA9ICh4eSArIHd6KSAqIHN4O1xuICB2YXIgb3V0MiA9ICh4eiAtIHd5KSAqIHN4O1xuICB2YXIgb3V0NCA9ICh4eSAtIHd6KSAqIHN5O1xuICB2YXIgb3V0NSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICB2YXIgb3V0NiA9ICh5eiArIHd4KSAqIHN5O1xuICB2YXIgb3V0OCA9ICh4eiArIHd5KSAqIHN6O1xuICB2YXIgb3V0OSA9ICh5eiAtIHd4KSAqIHN6O1xuICB2YXIgb3V0MTAgPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgb3V0WzZdID0gb3V0NjtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gb3V0ODtcbiAgb3V0WzldID0gb3V0OTtcbiAgb3V0WzEwXSA9IG91dDEwO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF0gKyBveCAtIChvdXQwICogb3ggKyBvdXQ0ICogb3kgKyBvdXQ4ICogb3opO1xuICBvdXRbMTNdID0gdlsxXSArIG95IC0gKG91dDEgKiBveCArIG91dDUgKiBveSArIG91dDkgKiBveik7XG4gIG91dFsxNF0gPSB2WzJdICsgb3ogLSAob3V0MiAqIG94ICsgb3V0NiAqIG95ICsgb3V0MTAgKiBveik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZydXN0dW0ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XG4gIHZhciB0YiA9IDEgLyAodG9wIC0gYm90dG9tKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gbmVhciAqIDIgKiBybDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gbmVhciAqIDIgKiB0YjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IGZhciAqIG5lYXIgKiAyICogbmY7XG4gIG91dFsxNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cclxuICogUGFzc2luZyBudWxsL3VuZGVmaW5lZC9ubyB2YWx1ZSBmb3IgZmFyIHdpbGwgZ2VuZXJhdGUgaW5maW5pdGUgcHJvamVjdGlvbiBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW0sIGNhbiBiZSBudWxsIG9yIEluZmluaXR5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgIG5mO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE1XSA9IDA7XG5cbiAgaWYgKGZhciAhPSBudWxsICYmIGZhciAhPT0gSW5maW5pdHkpIHtcbiAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNF0gPSAyICogZmFyICogbmVhciAqIG5mO1xuICB9IGVsc2Uge1xuICAgIG91dFsxMF0gPSAtMTtcbiAgICBvdXRbMTRdID0gLTIgKiBuZWFyO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxyXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXHJcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICB2YXIgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjU7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBvcnRobyhvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTtcbiAgdmFyIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSAtMiAqIGxyO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAtMiAqIGJ0O1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMiAqIG5mO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzLlxyXG4gKiBJZiB5b3Ugd2FudCBhIG1hdHJpeCB0aGF0IGFjdHVhbGx5IG1ha2VzIGFuIG9iamVjdCBsb29rIGF0IGFub3RoZXIgb2JqZWN0LCB5b3Ugc2hvdWxkIHVzZSB0YXJnZXRUbyBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuO1xuICB2YXIgZXlleCA9IGV5ZVswXTtcbiAgdmFyIGV5ZXkgPSBleWVbMV07XG4gIHZhciBleWV6ID0gZXllWzJdO1xuICB2YXIgdXB4ID0gdXBbMF07XG4gIHZhciB1cHkgPSB1cFsxXTtcbiAgdmFyIHVweiA9IHVwWzJdO1xuICB2YXIgY2VudGVyeCA9IGNlbnRlclswXTtcbiAgdmFyIGNlbnRlcnkgPSBjZW50ZXJbMV07XG4gIHZhciBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBpZGVudGl0eShvdXQpO1xuICB9XG5cbiAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgejIgPSBleWV6IC0gY2VudGVyejtcbiAgbGVuID0gMSAvIE1hdGguaHlwb3QoejAsIHoxLCB6Mik7XG4gIHowICo9IGxlbjtcbiAgejEgKj0gbGVuO1xuICB6MiAqPSBsZW47XG4gIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeDAsIHgxLCB4Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB4MCA9IDA7XG4gICAgeDEgPSAwO1xuICAgIHgyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHgwICo9IGxlbjtcbiAgICB4MSAqPSBsZW47XG4gICAgeDIgKj0gbGVuO1xuICB9XG5cbiAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgbGVuID0gTWF0aC5oeXBvdCh5MCwgeTEsIHkyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHkwID0gMDtcbiAgICB5MSA9IDA7XG4gICAgeTIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeTAgKj0gbGVuO1xuICAgIHkxICo9IGxlbjtcbiAgICB5MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geTA7XG4gIG91dFsyXSA9IHowO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4MTtcbiAgb3V0WzVdID0geTE7XG4gIG91dFs2XSA9IHoxO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4MjtcbiAgb3V0WzldID0geTI7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG1hdHJpeCB0aGF0IG1ha2VzIHNvbWV0aGluZyBsb29rIGF0IHNvbWV0aGluZyBlbHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gIHZhciBleWV4ID0gZXllWzBdLFxuICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICB1cHggPSB1cFswXSxcbiAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgdXB6ID0gdXBbMl07XG4gIHZhciB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG4gIHZhciBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cblxuICB2YXIgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cblxuZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0NChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIsIFwiICsgYVs4XSArIFwiLCBcIiArIGFbOV0gKyBcIiwgXCIgKyBhWzEwXSArIFwiLCBcIiArIGFbMTFdICsgXCIsIFwiICsgYVsxMl0gKyBcIiwgXCIgKyBhWzEzXSArIFwiLCBcIiArIGFbMTRdICsgXCIsIFwiICsgYVsxNV0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSwgYVs5XSwgYVsxMF0sIGFbMTFdLCBhWzEyXSwgYVsxM10sIGFbMTRdLCBhWzE1XSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0NCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgb3V0WzldID0gYVs5XSAqIGI7XG4gIG91dFsxMF0gPSBhWzEwXSAqIGI7XG4gIG91dFsxMV0gPSBhWzExXSAqIGI7XG4gIG91dFsxMl0gPSBhWzEyXSAqIGI7XG4gIG91dFsxM10gPSBhWzEzXSAqIGI7XG4gIG91dFsxNF0gPSBhWzE0XSAqIGI7XG4gIG91dFsxNV0gPSBhWzE1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0NCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdICYmIGFbOV0gPT09IGJbOV0gJiYgYVsxMF0gPT09IGJbMTBdICYmIGFbMTFdID09PSBiWzExXSAmJiBhWzEyXSA9PT0gYlsxMl0gJiYgYVsxM10gPT09IGJbMTNdICYmIGFbMTRdID09PSBiWzE0XSAmJiBhWzE1XSA9PT0gYlsxNV07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddO1xuICB2YXIgYTggPSBhWzhdLFxuICAgICAgYTkgPSBhWzldLFxuICAgICAgYTEwID0gYVsxMF0sXG4gICAgICBhMTEgPSBhWzExXTtcbiAgdmFyIGExMiA9IGFbMTJdLFxuICAgICAgYTEzID0gYVsxM10sXG4gICAgICBhMTQgPSBhWzE0XSxcbiAgICAgIGExNSA9IGFbMTVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICB2YXIgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddO1xuICB2YXIgYjggPSBiWzhdLFxuICAgICAgYjkgPSBiWzldLFxuICAgICAgYjEwID0gYlsxMF0sXG4gICAgICBiMTEgPSBiWzExXTtcbiAgdmFyIGIxMiA9IGJbMTJdLFxuICAgICAgYjEzID0gYlsxM10sXG4gICAgICBiMTQgPSBiWzE0XSxcbiAgICAgIGIxNSA9IGJbMTVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkgJiYgTWF0aC5hYnMoYTkgLSBiOSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTkpLCBNYXRoLmFicyhiOSkpICYmIE1hdGguYWJzKGExMCAtIGIxMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEwKSwgTWF0aC5hYnMoYjEwKSkgJiYgTWF0aC5hYnMoYTExIC0gYjExKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTEpLCBNYXRoLmFicyhiMTEpKSAmJiBNYXRoLmFicyhhMTIgLSBiMTIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMiksIE1hdGguYWJzKGIxMikpICYmIE1hdGguYWJzKGExMyAtIGIxMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEzKSwgTWF0aC5hYnMoYjEzKSkgJiYgTWF0aC5hYnMoYTE0IC0gYjE0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTQpLCBNYXRoLmFicyhiMTQpKSAmJiBNYXRoLmFicyhhMTUgLSBiMTUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNSksIE1hdGguYWJzKGIxNSkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgc3ViID0gc3VidHJhY3Q7XG5leHBvcnRzLnN1YiA9IHN1YjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnNldEF4aXNBbmdsZSA9IHNldEF4aXNBbmdsZTtcbmV4cG9ydHMuZ2V0QXhpc0FuZ2xlID0gZ2V0QXhpc0FuZ2xlO1xuZXhwb3J0cy5nZXRBbmdsZSA9IGdldEFuZ2xlO1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5yb3RhdGVYID0gcm90YXRlWDtcbmV4cG9ydHMucm90YXRlWSA9IHJvdGF0ZVk7XG5leHBvcnRzLnJvdGF0ZVogPSByb3RhdGVaO1xuZXhwb3J0cy5jYWxjdWxhdGVXID0gY2FsY3VsYXRlVztcbmV4cG9ydHMuZXhwID0gZXhwO1xuZXhwb3J0cy5sbiA9IGxuO1xuZXhwb3J0cy5wb3cgPSBwb3c7XG5leHBvcnRzLnNsZXJwID0gc2xlcnA7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5jb25qdWdhdGUgPSBjb25qdWdhdGU7XG5leHBvcnRzLmZyb21NYXQzID0gZnJvbU1hdDM7XG5leHBvcnRzLmZyb21FdWxlciA9IGZyb21FdWxlcjtcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5zZXRBeGVzID0gZXhwb3J0cy5zcWxlcnAgPSBleHBvcnRzLnJvdGF0aW9uVG8gPSBleHBvcnRzLmVxdWFscyA9IGV4cG9ydHMuZXhhY3RFcXVhbHMgPSBleHBvcnRzLm5vcm1hbGl6ZSA9IGV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gZXhwb3J0cy5sZW4gPSBleHBvcnRzLmxlbmd0aCA9IGV4cG9ydHMubGVycCA9IGV4cG9ydHMuZG90ID0gZXhwb3J0cy5zY2FsZSA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5hZGQgPSBleHBvcnRzLnNldCA9IGV4cG9ydHMuY29weSA9IGV4cG9ydHMuZnJvbVZhbHVlcyA9IGV4cG9ydHMuY2xvbmUgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbnZhciBtYXQzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWF0My5qc1wiKSk7XG5cbnZhciB2ZWMzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdmVjMy5qc1wiKSk7XG5cbnZhciB2ZWM0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdmVjNC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiBRdWF0ZXJuaW9uXHJcbiAqIEBtb2R1bGUgcXVhdFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxyXG4gKiB0aGVuIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiovXG5cblxuZnVuY3Rpb24gc2V0QXhpc0FuZ2xlKG91dCwgYXhpcywgcmFkKSB7XG4gIHJhZCA9IHJhZCAqIDAuNTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldHMgdGhlIHJvdGF0aW9uIGF4aXMgYW5kIGFuZ2xlIGZvciBhIGdpdmVuXHJcbiAqICBxdWF0ZXJuaW9uLiBJZiBhIHF1YXRlcm5pb24gaXMgY3JlYXRlZCB3aXRoXHJcbiAqICBzZXRBeGlzQW5nbGUsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lXHJcbiAqICB2YWx1ZXMgYXMgcHJvdmlkaWVkIGluIHRoZSBvcmlnaW5hbCBwYXJhbWV0ZXIgbGlzdFxyXG4gKiAgT1IgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdmFsdWVzLlxyXG4gKiBFeGFtcGxlOiBUaGUgcXVhdGVybmlvbiBmb3JtZWQgYnkgYXhpcyBbMCwgMCwgMV0gYW5kXHJcbiAqICBhbmdsZSAtOTAgaXMgdGhlIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5XHJcbiAqICBbMCwgMCwgMV0gYW5kIDI3MC4gVGhpcyBtZXRob2QgZmF2b3JzIHRoZSBsYXR0ZXIuXHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dF9heGlzICBWZWN0b3IgcmVjZWl2aW5nIHRoZSBheGlzIG9mIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdH0gcSAgICAgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgIEFuZ2xlLCBpbiByYWRpYW5zLCBvZiB0aGUgcm90YXRpb25cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0QXhpc0FuZ2xlKG91dF9heGlzLCBxKSB7XG4gIHZhciByYWQgPSBNYXRoLmFjb3MocVszXSkgKiAyLjA7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcblxuICBpZiAocyA+IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICBvdXRfYXhpc1swXSA9IHFbMF0gLyBzO1xuICAgIG91dF9heGlzWzFdID0gcVsxXSAvIHM7XG4gICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICBvdXRfYXhpc1swXSA9IDE7XG4gICAgb3V0X2F4aXNbMV0gPSAwO1xuICAgIG91dF9heGlzWzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiByYWQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgYW5ndWxhciBkaXN0YW5jZSBiZXR3ZWVuIHR3byB1bml0IHF1YXRlcm5pb25zXHJcbiAqXHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdH0gYSAgICAgT3JpZ2luIHVuaXQgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXR9IGIgICAgIERlc3RpbmF0aW9uIHVuaXQgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgYmV0d2VlbiB0aGUgdHdvIHF1YXRlcm5pb25zXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEFuZ2xlKGEsIGIpIHtcbiAgdmFyIGRvdHByb2R1Y3QgPSBkb3QoYSwgYik7XG4gIHJldHVybiBNYXRoLmFjb3MoMiAqIGRvdHByb2R1Y3QgKiBkb3Rwcm9kdWN0IC0gMSk7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXSxcbiAgICAgIGJ3ID0gYlszXTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ4ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieSA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnogPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cclxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cclxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY2FsY3VsYXRlVyhvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2YgYSB1bml0IHF1YXRlcm5pb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBleHAob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl0sXG4gICAgICB3ID0gYVszXTtcbiAgdmFyIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgdmFyIGV0ID0gTWF0aC5leHAodyk7XG4gIHZhciBzID0gciA+IDAgPyBldCAqIE1hdGguc2luKHIpIC8gciA6IDA7XG4gIG91dFswXSA9IHggKiBzO1xuICBvdXRbMV0gPSB5ICogcztcbiAgb3V0WzJdID0geiAqIHM7XG4gIG91dFszXSA9IGV0ICogTWF0aC5jb3Mocik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBhIHVuaXQgcXVhdGVybmlvbi5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIHRoZSBleHBvbmVudGlhbCBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxuKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdLFxuICAgICAgdyA9IGFbM107XG4gIHZhciByID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHZhciB0ID0gciA+IDAgPyBNYXRoLmF0YW4yKHIsIHcpIC8gciA6IDA7XG4gIG91dFswXSA9IHggKiB0O1xuICBvdXRbMV0gPSB5ICogdDtcbiAgb3V0WzJdID0geiAqIHQ7XG4gIG91dFszXSA9IDAuNSAqIE1hdGgubG9nKHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIHNjYWxhciBwb3dlciBvZiBhIHVuaXQgcXVhdGVybmlvbi5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIHRoZSBleHBvbmVudGlhbCBvZlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHF1YXRlcm5pb24gYnlcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBwb3cob3V0LCBhLCBiKSB7XG4gIGxuKG91dCwgYSk7XG4gIHNjYWxlKG91dCwgb3V0LCBiKTtcbiAgZXhwKG91dCwgb3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNsZXJwKG91dCwgYSwgYiwgdCkge1xuICAvLyBiZW5jaG1hcmtzOlxuICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgYncgPSBiWzNdO1xuICB2YXIgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7IC8vIGNhbGMgY29zaW5lXG5cbiAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3OyAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcblxuICBpZiAoY29zb20gPCAwLjApIHtcbiAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICBieCA9IC1ieDtcbiAgICBieSA9IC1ieTtcbiAgICBieiA9IC1iejtcbiAgICBidyA9IC1idztcbiAgfSAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG5cblxuICBpZiAoMS4wIC0gY29zb20gPiBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgb21lZ2EgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgIHNpbm9tID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgfSBlbHNlIHtcbiAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlXG4gICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgc2NhbGUxID0gdDtcbiAgfSAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG5cblxuICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB1bml0IHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcmFuZG9tKG91dCkge1xuICAvLyBJbXBsZW1lbnRhdGlvbiBvZiBodHRwOi8vcGxhbm5pbmcuY3MudWl1Yy5lZHUvbm9kZTE5OC5odG1sXG4gIC8vIFRPRE86IENhbGxpbmcgcmFuZG9tIDMgdGltZXMgaXMgcHJvYmFibHkgbm90IHRoZSBmYXN0ZXN0IHNvbHV0aW9uXG4gIHZhciB1MSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgdTIgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHUzID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciBzcXJ0MU1pbnVzVTEgPSBNYXRoLnNxcnQoMSAtIHUxKTtcbiAgdmFyIHNxcnRVMSA9IE1hdGguc3FydCh1MSk7XG4gIG91dFswXSA9IHNxcnQxTWludXNVMSAqIE1hdGguc2luKDIuMCAqIE1hdGguUEkgKiB1Mik7XG4gIG91dFsxXSA9IHNxcnQxTWludXNVMSAqIE1hdGguY29zKDIuMCAqIE1hdGguUEkgKiB1Mik7XG4gIG91dFsyXSA9IHNxcnRVMSAqIE1hdGguc2luKDIuMCAqIE1hdGguUEkgKiB1Myk7XG4gIG91dFszXSA9IHNxcnRVMSAqIE1hdGguY29zKDIuMCAqIE1hdGguUEkgKiB1Myk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xuICB2YXIgaW52RG90ID0gZG90ID8gMS4wIC8gZG90IDogMDsgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICBvdXRbMF0gPSAtYTAgKiBpbnZEb3Q7XG4gIG91dFsxXSA9IC1hMSAqIGludkRvdDtcbiAgb3V0WzJdID0gLWEyICogaW52RG90O1xuICBvdXRbM10gPSBhMyAqIGludkRvdDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XHJcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb25qdWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cclxuICpcclxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcclxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IG0gcm90YXRpb24gbWF0cml4XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21NYXQzKG91dCwgbSkge1xuICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgdmFyIGZSb290O1xuXG4gIGlmIChmVHJhY2UgPiAwLjApIHtcbiAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgZlJvb3QgPSBNYXRoLnNxcnQoZlRyYWNlICsgMS4wKTsgLy8gMndcblxuICAgIG91dFszXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7IC8vIDEvKDR3KVxuXG4gICAgb3V0WzBdID0gKG1bNV0gLSBtWzddKSAqIGZSb290O1xuICAgIG91dFsxXSA9IChtWzZdIC0gbVsyXSkgKiBmUm9vdDtcbiAgICBvdXRbMl0gPSAobVsxXSAtIG1bM10pICogZlJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgLy8gfHd8IDw9IDEvMlxuICAgIHZhciBpID0gMDtcbiAgICBpZiAobVs0XSA+IG1bMF0pIGkgPSAxO1xuICAgIGlmIChtWzhdID4gbVtpICogMyArIGldKSBpID0gMjtcbiAgICB2YXIgaiA9IChpICsgMSkgJSAzO1xuICAgIHZhciBrID0gKGkgKyAyKSAlIDM7XG4gICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpICogMyArIGldIC0gbVtqICogMyArIGpdIC0gbVtrICogMyArIGtdICsgMS4wKTtcbiAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgIG91dFszXSA9IChtW2ogKiAzICsga10gLSBtW2sgKiAzICsgal0pICogZlJvb3Q7XG4gICAgb3V0W2pdID0gKG1baiAqIDMgKyBpXSArIG1baSAqIDMgKyBqXSkgKiBmUm9vdDtcbiAgICBvdXRba10gPSAobVtrICogMyArIGldICsgbVtpICogMyArIGtdKSAqIGZSb290O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiBldWxlciBhbmdsZSB4LCB5LCB6LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHt4fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFggYXhpcyBpbiBkZWdyZWVzLlxyXG4gKiBAcGFyYW0ge3l9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWSBheGlzIGluIGRlZ3JlZXMuXHJcbiAqIEBwYXJhbSB7en0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBaIGF4aXMgaW4gZGVncmVlcy5cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbUV1bGVyKG91dCwgeCwgeSwgeikge1xuICB2YXIgaGFsZlRvUmFkID0gMC41ICogTWF0aC5QSSAvIDE4MC4wO1xuICB4ICo9IGhhbGZUb1JhZDtcbiAgeSAqPSBoYWxmVG9SYWQ7XG4gIHogKj0gaGFsZlRvUmFkO1xuICB2YXIgc3ggPSBNYXRoLnNpbih4KTtcbiAgdmFyIGN4ID0gTWF0aC5jb3MoeCk7XG4gIHZhciBzeSA9IE1hdGguc2luKHkpO1xuICB2YXIgY3kgPSBNYXRoLmNvcyh5KTtcbiAgdmFyIHN6ID0gTWF0aC5zaW4oeik7XG4gIHZhciBjeiA9IE1hdGguY29zKHopO1xuICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gIG91dFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgb3V0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICBvdXRbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInF1YXQoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIiwgXCIgKyBhWzNdICsgXCIpXCI7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgY2xvbmUgPSB2ZWM0LmNsb25lO1xuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG52YXIgZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZnJvbVZhbHVlcyA9IGZyb21WYWx1ZXM7XG52YXIgY29weSA9IHZlYzQuY29weTtcbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmNvcHkgPSBjb3B5O1xudmFyIHNldCA9IHZlYzQuc2V0O1xuLyoqXHJcbiAqIEFkZHMgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNldCA9IHNldDtcbnZhciBhZGQgPSB2ZWM0LmFkZDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5hZGQgPSBhZGQ7XG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgc2NhbGUgPSB2ZWM0LnNjYWxlO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG52YXIgZG90ID0gdmVjNC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRvdCA9IGRvdDtcbnZhciBsZXJwID0gdmVjNC5sZXJwO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydHMubGVycCA9IGxlcnA7XG52YXIgbGVuZ3RoID0gdmVjNC5sZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbnZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuID0gbGVuO1xudmFyIHNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gc3F1YXJlZExlbmd0aDtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckxlbiA9IHNxckxlbjtcbnZhciBub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIFRoZSBmaXJzdCBxdWF0ZXJuaW9uLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG52YXIgZXhhY3RFcXVhbHMgPSB2ZWM0LmV4YWN0RXF1YWxzO1xuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xudmFyIGVxdWFscyA9IHZlYzQuZXF1YWxzO1xuLyoqXHJcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcclxuICogdmVjdG9yIHRvIGFub3RoZXIuXHJcbiAqXHJcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcblxudmFyIHJvdGF0aW9uVG8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLCAwLCAwKTtcbiAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG5cbiAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICBpZiAodmVjMy5sZW4odG1wdmVjMykgPCAwLjAwMDAwMSkgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICBzZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgb3V0WzBdID0gMDtcbiAgICAgIG91dFsxXSA9IDA7XG4gICAgICBvdXRbMl0gPSAwO1xuICAgICAgb3V0WzNdID0gMTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgfVxuICB9O1xufSgpO1xuLyoqXHJcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuXG5leHBvcnRzLnJvdGF0aW9uVG8gPSByb3RhdGlvblRvO1xuXG52YXIgc3FsZXJwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGVtcDEgPSBjcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgc2xlcnAodGVtcDEsIGEsIGQsIHQpO1xuICAgIHNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBzbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpO1xuLyoqXHJcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXHJcbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxyXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cblxuZXhwb3J0cy5zcWxlcnAgPSBzcWxlcnA7XG5cbnZhciBzZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgIG1hdHJbNl0gPSByaWdodFsyXTtcbiAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgbWF0cls0XSA9IHVwWzFdO1xuICAgIG1hdHJbN10gPSB1cFsyXTtcbiAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgIG1hdHJbOF0gPSAtdmlld1syXTtcbiAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuc2V0QXhlcyA9IHNldEF4ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbmV4cG9ydHMuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMgPSBmcm9tUm90YXRpb25UcmFuc2xhdGlvblZhbHVlcztcbmV4cG9ydHMuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmcm9tUm90YXRpb25UcmFuc2xhdGlvbjtcbmV4cG9ydHMuZnJvbVRyYW5zbGF0aW9uID0gZnJvbVRyYW5zbGF0aW9uO1xuZXhwb3J0cy5mcm9tUm90YXRpb24gPSBmcm9tUm90YXRpb247XG5leHBvcnRzLmZyb21NYXQ0ID0gZnJvbU1hdDQ7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmdldER1YWwgPSBnZXREdWFsO1xuZXhwb3J0cy5zZXREdWFsID0gc2V0RHVhbDtcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZXhwb3J0cy5yb3RhdGVYID0gcm90YXRlWDtcbmV4cG9ydHMucm90YXRlWSA9IHJvdGF0ZVk7XG5leHBvcnRzLnJvdGF0ZVogPSByb3RhdGVaO1xuZXhwb3J0cy5yb3RhdGVCeVF1YXRBcHBlbmQgPSByb3RhdGVCeVF1YXRBcHBlbmQ7XG5leHBvcnRzLnJvdGF0ZUJ5UXVhdFByZXBlbmQgPSByb3RhdGVCeVF1YXRQcmVwZW5kO1xuZXhwb3J0cy5yb3RhdGVBcm91bmRBeGlzID0gcm90YXRlQXJvdW5kQXhpcztcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy5jb25qdWdhdGUgPSBjb25qdWdhdGU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLnNxckxlbiA9IGV4cG9ydHMuc3F1YXJlZExlbmd0aCA9IGV4cG9ydHMubGVuID0gZXhwb3J0cy5sZW5ndGggPSBleHBvcnRzLmRvdCA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5zZXRSZWFsID0gZXhwb3J0cy5nZXRSZWFsID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG52YXIgcXVhdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3F1YXQuanNcIikpO1xuXG52YXIgbWF0NCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL21hdDQuanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKipcclxuICogRHVhbCBRdWF0ZXJuaW9uPGJyPlxyXG4gKiBGb3JtYXQ6IFtyZWFsLCBkdWFsXTxicj5cclxuICogUXVhdGVybmlvbiBmb3JtYXQ6IFhZWlc8YnI+XHJcbiAqIE1ha2Ugc3VyZSB0byBoYXZlIG5vcm1hbGl6ZWQgZHVhbCBxdWF0ZXJuaW9ucywgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbnMgbWF5IG5vdCB3b3JrIGFzIGludGVuZGVkLjxicj5cclxuICogQG1vZHVsZSBxdWF0MlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gYSBuZXcgZHVhbCBxdWF0ZXJuaW9uIFtyZWFsIC0+IHJvdGF0aW9uLCBkdWFsIC0+IHRyYW5zbGF0aW9uXVxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgZHFbMF0gPSAwO1xuICAgIGRxWzFdID0gMDtcbiAgICBkcVsyXSA9IDA7XG4gICAgZHFbNF0gPSAwO1xuICAgIGRxWzVdID0gMDtcbiAgICBkcVs2XSA9IDA7XG4gICAgZHFbN10gPSAwO1xuICB9XG5cbiAgZHFbM10gPSAxO1xuICByZXR1cm4gZHE7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcbiAgZHFbMF0gPSBhWzBdO1xuICBkcVsxXSA9IGFbMV07XG4gIGRxWzJdID0gYVsyXTtcbiAgZHFbM10gPSBhWzNdO1xuICBkcVs0XSA9IGFbNF07XG4gIGRxWzVdID0gYVs1XTtcbiAgZHFbNl0gPSBhWzZdO1xuICBkcVs3XSA9IGFbN107XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGR1YWwgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgxIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejEgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFcgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTIgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoyIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MiBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG5ldyBkdWFsIHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIsIHcyKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IHgxO1xuICBkcVsxXSA9IHkxO1xuICBkcVsyXSA9IHoxO1xuICBkcVszXSA9IHcxO1xuICBkcVs0XSA9IHgyO1xuICBkcVs1XSA9IHkyO1xuICBkcVs2XSA9IHoyO1xuICBkcVs3XSA9IHcyO1xuICByZXR1cm4gZHE7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBkdWFsIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gdmFsdWVzIChxdWF0IGFuZCB0cmFuc2xhdGlvbilcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgxIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejEgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFcgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBYIGNvbXBvbmVudCAodHJhbnNsYXRpb24pXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudCAodHJhbnNsYXRpb24pXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MiBaIGNvbXBvbmVudCAodHJhbnNsYXRpb24pXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMoeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIHZhciBheCA9IHgyICogMC41LFxuICAgICAgYXkgPSB5MiAqIDAuNSxcbiAgICAgIGF6ID0gejIgKiAwLjU7XG4gIGRxWzRdID0gYXggKiB3MSArIGF5ICogejEgLSBheiAqIHkxO1xuICBkcVs1XSA9IGF5ICogdzEgKyBheiAqIHgxIC0gYXggKiB6MTtcbiAgZHFbNl0gPSBheiAqIHcxICsgYXggKiB5MSAtIGF5ICogeDE7XG4gIGRxWzddID0gLWF4ICogeDEgLSBheSAqIHkxIC0gYXogKiB6MTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb24gYW5kIGEgdHJhbnNsYXRpb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBub3JtYWxpemVkIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHQgdHJhbmxhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdCkge1xuICB2YXIgYXggPSB0WzBdICogMC41LFxuICAgICAgYXkgPSB0WzFdICogMC41LFxuICAgICAgYXogPSB0WzJdICogMC41LFxuICAgICAgYnggPSBxWzBdLFxuICAgICAgYnkgPSBxWzFdLFxuICAgICAgYnogPSBxWzJdLFxuICAgICAgYncgPSBxWzNdO1xuICBvdXRbMF0gPSBieDtcbiAgb3V0WzFdID0gYnk7XG4gIG91dFsyXSA9IGJ6O1xuICBvdXRbM10gPSBidztcbiAgb3V0WzRdID0gYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbNV0gPSBheSAqIGJ3ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFs2XSA9IGF6ICogYncgKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzddID0gLWF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgZHVhbCBxdWF0IGZyb20gYSB0cmFuc2xhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdCB0cmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21UcmFuc2xhdGlvbihvdXQsIHQpIHtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gdFswXSAqIDAuNTtcbiAgb3V0WzVdID0gdFsxXSAqIDAuNTtcbiAgb3V0WzZdID0gdFsyXSAqIDAuNTtcbiAgb3V0WzddID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgZHVhbCBxdWF0IGZyb20gYSBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHRoZSBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCBxKSB7XG4gIG91dFswXSA9IHFbMF07XG4gIG91dFsxXSA9IHFbMV07XG4gIG91dFsyXSA9IHFbMl07XG4gIG91dFszXSA9IHFbM107XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBkdWFsIHF1YXQgZnJvbSBhIG1hdHJpeCAoNHg0KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gZHVhbCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgLy9UT0RPIE9wdGltaXplIHRoaXNcbiAgdmFyIG91dGVyID0gcXVhdC5jcmVhdGUoKTtcbiAgbWF0NC5nZXRSb3RhdGlvbihvdXRlciwgYSk7XG4gIHZhciB0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG1hdDQuZ2V0VHJhbnNsYXRpb24odCwgYSk7XG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgb3V0ZXIsIHQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBkdWFsIHF1YXQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBzb3VyY2UgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIGR1YWwgcXVhdCB0byB0aGUgaWRlbnRpdHkgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCB4MSwgeTEsIHoxLCB3MSwgeDIsIHkyLCB6MiwgdzIpIHtcbiAgb3V0WzBdID0geDE7XG4gIG91dFsxXSA9IHkxO1xuICBvdXRbMl0gPSB6MTtcbiAgb3V0WzNdID0gdzE7XG4gIG91dFs0XSA9IHgyO1xuICBvdXRbNV0gPSB5MjtcbiAgb3V0WzZdID0gejI7XG4gIG91dFs3XSA9IHcyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldHMgdGhlIHJlYWwgcGFydCBvZiBhIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0gIHtxdWF0fSBvdXQgcmVhbCBwYXJ0XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge3F1YXR9IHJlYWwgcGFydFxyXG4gKi9cblxuXG52YXIgZ2V0UmVhbCA9IHF1YXQuY29weTtcbi8qKlxyXG4gKiBHZXRzIHRoZSBkdWFsIHBhcnQgb2YgYSBkdWFsIHF1YXRcclxuICogQHBhcmFtICB7cXVhdH0gb3V0IGR1YWwgcGFydFxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvblxyXG4gKiBAcmV0dXJuIHtxdWF0fSBkdWFsIHBhcnRcclxuICovXG5cbmV4cG9ydHMuZ2V0UmVhbCA9IGdldFJlYWw7XG5cbmZ1bmN0aW9uIGdldER1YWwob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbNF07XG4gIG91dFsxXSA9IGFbNV07XG4gIG91dFsyXSA9IGFbNl07XG4gIG91dFszXSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSByZWFsIGNvbXBvbmVudCBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJlYWwgcGFydFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIHNldFJlYWwgPSBxdWF0LmNvcHk7XG4vKipcclxuICogU2V0IHRoZSBkdWFsIGNvbXBvbmVudCBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIGR1YWwgcGFydFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc2V0UmVhbCA9IHNldFJlYWw7XG5cbmZ1bmN0aW9uIHNldER1YWwob3V0LCBxKSB7XG4gIG91dFs0XSA9IHFbMF07XG4gIG91dFs1XSA9IHFbMV07XG4gIG91dFs2XSA9IHFbMl07XG4gIG91dFs3XSA9IHFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgdHJhbnNsYXRpb24gb2YgYSBub3JtYWxpemVkIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgdHJhbnNsYXRpb25cclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb24gdG8gYmUgZGVjb21wb3NlZFxyXG4gKiBAcmV0dXJuIHt2ZWMzfSB0cmFuc2xhdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihvdXQsIGEpIHtcbiAgdmFyIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXTtcbiAgb3V0WzBdID0gKGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnkpICogMjtcbiAgb3V0WzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgb3V0WzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGVzIGEgZHVhbCBxdWF0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGF4MSA9IGFbMF0sXG4gICAgICBheTEgPSBhWzFdLFxuICAgICAgYXoxID0gYVsyXSxcbiAgICAgIGF3MSA9IGFbM10sXG4gICAgICBieDEgPSB2WzBdICogMC41LFxuICAgICAgYnkxID0gdlsxXSAqIDAuNSxcbiAgICAgIGJ6MSA9IHZbMl0gKiAwLjUsXG4gICAgICBheDIgPSBhWzRdLFxuICAgICAgYXkyID0gYVs1XSxcbiAgICAgIGF6MiA9IGFbNl0sXG4gICAgICBhdzIgPSBhWzddO1xuICBvdXRbMF0gPSBheDE7XG4gIG91dFsxXSA9IGF5MTtcbiAgb3V0WzJdID0gYXoxO1xuICBvdXRbM10gPSBhdzE7XG4gIG91dFs0XSA9IGF3MSAqIGJ4MSArIGF5MSAqIGJ6MSAtIGF6MSAqIGJ5MSArIGF4MjtcbiAgb3V0WzVdID0gYXcxICogYnkxICsgYXoxICogYngxIC0gYXgxICogYnoxICsgYXkyO1xuICBvdXRbNl0gPSBhdzEgKiBiejEgKyBheDEgKiBieTEgLSBheTEgKiBieDEgKyBhejI7XG4gIG91dFs3XSA9IC1heDEgKiBieDEgLSBheTEgKiBieTEgLSBhejEgKiBiejEgKyBhdzI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgaG93IGZhciBzaG91bGQgdGhlIHJvdGF0aW9uIGJlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGF4MSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksXG4gICAgICBheTEgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxuICAgICAgYXoxID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgIGF3MSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHF1YXQucm90YXRlWChvdXQsIGEsIHJhZCk7XG4gIGJ4ID0gb3V0WzBdO1xuICBieSA9IG91dFsxXTtcbiAgYnogPSBvdXRbMl07XG4gIGJ3ID0gb3V0WzNdO1xuICBvdXRbNF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzVdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFs2XSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbN10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCB0aGUgWSBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVZKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGhvdyBmYXIgc2hvdWxkIHRoZSByb3RhdGlvbiBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBheDEgPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxuICAgICAgYXkxID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcbiAgICAgIGF6MSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsXG4gICAgICBhdzEgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICBxdWF0LnJvdGF0ZVoob3V0LCBhLCByYWQpO1xuICBieCA9IG91dFswXTtcbiAgYnkgPSBvdXRbMV07XG4gIGJ6ID0gb3V0WzJdO1xuICBidyA9IG91dFszXTtcbiAgb3V0WzRdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFs1XSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbNl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzddID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKGEgKiBxKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdEFwcGVuZChvdXQsIGEsIHEpIHtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXSxcbiAgICAgIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKiBxdyArIGF3ICogcXggKyBheSAqIHF6IC0gYXogKiBxeTtcbiAgb3V0WzFdID0gYXkgKiBxdyArIGF3ICogcXkgKyBheiAqIHF4IC0gYXggKiBxejtcbiAgb3V0WzJdID0gYXogKiBxdyArIGF3ICogcXogKyBheCAqIHF5IC0gYXkgKiBxeDtcbiAgb3V0WzNdID0gYXcgKiBxdyAtIGF4ICogcXggLSBheSAqIHF5IC0gYXogKiBxejtcbiAgYXggPSBhWzRdO1xuICBheSA9IGFbNV07XG4gIGF6ID0gYVs2XTtcbiAgYXcgPSBhWzddO1xuICBvdXRbNF0gPSBheCAqIHF3ICsgYXcgKiBxeCArIGF5ICogcXogLSBheiAqIHF5O1xuICBvdXRbNV0gPSBheSAqIHF3ICsgYXcgKiBxeSArIGF6ICogcXggLSBheCAqIHF6O1xuICBvdXRbNl0gPSBheiAqIHF3ICsgYXcgKiBxeiArIGF4ICogcXkgLSBheSAqIHF4O1xuICBvdXRbN10gPSBhdyAqIHF3IC0gYXggKiBxeCAtIGF5ICogcXkgLSBheiAqIHF6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYnkgYSBnaXZlbiBxdWF0ZXJuaW9uIChxICogYSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVCeVF1YXRQcmVwZW5kKG91dCwgcSwgYSkge1xuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdLFxuICAgICAgYnggPSBhWzBdLFxuICAgICAgYnkgPSBhWzFdLFxuICAgICAgYnogPSBhWzJdLFxuICAgICAgYncgPSBhWzNdO1xuICBvdXRbMF0gPSBxeCAqIGJ3ICsgcXcgKiBieCArIHF5ICogYnogLSBxeiAqIGJ5O1xuICBvdXRbMV0gPSBxeSAqIGJ3ICsgcXcgKiBieSArIHF6ICogYnggLSBxeCAqIGJ6O1xuICBvdXRbMl0gPSBxeiAqIGJ3ICsgcXcgKiBieiArIHF4ICogYnkgLSBxeSAqIGJ4O1xuICBvdXRbM10gPSBxdyAqIGJ3IC0gcXggKiBieCAtIHF5ICogYnkgLSBxeiAqIGJ6O1xuICBieCA9IGFbNF07XG4gIGJ5ID0gYVs1XTtcbiAgYnogPSBhWzZdO1xuICBidyA9IGFbN107XG4gIG91dFs0XSA9IHF4ICogYncgKyBxdyAqIGJ4ICsgcXkgKiBieiAtIHF6ICogYnk7XG4gIG91dFs1XSA9IHF5ICogYncgKyBxdyAqIGJ5ICsgcXogKiBieCAtIHF4ICogYno7XG4gIG91dFs2XSA9IHF6ICogYncgKyBxdyAqIGJ6ICsgcXggKiBieSAtIHF5ICogYng7XG4gIG91dFs3XSA9IHF3ICogYncgLSBxeCAqIGJ4IC0gcXkgKiBieSAtIHF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgYSBnaXZlbiBheGlzLiBEb2VzIHRoZSBub3JtYWxpc2F0aW9uIGF1dG9tYXRpY2FsbHlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgaG93IGZhciB0aGUgcm90YXRpb24gc2hvdWxkIGJlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZUFyb3VuZEF4aXMob3V0LCBhLCBheGlzLCByYWQpIHtcbiAgLy9TcGVjaWFsIGNhc2UgZm9yIHJhZCA9IDBcbiAgaWYgKE1hdGguYWJzKHJhZCkgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGNvcHkob3V0LCBhKTtcbiAgfVxuXG4gIHZhciBheGlzTGVuZ3RoID0gTWF0aC5oeXBvdChheGlzWzBdLCBheGlzWzFdLCBheGlzWzJdKTtcbiAgcmFkID0gcmFkICogMC41O1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBieCA9IHMgKiBheGlzWzBdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ5ID0gcyAqIGF4aXNbMV0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYnogPSBzICogYXhpc1syXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBidyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBheDEgPSBhWzBdLFxuICAgICAgYXkxID0gYVsxXSxcbiAgICAgIGF6MSA9IGFbMl0sXG4gICAgICBhdzEgPSBhWzNdO1xuICBvdXRbMF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzFdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFsyXSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbM10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgdmFyIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgb3V0WzRdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzVdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzddID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBkdWFsIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIGR1YWwgcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGF4MCA9IGFbMF0sXG4gICAgICBheTAgPSBhWzFdLFxuICAgICAgYXowID0gYVsyXSxcbiAgICAgIGF3MCA9IGFbM10sXG4gICAgICBieDEgPSBiWzRdLFxuICAgICAgYnkxID0gYls1XSxcbiAgICAgIGJ6MSA9IGJbNl0sXG4gICAgICBidzEgPSBiWzddLFxuICAgICAgYXgxID0gYVs0XSxcbiAgICAgIGF5MSA9IGFbNV0sXG4gICAgICBhejEgPSBhWzZdLFxuICAgICAgYXcxID0gYVs3XSxcbiAgICAgIGJ4MCA9IGJbMF0sXG4gICAgICBieTAgPSBiWzFdLFxuICAgICAgYnowID0gYlsyXSxcbiAgICAgIGJ3MCA9IGJbM107XG4gIG91dFswXSA9IGF4MCAqIGJ3MCArIGF3MCAqIGJ4MCArIGF5MCAqIGJ6MCAtIGF6MCAqIGJ5MDtcbiAgb3V0WzFdID0gYXkwICogYncwICsgYXcwICogYnkwICsgYXowICogYngwIC0gYXgwICogYnowO1xuICBvdXRbMl0gPSBhejAgKiBidzAgKyBhdzAgKiBiejAgKyBheDAgKiBieTAgLSBheTAgKiBieDA7XG4gIG91dFszXSA9IGF3MCAqIGJ3MCAtIGF4MCAqIGJ4MCAtIGF5MCAqIGJ5MCAtIGF6MCAqIGJ6MDtcbiAgb3V0WzRdID0gYXgwICogYncxICsgYXcwICogYngxICsgYXkwICogYnoxIC0gYXowICogYnkxICsgYXgxICogYncwICsgYXcxICogYngwICsgYXkxICogYnowIC0gYXoxICogYnkwO1xuICBvdXRbNV0gPSBheTAgKiBidzEgKyBhdzAgKiBieTEgKyBhejAgKiBieDEgLSBheDAgKiBiejEgKyBheTEgKiBidzAgKyBhdzEgKiBieTAgKyBhejEgKiBieDAgLSBheDEgKiBiejA7XG4gIG91dFs2XSA9IGF6MCAqIGJ3MSArIGF3MCAqIGJ6MSArIGF4MCAqIGJ5MSAtIGF5MCAqIGJ4MSArIGF6MSAqIGJ3MCArIGF3MSAqIGJ6MCArIGF4MSAqIGJ5MCAtIGF5MSAqIGJ4MDtcbiAgb3V0WzddID0gYXcwICogYncxIC0gYXgwICogYngxIC0gYXkwICogYnkxIC0gYXowICogYnoxICsgYXcxICogYncwIC0gYXgxICogYngwIC0gYXkxICogYnkwIC0gYXoxICogYnowO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdDIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogU2NhbGVzIGEgZHVhbCBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXQgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBkdWFsIHF1YXQgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gZHVhbCBxdWF0J3MgKFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgcmVhbCBwYXJ0cylcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cblxudmFyIGRvdCA9IHF1YXQuZG90O1xuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gZHVhbCBxdWF0cydzXHJcbiAqIE5PVEU6IFRoZSByZXN1bHRpbmcgZHVhbCBxdWF0ZXJuaW9ucyB3b24ndCBhbHdheXMgYmUgbm9ybWFsaXplZCAoVGhlIGVycm9yIGlzIG1vc3Qgbm90aWNlYWJsZSB3aGVuIHQgPSAwLjUpXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnRzLmRvdCA9IGRvdDtcblxuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIG10ID0gMSAtIHQ7XG4gIGlmIChkb3QoYSwgYikgPCAwKSB0ID0gLXQ7XG4gIG91dFswXSA9IGFbMF0gKiBtdCArIGJbMF0gKiB0O1xuICBvdXRbMV0gPSBhWzFdICogbXQgKyBiWzFdICogdDtcbiAgb3V0WzJdID0gYVsyXSAqIG10ICsgYlsyXSAqIHQ7XG4gIG91dFszXSA9IGFbM10gKiBtdCArIGJbM10gKiB0O1xuICBvdXRbNF0gPSBhWzRdICogbXQgKyBiWzRdICogdDtcbiAgb3V0WzVdID0gYVs1XSAqIG10ICsgYls1XSAqIHQ7XG4gIG91dFs2XSA9IGFbNl0gKiBtdCArIGJbNl0gKiB0O1xuICBvdXRbN10gPSBhWzddICogbXQgKyBiWzddICogdDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgZHVhbCBxdWF0LiBJZiB0aGV5IGFyZSBub3JtYWxpemVkLCBjb25qdWdhdGUgaXMgY2hlYXBlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBzcWxlbiA9IHNxdWFyZWRMZW5ndGgoYSk7XG4gIG91dFswXSA9IC1hWzBdIC8gc3FsZW47XG4gIG91dFsxXSA9IC1hWzFdIC8gc3FsZW47XG4gIG91dFsyXSA9IC1hWzJdIC8gc3FsZW47XG4gIG91dFszXSA9IGFbM10gLyBzcWxlbjtcbiAgb3V0WzRdID0gLWFbNF0gLyBzcWxlbjtcbiAgb3V0WzVdID0gLWFbNV0gLyBzcWxlbjtcbiAgb3V0WzZdID0gLWFbNl0gLyBzcWxlbjtcbiAgb3V0WzddID0gYVs3XSAvIHNxbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIGR1YWwgcXVhdFxyXG4gKiBJZiB0aGUgZHVhbCBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdDIuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSAtYVs0XTtcbiAgb3V0WzVdID0gLWFbNV07XG4gIG91dFs2XSA9IC1hWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBsZW5ndGggPSBxdWF0Lmxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbnZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBkdWFsIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuID0gbGVuO1xudmFyIHNxdWFyZWRMZW5ndGggPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRMZW5ndGg7XG52YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBkdWFsIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJMZW4gPSBzcXJMZW47XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIG1hZ25pdHVkZSA9IHNxdWFyZWRMZW5ndGgoYSk7XG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICBtYWduaXR1ZGUgPSBNYXRoLnNxcnQobWFnbml0dWRlKTtcbiAgICB2YXIgYTAgPSBhWzBdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMSA9IGFbMV0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGEyID0gYVsyXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTMgPSBhWzNdIC8gbWFnbml0dWRlO1xuICAgIHZhciBiMCA9IGFbNF07XG4gICAgdmFyIGIxID0gYVs1XTtcbiAgICB2YXIgYjIgPSBhWzZdO1xuICAgIHZhciBiMyA9IGFbN107XG4gICAgdmFyIGFfZG90X2IgPSBhMCAqIGIwICsgYTEgKiBiMSArIGEyICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IChiMCAtIGEwICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzVdID0gKGIxIC0gYTEgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbNl0gPSAoYjIgLSBhMiAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs3XSA9IChiMyAtIGEzICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkdWFsIHF1YXRlbmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGR1YWwgcXVhdFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJxdWF0MihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIiwgXCIgKyBhWzRdICsgXCIsIFwiICsgYVs1XSArIFwiLCBcIiArIGFbNl0gKyBcIiwgXCIgKyBhWzddICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZHVhbCBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3QgZHVhbCBxdWF0ZXJuaW9uLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBkdWFsIHF1YXRlcm5pb24uXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBkdWFsIHF1YXRlcm5pb25zIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZHVhbCBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3QgZHVhbCBxdWF0LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBkdWFsIHF1YXQuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBkdWFsIHF1YXRzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmZyb21WYWx1ZXMgPSBmcm9tVmFsdWVzO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmRpdmlkZSA9IGRpdmlkZTtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMuc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRMZW5ndGg7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2U7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQyID0gdHJhbnNmb3JtTWF0MjtcbmV4cG9ydHMudHJhbnNmb3JtTWF0MmQgPSB0cmFuc2Zvcm1NYXQyZDtcbmV4cG9ydHMudHJhbnNmb3JtTWF0MyA9IHRyYW5zZm9ybU1hdDM7XG5leHBvcnRzLnRyYW5zZm9ybU1hdDQgPSB0cmFuc2Zvcm1NYXQ0O1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLmFuZ2xlID0gYW5nbGU7XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuZm9yRWFjaCA9IGV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5zcXJEaXN0ID0gZXhwb3J0cy5kaXN0ID0gZXhwb3J0cy5kaXYgPSBleHBvcnRzLm11bCA9IGV4cG9ydHMuc3ViID0gZXhwb3J0cy5sZW4gPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5cblxuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeTtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufVxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcclxuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xyXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcclxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIHZlYzIgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCBiLCByYWQpIHtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICB2YXIgcDAgPSBhWzBdIC0gYlswXSxcbiAgICAgIHAxID0gYVsxXSAtIGJbMV0sXG4gICAgICBzaW5DID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGNvc0MgPSBNYXRoLmNvcyhyYWQpOyAvL3BlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgb3V0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIHgxID0gYVswXSxcbiAgICAgIHkxID0gYVsxXSxcbiAgICAgIHgyID0gYlswXSxcbiAgICAgIHkyID0gYlsxXSxcbiAgICAgIC8vIG1hZyBpcyB0aGUgcHJvZHVjdCBvZiB0aGUgbWFnbml0dWRlcyBvZiBhIGFuZCBiXG4gIG1hZyA9IE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSkgKiBNYXRoLnNxcnQoeDIgKiB4MiArIHkyICogeTIpLFxuICAgICAgLy8gbWFnICYmLi4gc2hvcnQgY2lyY3VpdHMgaWYgbWFnID09IDBcbiAgY29zaW5lID0gbWFnICYmICh4MSAqIHgyICsgeTEgKiB5MikgLyBtYWc7IC8vIE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSBjbGFtcHMgdGhlIGNvc2luZSBiZXR3ZWVuIC0xIGFuZCAxXG5cbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gemVyb1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuID0gbGVuO1xudmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnN1YiA9IHN1YjtcbnZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubXVsID0gbXVsO1xudmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5kaXYgPSBkaXY7XG52YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5kaXN0ID0gZGlzdDtcbnZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyRGlzdCA9IHNxckRpc3Q7XG52YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cclxuICogQHJldHVybnMge0FycmF5fSBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zcXJMZW4gPSBzcXJMZW47XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5kaXZpZGUgPSBkaXZpZGU7XG5leHBvcnRzLmNlaWwgPSBjZWlsO1xuZXhwb3J0cy5mbG9vciA9IGZsb29yO1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLm1heCA9IG1heDtcbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuc2NhbGVBbmRBZGQgPSBzY2FsZUFuZEFkZDtcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuZXhwb3J0cy5zcXVhcmVkTGVuZ3RoID0gc3F1YXJlZExlbmd0aDtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5pbnZlcnNlID0gaW52ZXJzZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5kb3QgPSBkb3Q7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5oZXJtaXRlID0gaGVybWl0ZTtcbmV4cG9ydHMuYmV6aWVyID0gYmV6aWVyO1xuZXhwb3J0cy5yYW5kb20gPSByYW5kb207XG5leHBvcnRzLnRyYW5zZm9ybU1hdDQgPSB0cmFuc2Zvcm1NYXQ0O1xuZXhwb3J0cy50cmFuc2Zvcm1NYXQzID0gdHJhbnNmb3JtTWF0MztcbmV4cG9ydHMudHJhbnNmb3JtUXVhdCA9IHRyYW5zZm9ybVF1YXQ7XG5leHBvcnRzLnJvdGF0ZVggPSByb3RhdGVYO1xuZXhwb3J0cy5yb3RhdGVZID0gcm90YXRlWTtcbmV4cG9ydHMucm90YXRlWiA9IHJvdGF0ZVo7XG5leHBvcnRzLmFuZ2xlID0gYW5nbGU7XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuZXhwb3J0cy5zdHIgPSBzdHI7XG5leHBvcnRzLmV4YWN0RXF1YWxzID0gZXhhY3RFcXVhbHM7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuZm9yRWFjaCA9IGV4cG9ydHMuc3FyTGVuID0gZXhwb3J0cy5sZW4gPSBleHBvcnRzLnNxckRpc3QgPSBleHBvcnRzLmRpc3QgPSBleHBvcnRzLmRpdiA9IGV4cG9ydHMubXVsID0gZXhwb3J0cy5zdWIgPSB2b2lkIDA7XG5cbnZhciBnbE1hdHJpeCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbi8qKlxyXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzNcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeik7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxyXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gaGVybWl0ZShvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGZhY3RvclRpbWVzMiAqICgyICogdCAtIDMpICsgMTtcbiAgdmFyIGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdDtcbiAgdmFyIGZhY3RvcjMgPSBmYWN0b3JUaW1lczIgKiAodCAtIDEpO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqICgzIC0gMiAqIHQpO1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYmV6aWVyKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0O1xuICB2YXIgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvO1xuICB2YXIgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIHZhciB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjA7XG4gIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGU7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXHJcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB3ID0gdyB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XHJcbiAqIENhbiBhbHNvIGJlIHVzZWQgZm9yIGR1YWwgcXVhdGVybmlvbnMuIChNdWx0aXBseSBpdCB3aXRoIHRoZSByZWFsIHBhcnQpXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTsgLy8gdmFyIHF2ZWMgPSBbcXgsIHF5LCBxel07XG4gIC8vIHZhciB1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIGEpO1xuXG4gIHZhciB1dnggPSBxeSAqIHogLSBxeiAqIHksXG4gICAgICB1dnkgPSBxeiAqIHggLSBxeCAqIHosXG4gICAgICB1dnogPSBxeCAqIHkgLSBxeSAqIHg7IC8vIHZhciB1dXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCB1dik7XG5cbiAgdmFyIHV1dnggPSBxeSAqIHV2eiAtIHF6ICogdXZ5LFxuICAgICAgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dnosXG4gICAgICB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDsgLy8gdmVjMy5zY2FsZSh1diwgdXYsIDIgKiB3KTtcblxuICB2YXIgdzIgPSBxdyAqIDI7XG4gIHV2eCAqPSB3MjtcbiAgdXZ5ICo9IHcyO1xuICB1dnogKj0gdzI7IC8vIHZlYzMuc2NhbGUodXV2LCB1dXYsIDIpO1xuXG4gIHV1dnggKj0gMjtcbiAgdXV2eSAqPSAyO1xuICB1dXZ6ICo9IDI7IC8vIHJldHVybiB2ZWMzLmFkZChvdXQsIGEsIHZlYzMuYWRkKG91dCwgdXYsIHV1dikpO1xuXG4gIG91dFswXSA9IHggKyB1dnggKyB1dXZ4O1xuICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgb3V0WzJdID0geiArIHV2eiArIHV1dno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKHJhZCkgLSBwWzJdICogTWF0aC5zaW4ocmFkKTtcbiAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihyYWQpICsgcFsyXSAqIE1hdGguY29zKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzJdID0gcFsyXTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKi9cblxuXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBtYWcxID0gTWF0aC5zcXJ0KGF4ICogYXggKyBheSAqIGF5ICsgYXogKiBheiksXG4gICAgICBtYWcyID0gTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiksXG4gICAgICBtYWcgPSBtYWcxICogbWFnMixcbiAgICAgIGNvc2luZSA9IG1hZyAmJiBkb3QoYSwgYikgLyBtYWc7XG4gIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpKTtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5cbnZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5zdWIgPSBzdWI7XG52YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLm11bCA9IG11bDtcbnZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZGl2ID0gZGl2O1xudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuZGlzdCA9IGRpc3Q7XG52YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyRGlzdCA9IHNxckRpc3Q7XG52YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMubGVuID0gbGVuO1xudmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3FyTGVuID0gc3FyTGVuO1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDM7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICB2ZWNbMl0gPSBhW2kgKyAyXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuZm9yRWFjaCA9IGZvckVhY2g7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5mcm9tVmFsdWVzID0gZnJvbVZhbHVlcztcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuZXhwb3J0cy5tdWx0aXBseSA9IG11bHRpcGx5O1xuZXhwb3J0cy5kaXZpZGUgPSBkaXZpZGU7XG5leHBvcnRzLmNlaWwgPSBjZWlsO1xuZXhwb3J0cy5mbG9vciA9IGZsb29yO1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLm1heCA9IG1heDtcbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuc2NhbGVBbmRBZGQgPSBzY2FsZUFuZEFkZDtcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLnNxdWFyZWRMZW5ndGggPSBzcXVhcmVkTGVuZ3RoO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuY3Jvc3MgPSBjcm9zcztcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMudHJhbnNmb3JtTWF0NCA9IHRyYW5zZm9ybU1hdDQ7XG5leHBvcnRzLnRyYW5zZm9ybVF1YXQgPSB0cmFuc2Zvcm1RdWF0O1xuZXhwb3J0cy56ZXJvID0gemVybztcbmV4cG9ydHMuc3RyID0gc3RyO1xuZXhwb3J0cy5leGFjdEVxdWFscyA9IGV4YWN0RXF1YWxzO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLmZvckVhY2ggPSBleHBvcnRzLnNxckxlbiA9IGV4cG9ydHMubGVuID0gZXhwb3J0cy5zcXJEaXN0ID0gZXhwb3J0cy5kaXN0ID0gZXhwb3J0cy5kaXYgPSBleHBvcnRzLm11bCA9IGV4cG9ydHMuc3ViID0gdm9pZCAwO1xuXG52YXIgZ2xNYXRyaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb21tb24uanNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4vKipcclxuICogNCBEaW1lbnNpb25hbCBWZWN0b3JcclxuICogQG1vZHVsZSB2ZWM0XHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXHJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHosIHcpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHosIHcpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5jZWlsKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLnJvdW5kKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgdmFyIHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICB2YXIgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgdyA9IGFbM107XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHosIHcpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICovXG5cblxuZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IC1hWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSB4ICogbGVuO1xuICBvdXRbMV0gPSB5ICogbGVuO1xuICBvdXRbMl0gPSB6ICogbGVuO1xuICBvdXRbM10gPSB3ICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cblxuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNyb3NzLXByb2R1Y3Qgb2YgdGhyZWUgdmVjdG9ycyBpbiBhIDQtZGltZW5zaW9uYWwgc3BhY2VcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IHJlc3VsdCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gVSB0aGUgZmlyc3QgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBWIHRoZSBzZWNvbmQgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBXIHRoZSB0aGlyZCB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IHJlc3VsdFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjcm9zcyhvdXQsIHUsIHYsIHcpIHtcbiAgdmFyIEEgPSB2WzBdICogd1sxXSAtIHZbMV0gKiB3WzBdLFxuICAgICAgQiA9IHZbMF0gKiB3WzJdIC0gdlsyXSAqIHdbMF0sXG4gICAgICBDID0gdlswXSAqIHdbM10gLSB2WzNdICogd1swXSxcbiAgICAgIEQgPSB2WzFdICogd1syXSAtIHZbMl0gKiB3WzFdLFxuICAgICAgRSA9IHZbMV0gKiB3WzNdIC0gdlszXSAqIHdbMV0sXG4gICAgICBGID0gdlsyXSAqIHdbM10gLSB2WzNdICogd1syXTtcbiAgdmFyIEcgPSB1WzBdO1xuICB2YXIgSCA9IHVbMV07XG4gIHZhciBJID0gdVsyXTtcbiAgdmFyIEogPSB1WzNdO1xuICBvdXRbMF0gPSBIICogRiAtIEkgKiBFICsgSiAqIEQ7XG4gIG91dFsxXSA9IC0oRyAqIEYpICsgSSAqIEMgLSBKICogQjtcbiAgb3V0WzJdID0gRyAqIEUgLSBIICogQyArIEogKiBBO1xuICBvdXRbM10gPSAtKEcgKiBEKSArIEggKiBCIC0gSSAqIEE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICB2YXIgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wOyAvLyBNYXJzYWdsaWEsIEdlb3JnZS4gQ2hvb3NpbmcgYSBQb2ludCBmcm9tIHRoZSBTdXJmYWNlIG9mIGFcbiAgLy8gU3BoZXJlLiBBbm4uIE1hdGguIFN0YXRpc3QuIDQzICgxOTcyKSwgbm8uIDIsIDY0NS0tNjQ2LlxuICAvLyBodHRwOi8vcHJvamVjdGV1Y2xpZC5vcmcvZXVjbGlkLmFvbXMvMTE3NzY5MjY0NDtcblxuICB2YXIgdjEsIHYyLCB2MywgdjQ7XG4gIHZhciBzMSwgczI7XG5cbiAgZG8ge1xuICAgIHYxID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2MiA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczEgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgfSB3aGlsZSAoczEgPj0gMSk7XG5cbiAgZG8ge1xuICAgIHYzID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2NCA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczIgPSB2MyAqIHYzICsgdjQgKiB2NDtcbiAgfSB3aGlsZSAoczIgPj0gMSk7XG5cbiAgdmFyIGQgPSBNYXRoLnNxcnQoKDEgLSBzMSkgLyBzMik7XG4gIG91dFswXSA9IHNjYWxlICogdjE7XG4gIG91dFsxXSA9IHNjYWxlICogdjI7XG4gIG91dFsyXSA9IHNjYWxlICogdjMgKiBkO1xuICBvdXRbM10gPSBzY2FsZSAqIHY0ICogZDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdLFxuICAgICAgdyA9IGFbM107XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM107IC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG5cbiAgdmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgdmFyIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejsgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cblxuZnVuY3Rpb24gemVybyhvdXQpIHtcbiAgb3V0WzBdID0gMC4wO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWM0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuXG52YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydHMuc3ViID0gc3ViO1xudmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0cy5tdWwgPSBtdWw7XG52YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpdiA9IGRpdjtcbnZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmRpc3QgPSBkaXN0O1xudmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckRpc3QgPSBzcXJEaXN0O1xudmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLmxlbiA9IGxlbjtcbnZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnRzLnNxckxlbiA9IHNxckxlbjtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICB2ZWNbM10gPSBhW2kgKyAzXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgICBhW2kgKyAzXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDsiLCIvKiEgSGFtbWVyLkpTIC0gdjIuMC40IC0gMjAxNC0wOS0yOFxyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSm9yaWsgVGFuZ2VsZGVyO1xyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cclxuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGV4cG9ydE5hbWUsIHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ01TJywgJ21zJywgJ28nXTtcclxudmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxudmFyIFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xyXG5cclxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxudmFyIGFicyA9IE1hdGguYWJzO1xyXG52YXIgbm93ID0gRGF0ZS5ub3c7XHJcblxyXG4vKipcclxuICogc2V0IGEgdGltZW91dCB3aXRoIGEgZ2l2ZW4gc2NvcGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHNldFRpbWVvdXRDb250ZXh0KGZuLCB0aW1lb3V0LCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XHJcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxyXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cclxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcclxuICogQHBhcmFtIHtTdHJpbmd9IGZuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XHJcbiAgICAgICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcclxuICovXHJcbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgaWYgKCFvYmopIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XHJcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcclxuICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIGV4dGVuZCBvYmplY3QuXHJcbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlXVxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxyXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xyXG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xyXG59XHJcblxyXG4vKipcclxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxyXG4gKi9cclxuZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xyXG4gICAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGUsXHJcbiAgICAgICAgY2hpbGRQO1xyXG5cclxuICAgIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xyXG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XHJcbiAgICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XHJcblxyXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgICBleHRlbmQoY2hpbGRQLCBwcm9wZXJ0aWVzKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cclxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT0gVFlQRV9GVU5DVElPTikge1xyXG4gICAgICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxyXG4gKiBAcGFyYW0geyp9IHZhbDFcclxuICogQHBhcmFtIHsqfSB2YWwyXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuZnVuY3Rpb24gaWZVbmRlZmluZWQodmFsMSwgdmFsMikge1xyXG4gICAgcmV0dXJuICh2YWwxID09PSB1bmRlZmluZWQpID8gdmFsMiA6IHZhbDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXHJcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xyXG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcclxuICogQG1ldGhvZCBoYXNQYXJlbnRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcclxuICovXHJcbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcclxuICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcclxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXHJcbiAqL1xyXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcclxuICAgIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xyXG59XHJcblxyXG4vKipcclxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcclxuICAgIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xyXG59XHJcblxyXG4vKipcclxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxyXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcclxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XHJcbiAgICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xyXG4gICAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcclxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xyXG59XHJcblxyXG4vKipcclxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxyXG4gKi9cclxuZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcclxuICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xyXG4gICAgICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbDtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvcnQpIHtcclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydChmdW5jdGlvbiBzb3J0VW5pcXVlQXJyYXkoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcclxuICovXHJcbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcclxuICAgIHZhciBwcmVmaXgsIHByb3A7XHJcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xyXG5cclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xyXG4gICAgICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcclxuICAgICAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgaWYgKHByb3AgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IGEgdW5pcXVlIGlkXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXHJcbiAqL1xyXG52YXIgX3VuaXF1ZUlkID0gMTtcclxuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XHJcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xyXG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyk7XHJcbn1cclxuXHJcbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XHJcblxyXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xyXG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XHJcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xyXG52YXIgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcclxudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xyXG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcclxuXHJcbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XHJcblxyXG52YXIgSU5QVVRfU1RBUlQgPSAxO1xyXG52YXIgSU5QVVRfTU9WRSA9IDI7XHJcbnZhciBJTlBVVF9FTkQgPSA0O1xyXG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcclxuXHJcbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XHJcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XHJcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xyXG52YXIgRElSRUNUSU9OX1VQID0gODtcclxudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XHJcblxyXG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcclxudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xyXG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xyXG5cclxudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcclxudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XHJcblxyXG4vKipcclxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAqIEByZXR1cm5zIHtJbnB1dH1cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcclxuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xyXG5cclxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxyXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxyXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xyXG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0KCk7XHJcblxyXG59XHJcblxyXG5JbnB1dC5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYmluZCB0aGUgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXHJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxyXG4gKiBAcmV0dXJucyB7SW5wdXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcclxuICAgIHZhciBUeXBlO1xyXG4gICAgdmFyIGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcclxuXHJcbiAgICBpZiAoaW5wdXRDbGFzcykge1xyXG4gICAgICAgIFR5cGUgPSBpbnB1dENsYXNzO1xyXG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XHJcbiAgICAgICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xyXG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcclxuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcclxuICAgIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcclxuICAgICAgICBUeXBlID0gTW91c2VJbnB1dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXHJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcclxuICAgIHZhciBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcclxuICAgIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xyXG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XHJcbiAgICB2YXIgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcclxuXHJcbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xyXG4gICAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcclxuXHJcbiAgICBpZiAoaXNGaXJzdCkge1xyXG4gICAgICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXHJcbiAgICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcclxuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcclxuXHJcbiAgICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcclxuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xyXG5cclxuICAgIC8vIGVtaXQgc2VjcmV0IGV2ZW50XHJcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcclxuXHJcbiAgICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XHJcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xyXG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XHJcbiAgICB2YXIgcG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycztcclxuICAgIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcclxuXHJcbiAgICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXHJcbiAgICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xyXG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXHJcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcclxuICAgICAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XHJcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XHJcbiAgICB2YXIgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcclxuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcclxuXHJcbiAgICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcclxuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xyXG4gICAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XHJcblxyXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XHJcbiAgICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcclxuXHJcbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XHJcbiAgICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xyXG5cclxuICAgIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XHJcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xyXG5cclxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XHJcblxyXG4gICAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcclxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XHJcbiAgICBpZiAoaGFzUGFyZW50KGlucHV0LnNyY0V2ZW50LnRhcmdldCwgdGFyZ2V0KSkge1xyXG4gICAgICAgIHRhcmdldCA9IGlucHV0LnNyY0V2ZW50LnRhcmdldDtcclxuICAgIH1cclxuICAgIGlucHV0LnRhcmdldCA9IHRhcmdldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcclxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7XHJcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcclxuICAgIHZhciBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcclxuICAgIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcclxuXHJcbiAgICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcclxuICAgICAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcclxuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxyXG4gICAgICAgICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xyXG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcclxuICAgICAgICAgICAgeTogY2VudGVyLnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xyXG4gICAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcclxuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcclxuICAgIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQsXHJcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXHJcbiAgICAgICAgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBkaXJlY3Rpb247XHJcblxyXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIHZhciBkZWx0YVggPSBsYXN0LmRlbHRhWCAtIGlucHV0LmRlbHRhWDtcclxuICAgICAgICB2YXIgZGVsdGFZID0gbGFzdC5kZWx0YVkgLSBpbnB1dC5kZWx0YVk7XHJcblxyXG4gICAgICAgIHZhciB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XHJcbiAgICAgICAgdmVsb2NpdHlYID0gdi54O1xyXG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcclxuICAgICAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcclxuICAgICAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xyXG5cclxuICAgICAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXHJcbiAgICAgICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xyXG4gICAgICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xyXG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XHJcbiAgICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XHJcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XHJcbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcclxuICovXHJcbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XHJcbiAgICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcclxuICAgIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xyXG4gICAgdmFyIHBvaW50ZXJzID0gW107XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xyXG4gICAgICAgICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcclxuICAgICAgICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRpbWVTdGFtcDogbm93KCksXHJcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxyXG4gICAgICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcclxuICAgICAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcclxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcclxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcclxuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XHJcbiAgICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XHJcblxyXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcclxuICAgIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxyXG4gICAgICAgICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XHJcbiAgICAgICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xyXG4gICAgICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxyXG4gICAgICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcclxuICAgICAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XHJcbiAgICBpZiAoeCA9PT0geSkge1xyXG4gICAgICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xyXG4gICAgICAgIHJldHVybiB4ID4gMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cclxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcclxuICAgIH1cclxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxyXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxyXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcclxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcclxuICAgIH1cclxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxyXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcclxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcclxuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXHJcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcclxuICAgIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSAtIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXHJcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxyXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xyXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcclxuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xyXG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xyXG59XHJcblxyXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xyXG4gICAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcclxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcclxuICAgIG1vdXNldXA6IElOUFVUX0VORFxyXG59O1xyXG5cclxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XHJcbnZhciBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcclxuXHJcbi8qKlxyXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIElucHV0XHJcbiAqL1xyXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xyXG4gICAgdGhpcy5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XHJcbiAgICB0aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcclxuXHJcbiAgICB0aGlzLmFsbG93ID0gdHJ1ZTsgLy8gdXNlZCBieSBJbnB1dC5Ub3VjaE1vdXNlIHRvIGRpc2FibGUgbW91c2UgZXZlbnRzXHJcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXHJcblxyXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcclxuXHJcbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcclxuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duLCBhbmQgbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkIChzZWUgdGhlIFRvdWNoTW91c2UgaW5wdXQpXHJcbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQgfHwgIXRoaXMuYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcclxuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXHJcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcclxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXHJcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcclxuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcclxuICAgIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxyXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXHJcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXHJcbiAgICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcclxufTtcclxuXHJcbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXHJcbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xyXG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcclxuICAgIDM6IElOUFVUX1RZUEVfUEVOLFxyXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcclxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxyXG59O1xyXG5cclxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xyXG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcclxuXHJcbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxyXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XHJcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xyXG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XHJcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xyXG4gICAgdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcclxufVxyXG5cclxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcclxuICAgIC8qKlxyXG4gICAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFBFaGFuZGxlcihldikge1xyXG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XHJcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xyXG4gICAgICAgIHZhciBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xyXG5cclxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcclxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xyXG5cclxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXHJcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcclxuICAgICAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcclxuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xyXG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxyXG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxyXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcclxuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcclxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxyXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xyXG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXHJcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXHJcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxyXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxyXG59O1xyXG5cclxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xyXG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xyXG5cclxuLyoqXHJcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgSW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XHJcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XHJcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XHJcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBURWhhbmRsZXIoZXYpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XHJcblxyXG4gICAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cclxuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxyXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XHJcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxyXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxyXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQHRoaXMge1RvdWNoSW5wdXR9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxyXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XHJcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcclxuICAgIHZhciBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XHJcblxyXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xyXG4gICAgICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xyXG59XHJcblxyXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xyXG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXHJcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXHJcbiAgICB0b3VjaGVuZDogSU5QVVRfRU5ELFxyXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxyXG59O1xyXG5cclxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xyXG5cclxuLyoqXHJcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBJbnB1dFxyXG4gKi9cclxuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcclxuICAgIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xyXG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcclxuXHJcbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFRvdWNoSW5wdXQsIElucHV0LCB7XHJcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XHJcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xyXG4gICAgICAgIGlmICghdG91Y2hlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xyXG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcclxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxyXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcclxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xyXG4gICAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xyXG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xyXG5cclxuICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXHJcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGksXHJcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcclxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxyXG4gICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW10sXHJcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcblxyXG4gICAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xyXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcclxuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcclxuICAgIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcclxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xyXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcclxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xyXG4gICAgXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxyXG4gKlxyXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cclxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgSW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcclxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdmFyIGhhbmRsZXIgPSBiaW5kRm4odGhpcy5oYW5kbGVyLCB0aGlzKTtcclxuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xyXG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XHJcbn1cclxuXHJcbmluaGVyaXQoVG91Y2hNb3VzZUlucHV0LCBJbnB1dCwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xyXG4gICAgICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRNRWhhbmRsZXIobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSB7XHJcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxyXG4gICAgICAgICAgICBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX01PVVNFKTtcclxuXHJcbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCBzbyAgYmxvY2sgYWxsIHVwY29taW5nIG1vdXNlIGV2ZW50c1xyXG4gICAgICAgIC8vIG1vc3QgbW9iaWxlIGJyb3dzZXIgYWxzbyBlbWl0IG1vdXNlZXZlbnRzLCByaWdodCBhZnRlciB0b3VjaHN0YXJ0XHJcbiAgICAgICAgaWYgKGlzVG91Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiAhdGhpcy5tb3VzZS5hbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXNldCB0aGUgYWxsb3dNb3VzZSB3aGVuIHdlJ3JlIGRvbmVcclxuICAgICAgICBpZiAoaW5wdXRFdmVudCAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2UuYWxsb3cgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XHJcbnZhciBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XHJcblxyXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXHJcbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcclxudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xyXG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcclxudmFyIFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xyXG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcclxudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XHJcblxyXG4vKipcclxuICogVG91Y2ggQWN0aW9uXHJcbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXHJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBUb3VjaEFjdGlvbihtYW5hZ2VyLCB2YWx1ZSkge1xyXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgIHRoaXMuc2V0KHZhbHVlKTtcclxufVxyXG5cclxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICBpZiAodmFsdWUgPT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcclxuICAgICAqL1xyXG4gICAgY29tcHV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcclxuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xyXG4gICAgICAgICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAgICAgKi9cclxuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICAvLyBub3QgbmVlZGVkIHdpdGggbmF0aXZlIHN1cHBvcnQgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eVxyXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxyXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XHJcbiAgICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSk7XHJcbiAgICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcclxuXHJcbiAgICAgICAgaWYgKGhhc05vbmUgfHxcclxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XHJcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XHJcbiAgICAgKi9cclxuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcclxuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcclxuICAgIC8vIG5vbmVcclxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xyXG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG5cclxuICAgIC8vIHBhbi14IGFuZCBwYW4teSBjYW4gYmUgY29tYmluZWRcclxuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX1BBTl9YICsgJyAnICsgVE9VQ0hfQUNUSU9OX1BBTl9ZO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBhbi14IE9SIHBhbi15XHJcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWFuaXB1bGF0aW9uXHJcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcclxuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXHJcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cclxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXHJcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxyXG4gKlxyXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXHJcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXHJcbiAqXHJcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cclxuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cclxuICpcclxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxyXG4gKiAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xyXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcclxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxyXG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxyXG4gKi9cclxudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcclxudmFyIFNUQVRFX0JFR0FOID0gMjtcclxudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xyXG52YXIgU1RBVEVfRU5ERUQgPSA4O1xyXG52YXIgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xyXG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XHJcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcclxuXHJcbi8qKlxyXG4gKiBSZWNvZ25pemVyXHJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBSZWNvZ25pemVyKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xyXG5cclxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZShvcHRpb25zIHx8IHt9LCB0aGlzLmRlZmF1bHRzKTtcclxuXHJcbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXHJcbiAgICB0aGlzLm9wdGlvbnMuZW5hYmxlID0gaWZVbmRlZmluZWQodGhpcy5vcHRpb25zLmVuYWJsZSwgdHJ1ZSk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xyXG5cclxuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XHJcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XHJcbn1cclxuXHJcblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxyXG4gICAgICovXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICBleHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcclxuICAgICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHJlY29nbml6ZVdpdGg6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XHJcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xyXG4gICAgICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcclxuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XHJcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xyXG4gICAgICovXHJcbiAgICBkcm9wUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgcmVxdWlyZUZhaWx1cmU6IGZ1bmN0aW9uKG90aGVyUmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcclxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGhhc1JlcXVpcmVGYWlsdXJlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgY2FuUmVjb2duaXplV2l0aDogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcclxuICAgICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqL1xyXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZW1pdCh3aXRoU3RhdGUpIHtcclxuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgKHdpdGhTdGF0ZSA/IHN0YXRlU3RyKHN0YXRlKSA6ICcnKSwgaW5wdXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXHJcbiAgICAgICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcclxuICAgICAgICAgICAgZW1pdCh0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVtaXQoKTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xyXG5cclxuICAgICAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxyXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xyXG4gICAgICAgICAgICBlbWl0KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXHJcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXHJcbiAgICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqL1xyXG4gICAgdHJ5RW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcclxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbiB3ZSBlbWl0P1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGNhbkVtaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXHJcbiAgICAgKi9cclxuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XHJcbiAgICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcclxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xyXG4gICAgICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGV4dGVuZCh7fSwgaW5wdXREYXRhKTtcclxuXHJcbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XHJcbiAgICAgICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XHJcblxyXG4gICAgICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxyXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxyXG4gICAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxyXG4gICAgICogQHJldHVybnMge0NvbnN0fSBTVEFURVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dERhdGEpIHsgfSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXHJcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcclxuICogQHBhcmFtIHtDb25zdH0gc3RhdGVcclxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcclxuICovXHJcbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XHJcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcclxuICAgICAgICByZXR1cm4gJ2NhbmNlbCc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcclxuICAgICAgICByZXR1cm4gJ2VuZCc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xyXG4gICAgICAgIHJldHVybiAnbW92ZSc7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcclxuICAgICAgICByZXR1cm4gJ3N0YXJ0JztcclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xyXG4gKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cclxuICogQHJldHVybnMge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcclxuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcclxuICAgICAgICByZXR1cm4gJ2Rvd24nO1xyXG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQKSB7XHJcbiAgICAgICAgcmV0dXJuICd1cCc7XHJcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fTEVGVCkge1xyXG4gICAgICAgIHJldHVybiAnbGVmdCc7XHJcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcclxuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXHJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XHJcbiAgICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcclxuICAgIGlmIChtYW5hZ2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gQXR0clJlY29nbml6ZXIoKSB7XHJcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmluaGVyaXQoQXR0clJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcG9pbnRlcnM6IDFcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcclxuICAgICAqL1xyXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxyXG4gICAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcclxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGlucHV0LmV2ZW50VHlwZTtcclxuXHJcbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XHJcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcclxuXHJcbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxyXG4gICAgICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFBhblxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIHRoaXMucFggPSBudWxsO1xyXG4gICAgdGhpcy5wWSA9IG51bGw7XHJcbn1cclxuXHJcbmluaGVyaXQoUGFuUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBldmVudDogJ3BhbicsXHJcbiAgICAgICAgdGhyZXNob2xkOiAxMCxcclxuICAgICAgICBwb2ludGVyczogMSxcclxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWN0aW9ucztcclxuICAgIH0sXHJcblxyXG4gICAgZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XHJcbiAgICAgICAgdmFyIHkgPSBpbnB1dC5kZWx0YVk7XHJcblxyXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cclxuICAgICAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xyXG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcclxuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxyXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XHJcbiAgICAgICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcclxuXHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBQaW5jaFxyXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gUGluY2hSZWNvZ25pemVyKCkge1xyXG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChQaW5jaFJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqIEBtZW1iZXJvZiBQaW5jaFJlY29nbml6ZXJcclxuICAgICAqL1xyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBldmVudDogJ3BpbmNoJyxcclxuICAgICAgICB0aHJlc2hvbGQ6IDAsXHJcbiAgICAgICAgcG9pbnRlcnM6IDJcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcclxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcclxuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcclxuICAgICAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dCwgaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogUHJlc3NcclxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XHJcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xyXG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xyXG59XHJcblxyXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXHJcbiAgICAgICAgcG9pbnRlcnM6IDEsXHJcbiAgICAgICAgdGltZTogNTAwLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxyXG4gICAgICAgIHRocmVzaG9sZDogNSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XHJcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xyXG4gICAgICAgIHZhciB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XHJcblxyXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XHJcblxyXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XHJcbiAgICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxyXG4gICAgICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcclxuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVcclxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBSb3RhdGVSZWNvZ25pemVyKCkge1xyXG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuaW5oZXJpdChSb3RhdGVSZWNvZ25pemVyLCBBdHRyUmVjb2duaXplciwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUm90YXRlUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAncm90YXRlJyxcclxuICAgICAgICB0aHJlc2hvbGQ6IDAsXHJcbiAgICAgICAgcG9pbnRlcnM6IDJcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xyXG4gICAgfSxcclxuXHJcbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcclxuICAgICAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogU3dpcGVcclxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XHJcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxyXG4gICAgICAgIHRocmVzaG9sZDogMTAsXHJcbiAgICAgICAgdmVsb2NpdHk6IDAuNjUsXHJcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcclxuICAgICAgICBwb2ludGVyczogMVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xyXG4gICAgICAgIHZhciB2ZWxvY2l0eTtcclxuXHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcclxuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC52ZWxvY2l0eTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQudmVsb2NpdHlYO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQudmVsb2NpdHlZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiAmIGlucHV0LmRpcmVjdGlvbiAmJlxyXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcclxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQSB0YXAgaXMgZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcclxuICogYSBzaW5nbGUgdGFwLlxyXG4gKlxyXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcclxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgUmVjb2duaXplclxyXG4gKi9cclxuZnVuY3Rpb24gVGFwUmVjb2duaXplcigpIHtcclxuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXHJcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcclxuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcclxuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcclxuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcclxuICAgIHRoaXMuY291bnQgPSAwO1xyXG59XHJcblxyXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxyXG4gICAgICovXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGV2ZW50OiAndGFwJyxcclxuICAgICAgICBwb2ludGVyczogMSxcclxuICAgICAgICB0YXBzOiAxLFxyXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXHJcbiAgICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxyXG4gICAgICAgIHRocmVzaG9sZDogMiwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcclxuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gICAgICAgIHZhciB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xyXG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcclxuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XHJcblxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuXHJcbiAgICAgICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxyXG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcclxuICAgICAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT0gSU5QVVRfRU5EKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcclxuICAgICAgICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcclxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cclxuICAgICAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcclxuICAgICAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XHJcbiAgICB9LFxyXG5cclxuICAgIGZhaWxUaW1lb3V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xyXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1JFQ09HTklaRUQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhbiBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgb3B0aW9ucy5yZWNvZ25pemVycyA9IGlmVW5kZWZpbmVkKG9wdGlvbnMucmVjb2duaXplcnMsIEhhbW1lci5kZWZhdWx0cy5wcmVzZXQpO1xyXG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtzdHJpbmd9XHJcbiAqL1xyXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNCc7XHJcblxyXG4vKipcclxuICogZGVmYXVsdCBzZXR0aW5nc1xyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5IYW1tZXIuZGVmYXVsdHMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBkb21FdmVudHM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXHJcbiAgICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCBjb21wdXRlXHJcbiAgICAgKi9cclxuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBlbmFibGU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXHJcbiAgICAgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cclxuICAgICAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXHJcbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xyXG4gICAgICogQHR5cGUge051bGx8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuICAgIGlucHV0Q2xhc3M6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcclxuICAgICAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHByZXNldDogW1xyXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxyXG4gICAgICAgIFtSb3RhdGVSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfV0sXHJcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwgeyBlbmFibGU6IGZhbHNlIH0sIFsncm90YXRlJ11dLFxyXG4gICAgICAgIFtTd2lwZVJlY29nbml6ZXIseyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH1dLFxyXG4gICAgICAgIFtQYW5SZWNvZ25pemVyLCB7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfSwgWydzd2lwZSddXSxcclxuICAgICAgICBbVGFwUmVjb2duaXplcl0sXHJcbiAgICAgICAgW1RhcFJlY29nbml6ZXIsIHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0sIFsndGFwJ11dLFxyXG4gICAgICAgIFtQcmVzc1JlY29nbml6ZXJdXHJcbiAgICBdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cclxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqL1xyXG4gICAgY3NzUHJvcHM6IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cclxuICAgICAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcclxuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29udGVudFpvb21pbmc6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcclxuICAgICAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgU1RPUCA9IDE7XHJcbnZhciBGT1JDRURfU1RPUCA9IDI7XHJcblxyXG4vKipcclxuICogTWFuYWdlclxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIEhhbW1lci5kZWZhdWx0cyk7XHJcbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHJcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XHJcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcclxuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcclxuXHJcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XHJcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XHJcblxyXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XHJcblxyXG4gICAgZWFjaChvcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcclxuICAgICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcclxuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XHJcbiAgICB9LCB0aGlzKTtcclxufVxyXG5cclxuTWFuYWdlci5wcm90b3R5cGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIHNldCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XHJcbiAgICAgKi9cclxuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXHJcbiAgICAgICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cclxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXHJcbiAgICAgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxyXG4gICAgICovXHJcbiAgICBzdG9wOiBmdW5jdGlvbihmb3JjZSkge1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcclxuICAgICAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcclxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxyXG4gICAgICovXHJcbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xyXG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xyXG4gICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcjtcclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG5cclxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cclxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXHJcbiAgICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxyXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xyXG5cclxuICAgICAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxyXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxyXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcclxuICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxyXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcclxuICAgICAgICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXHJcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxyXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cclxuICAgICAgICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXHJcbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxyXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXHJcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxyXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxyXG4gICAgICovXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcclxuICAgICAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT0gcmVjb2duaXplcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcclxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XHJcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcclxuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZTogZnVuY3Rpb24ocmVjb2duaXplcikge1xyXG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xyXG4gICAgICAgIHJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcclxuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplciksIDEpO1xyXG5cclxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIGJpbmQgZXZlbnRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XHJcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XHJcbiAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cclxuICAgICAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcclxuICAgICAqL1xyXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xyXG4gICAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAgICAgKi9cclxuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcclxuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xyXG4gICAgICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcclxuICAgICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXHJcbiAgICAgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxyXG4gICAgICovXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5zZXNzaW9uID0ge307XHJcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcclxuICovXHJcbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XHJcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBlbGVtZW50LnN0eWxlW3ByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpXSA9IGFkZCA/IHZhbHVlIDogJyc7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XHJcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcclxuICAgIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcclxuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcclxufVxyXG5cclxuZXh0ZW5kKEhhbW1lciwge1xyXG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxyXG4gICAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcclxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxyXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXHJcblxyXG4gICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxyXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxyXG4gICAgU1RBVEVfQ0hBTkdFRDogU1RBVEVfQ0hBTkdFRCxcclxuICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcclxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXHJcbiAgICBTVEFURV9DQU5DRUxMRUQ6IFNUQVRFX0NBTkNFTExFRCxcclxuICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxyXG5cclxuICAgIERJUkVDVElPTl9OT05FOiBESVJFQ1RJT05fTk9ORSxcclxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcclxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxyXG4gICAgRElSRUNUSU9OX1VQOiBESVJFQ1RJT05fVVAsXHJcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXHJcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXHJcbiAgICBESVJFQ1RJT05fVkVSVElDQUw6IERJUkVDVElPTl9WRVJUSUNBTCxcclxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXHJcblxyXG4gICAgTWFuYWdlcjogTWFuYWdlcixcclxuICAgIElucHV0OiBJbnB1dCxcclxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcclxuXHJcbiAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxyXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcclxuICAgIFBvaW50ZXJFdmVudElucHV0OiBQb2ludGVyRXZlbnRJbnB1dCxcclxuICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxyXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcclxuXHJcbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxyXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxyXG4gICAgVGFwOiBUYXBSZWNvZ25pemVyLFxyXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxyXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcclxuICAgIFBpbmNoOiBQaW5jaFJlY29nbml6ZXIsXHJcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXHJcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxyXG5cclxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcclxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXHJcbiAgICBlYWNoOiBlYWNoLFxyXG4gICAgbWVyZ2U6IG1lcmdlLFxyXG4gICAgZXh0ZW5kOiBleHRlbmQsXHJcbiAgICBpbmhlcml0OiBpbmhlcml0LFxyXG4gICAgYmluZEZuOiBiaW5kRm4sXHJcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcclxufSk7XHJcblxyXG5pZiAodHlwZW9mIGRlZmluZSA9PSBUWVBFX0ZVTkNUSU9OICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gSGFtbWVyO1xyXG4gICAgfSk7XHJcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XHJcbn0gZWxzZSB7XHJcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XHJcbn1cclxuXHJcbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBNaW5pbWFsaXN0aWMgZXZlbnQgZW1pdHRlciBtaXhpbi5cbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge31cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuIElmIHRoZSBsaXN0ZW5lciBoYXNcbiAqIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgZXZlbnQsIHRoaXMgaXMgYSBuby1vcC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgdmFyIGV2ZW50TWFwID0gdGhpcy5fX2V2ZW50cyA9IHRoaXMuX19ldmVudHMgfHwge307XG4gIHZhciBoYW5kbGVyTGlzdCA9IGV2ZW50TWFwW25hbWVdID0gZXZlbnRNYXBbbmFtZV0gfHwgW107XG4gIGlmIChoYW5kbGVyTGlzdC5pbmRleE9mKGZuKSA8IDApIHtcbiAgICBoYW5kbGVyTGlzdC5wdXNoKGZuKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQuIElmIHRoZSBsaXN0ZW5lclxuICogaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhlIGV2ZW50LCB0aGlzIGlzIGEgbm8tb3AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gIHZhciBldmVudE1hcCA9IHRoaXMuX19ldmVudHMgPSB0aGlzLl9fZXZlbnRzIHx8IHt9O1xuICB2YXIgaGFuZGxlckxpc3QgPSBldmVudE1hcFtuYW1lXTtcbiAgaWYgKGhhbmRsZXJMaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gaGFuZGxlckxpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGhhbmRsZXJMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEVtaXRzIGFuIGV2ZW50LCBjYXVzaW5nIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhhdCBldmVudCB0byBiZVxuICogY2FsbGVkIGluIHJlZ2lzdHJhdGlvbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQXJndW1lbnRzIHRvIGNhbGwgbGlzdGVuZXJzIHdpdGguXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKG5hbWUsIHZhcl9hcmdzKSB7XG4gIHZhciBldmVudE1hcCA9IHRoaXMuX19ldmVudHMgPSB0aGlzLl9fZXZlbnRzIHx8IHt9O1xuICB2YXIgaGFuZGxlckxpc3QgPSBldmVudE1hcFtuYW1lXTtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm4gPSBoYW5kbGVyTGlzdFtpXTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNaXhlcyBpbiB7QGxpbmsgRXZlbnRFbWl0dGVyfSBpbnRvIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGV2ZW50RW1pdHRlcihjdG9yKSB7XG4gIGZvciAodmFyIHByb3AgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIGlmIChFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBjdG9yLnByb3RvdHlwZVtwcm9wXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbcHJvcF07XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXZlbnRFbWl0dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIEBjbGFzcyBEZXB0aG1hcFN0b3JlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBEZXB0aG1hcFN0b3JlIG1haW50YWlucyBhIGNhY2hlIG9mIGRlcHRobWFwIGRhdGEgdXNlZCB0byByZW5kZXIgYSB7QGxpbmsgTGF5ZXJ9LlxuICpcbiAqIE11bHRpcGxlIGxheWVycyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgdW5kZXJseWluZyB7QGxpbmsgV2ViR2xTdGFnZX0gbWF5XG4gKiBzaGFyZSB0aGUgc2FtZSBEZXB0aG1hcFN0b3JlLiBMYXllcnMgYmVsb25naW5nIHRvIGRpc3RpbmN0IHtAbGluayBXZWJHbFN0YWdlfVxuICogaW5zdGFuY2VzIG1heSBub3QgZG8gc28gZHVlIHRvIHJlc3RyaWN0aW9ucyBvbiB0aGUgdXNlIG9mIHRleHR1cmVzIGFjcm9zc1xuICogc3RhZ2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHVuZGVybHlpbmcgc291cmNlIHVybC5cbiAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSB1bmRlcmx5aW5nIHN0YWdlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gRGVwdGhtYXBTdG9yZShzb3VyY2UsIHN0YWdlLCBvcHRzKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHNlbGYuX3NvdXJjZSA9IHNvdXJjZTtcbiAgc2VsZi5fc3RhZ2UgPSBzdGFnZTtcblxuICBzZWxmLl9hc3NldCA9IG51bGw7XG4gIHNlbGYuX3RleHR1cmUgPSBudWxsO1xuICBzZWxmLl9jdWJlVGV4dHVyZSA9IG51bGw7XG5cbiAgLy8gVE9ETyBPdGhlciB0eXBlcyBvZiBkZXB0aG1hcC5cbiAgc2VsZi5fc291cmNlVHlwZSA9IHNvdXJjZS5zcGxpdCgnLicpLnBvcCgpO1xuICBpZiAoc2VsZi5fc291cmNlVHlwZSA9PSAnc3RsJykge1xuICAgIC8vIExvYWQgU1RMIGZpbGUuXG4gICAgc3RhZ2UubG9hZE1vZGVsKHNvdXJjZSwgZnVuY3Rpb24oZXJyLCB7IHBvc2l0aW9ucywgaW5kaWNlcyB9KSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSAzRCBtb2RlbCBhcyBkZXB0aCBjdWJlIHRleHR1cmUuXG4gICAgICBzZWxmLmNyZWF0ZUN1YmVUZXh0dXJlKHNlbGYuX3N0YWdlLl9nbCwgcG9zaXRpb25zLCBpbmRpY2VzKTtcblxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN0YWdlLmxvYWRJbWFnZShzb3VyY2UsIG51bGwsIGZ1bmN0aW9uIChlcnIsIGFzc2V0KSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3RhZ2UuY3JlYXRlVGV4dHVyZShudWxsLCBhc3NldCwgZnVuY3Rpb24gKGVyciwgX3RpbGUsIGFzc2V0LCB0ZXh0dXJlKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9hc3NldCA9IGFzc2V0O1xuICAgICAgICBzZWxmLl90ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV2ZW50RW1pdHRlcihEZXB0aG1hcFN0b3JlKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkRlcHRobWFwU3RvcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGdsID0gdGhpcy5fc3RhZ2UuX2dsO1xuICB2YXIgYXNzZXQgPSB0aGlzLl9hc3NldDtcbiAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICB2YXIgY3ViZVRleHR1cmUgPSB0aGlzLl9jdWJlVGV4dHVyZTtcblxuICAvLyBEZXN0cm95IGFzc2V0LlxuICBpZiAoYXNzZXQpIHtcbiAgICBhc3NldC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBEZXN0cm95IHRleHR1cmUuXG4gIGlmICh0ZXh0dXJlKSB7XG4gICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBEZXN0cm95IGN1YmUgdGV4dHVyZS5cbiAgaWYgKGN1YmVUZXh0dXJlKSB7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZShjdWJlVGV4dHVyZSk7XG4gIH1cblxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG4vLyBUT0RPIE9wdGltaXplIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zLlxuZnVuY3Rpb24gRShnbCwgYSwgYiwgYykge1xuICBnbC50ZXhQYXJhbWV0ZXJpKGEsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShhLCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoYSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBiKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShhLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGMgPyBnbC5MSU5FQVIgOiBiKVxufVxuXG5mdW5jdGlvbiB6YSgpIHtcbiAgdmFyIGwgPSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgRmxvYXQzMkFycmF5ID8gbmV3IEZsb2F0MzJBcnJheSgxNikgOiBBcnJheSgxNik7XG4gIGRmKGwpO1xuICByZXR1cm4gbFxufVxuXG5mdW5jdGlvbiBkZihsKSB7XG4gIGxbMF0gPSBsWzVdID0gbFsxMF0gPSBsWzE1XSA9IDE7XG4gIGxbMV0gPSBsWzJdID0gbFszXSA9IGxbNF0gPSBsWzZdID0gbFs3XSA9IGxbOF0gPSBsWzldID0gbFsxMV0gPSBsWzEyXSA9IGxbMTNdID0gbFsxNF0gPSAwXG59XG5cbmZ1bmN0aW9uIFJkKGwsIGEsIGMsIGIsIGQsIE8sIEIsIGYsIGssIG4sIGUsIGgsIHAsIG0sIGcsIHosIHkpIHtcbiAgbFswXSA9IGE7XG4gIGxbMV0gPSBjO1xuICBsWzJdID0gYjtcbiAgbFszXSA9IGQ7XG4gIGxbNF0gPSBPO1xuICBsWzVdID0gQjtcbiAgbFs2XSA9IGY7XG4gIGxbN10gPSBrO1xuICBsWzhdID0gbjtcbiAgbFs5XSA9IGU7XG4gIGxbMTBdID0gaDtcbiAgbFsxMV0gPSBwO1xuICBsWzEyXSA9IG07XG4gIGxbMTNdID0gZztcbiAgbFsxNF0gPSB6O1xuICBsWzE1XSA9IHlcbn1cblxuZnVuY3Rpb24gemQobCwgYSwgYywgYiwgZCwgTywgQiwgZiwgaywgbikge1xuICBsWzBdID0gYTtcbiAgbFsxXSA9IGM7XG4gIGxbMl0gPSBiO1xuICBsWzNdID0gMDtcbiAgbFs0XSA9IGQ7XG4gIGxbNV0gPSBPO1xuICBsWzZdID0gQjtcbiAgbFs3XSA9IDA7XG4gIGxbOF0gPSBmO1xuICBsWzldID0gaztcbiAgbFsxMF0gPSBuO1xuICBsWzExXSA9IDA7XG4gIGxbMTJdID0gMDtcbiAgbFsxM10gPSAwO1xuICBsWzE0XSA9IDA7XG4gIGxbMTVdID0gMVxufVxuXG5mdW5jdGlvbiB5ZShsLCBhLCBjLCBiLCBkKSB7XG4gIFJkKGwsIGEsIDAsIDAsIDAsIDAsIGEsIDAsIDAsIGIsIGQsIDEsIDAsIGMgKiBiLCBjICogZCwgYywgMSlcbn1cblxuZnVuY3Rpb24gU2IobCwgYSkge1xuICB2YXIgYyA9IGFbMF1cbiAgICAsIGIgPSBhWzFdXG4gICAgLCBkID0gYVsyXVxuICAgICwgTyA9IGFbM11cbiAgICAsIEIgPSBhWzRdXG4gICAgLCBmID0gYVs1XVxuICAgICwgayA9IGFbNl1cbiAgICAsIG4gPSBhWzddXG4gICAgLCBlID0gYVs4XVxuICAgICwgaCA9IGFbOV1cbiAgICAsIHAgPSBhWzEwXVxuICAgICwgbSA9IGFbMTFdXG4gICAgLCBnID0gYVsxMl1cbiAgICAsIHogPSBhWzEzXVxuICAgICwgeSA9IGFbMTRdXG4gICAgLCB4ID0gYVsxNV1cbiAgICAsIEEgPSBsWzBdXG4gICAgLCBFID0gbFsxXVxuICAgICwgQyA9IGxbMl1cbiAgICAsIHEgPSBsWzNdO1xuICBsWzBdID0gQSAqIGMgKyBFICogQiArIEMgKiBlICsgcSAqIGc7XG4gIGxbMV0gPSBBICogYiArIEUgKiBmICsgQyAqIGggKyBxICogejtcbiAgbFsyXSA9IEEgKiBkICsgRSAqIGsgKyBDICogcCArIHEgKiB5O1xuICBsWzNdID0gQSAqIE8gKyBFICogbiArIEMgKiBtICsgcSAqIHg7XG4gIEEgPSBsWzRdO1xuICBFID0gbFs1XTtcbiAgQyA9IGxbNl07XG4gIHEgPSBsWzddO1xuICBsWzRdID0gQSAqIGMgKyBFICogQiArIEMgKiBlICsgcSAqIGc7XG4gIGxbNV0gPSBBICogYiArIEUgKiBmICsgQyAqIGggKyBxICogejtcbiAgbFs2XSA9IEEgKiBkICsgRSAqIGsgKyBDICogcCArIHEgKiB5O1xuICBsWzddID0gQSAqIE8gKyBFICogbiArIEMgKiBtICsgcSAqIHg7XG4gIEEgPSBsWzhdO1xuICBFID0gbFs5XTtcbiAgQyA9IGxbMTBdO1xuICBxID0gbFsxMV07XG4gIGxbOF0gPSBBICogYyArIEUgKiBCICsgQyAqIGUgKyBxICogZztcbiAgbFs5XSA9IEEgKiBiICsgRSAqIGYgKyBDICogaCArIHEgKiB6O1xuICBsWzEwXSA9IEEgKiBkICsgRSAqIGsgKyBDICogcCArIHEgKiB5O1xuICBsWzExXSA9IEEgKiBPICsgRSAqIG4gKyBDICogbSArIHEgKiB4O1xuICBBID0gbFsxMl07XG4gIEUgPSBsWzEzXTtcbiAgQyA9IGxbMTRdO1xuICBxID0gbFsxNV07XG4gIGxbMTJdID0gQSAqIGMgKyBFICogQiArIEMgKiBlICsgcSAqIGc7XG4gIGxbMTNdID0gQSAqIGIgKyBFICogZiArIEMgKiBoICsgcSAqIHo7XG4gIGxbMTRdID0gQSAqIGQgKyBFICogayArIEMgKiBwICsgcSAqIHk7XG4gIGxbMTVdID0gQSAqIE8gKyBFICogbiArIEMgKiBtICsgcSAqIHg7XG59XG5cbmZ1bmN0aW9uIEdkKGwsIGEsIGMsIGIpIHtcblxuICBjb25zdCBpYSA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1O1xuXG4gIHZhciBkLCBPLCBnO1xuICBkID0gYyAqIGlhO1xuICBjID0gTWF0aC5jb3MoZCk7XG4gIE8gPSBNYXRoLnNpbihkKTtcbiAgZCA9IC1hICogaWE7XG4gIGEgPSBNYXRoLmNvcyhkKTtcbiAgZyA9IE1hdGguc2luKGQpO1xuICBkID0gLWIgKiBpYTtcbiAgYiA9IE1hdGguY29zKGQpO1xuICBkID0gTWF0aC5zaW4oZCk7XG4gIHpkKGwsIC1nICogYiAtIGEgKiBPICogZCwgLWcgKiBkICsgYSAqIE8gKiBiLCAtYSAqIGMsIC1jICogZCwgYyAqIGIsIE8sIGEgKiBiIC0gZyAqIE8gKiBkLCBhICogZCArIGcgKiBPICogYiwgLWcgKiBjKTtcbn1cblxuZnVuY3Rpb24gQWQobCwgYSwgYywgYikge1xuICBSZChsLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCBhLCBjLCBiLCAxKVxufVxuXG5mdW5jdGlvbiBzZShsLCBhKSB7XG4gIHZhciBjID0gbFswXVxuICAgICwgYiA9IGxbMV1cbiAgICAsIGQgPSBsWzJdXG4gICAgLCBPID0gbFszXVxuICAgICwgZyA9IGxbNF1cbiAgICAsIGYgPSBsWzVdXG4gICAgLCBrID0gbFs2XVxuICAgICwgbiA9IGxbN11cbiAgICAsIGUgPSBsWzhdXG4gICAgLCBoID0gbFs5XVxuICAgICwgcCA9IGxbMTBdXG4gICAgLCBtID0gbFsxMV1cbiAgICAsIEkgPSBsWzEyXVxuICAgICwgeiA9IGxbMTNdXG4gICAgLCB5ID0gbFsxNF1cbiAgICAsIHggPSBsWzE1XVxuICAgICwgQSA9IGFbMF1cbiAgICAsIEUgPSBhWzFdXG4gICAgLCBDID0gYVsyXVxuICAgICwgcSA9IGFbM11cbiAgICAsIHYgPSBhWzRdXG4gICAgLCBNID0gYVs1XVxuICAgICwgdSA9IGFbNl1cbiAgICAsIFEgPSBhWzddXG4gICAgLCBGID0gYVs4XVxuICAgICwgYWEgPSBhWzldXG4gICAgLCBVID0gYVsxMF1cbiAgICAsIHcgPSBhWzExXVxuICAgICwgeWMgPSBhWzEyXVxuICAgICwgSGEgPSBhWzEzXVxuICAgICwgciA9IGFbMTRdXG4gICAgLCBKID0gYVsxNV07XG4gIGxbMF0gPSBBICogYyArIEUgKiBnICsgQyAqIGUgKyBxICogSTtcbiAgbFsxXSA9IEEgKiBiICsgRSAqIGYgKyBDICogaCArIHEgKiB6O1xuICBsWzJdID0gQSAqIGQgKyBFICogayArIEMgKiBwICsgcSAqIHk7XG4gIGxbM10gPSBBICogTyArIEUgKiBuICsgQyAqIG0gKyBxICogeDtcbiAgbFs0XSA9IHYgKiBjICsgTSAqIGcgKyB1ICogZSArIFEgKiBJO1xuICBsWzVdID0gdiAqIGIgKyBNICogZiArIHUgKiBoICsgUSAqIHo7XG4gIGxbNl0gPSB2ICogZCArIE0gKiBrICsgdSAqIHAgKyBRICogeTtcbiAgbFs3XSA9IHYgKiBPICsgTSAqIG4gKyB1ICogbSArIFEgKiB4O1xuICBsWzhdID0gRiAqIGMgKyBhYSAqIGcgKyBVICogZSArIHcgKiBJO1xuICBsWzldID0gRiAqIGIgKyBhYSAqIGYgKyBVICogaCArIHcgKiB6O1xuICBsWzEwXSA9IEYgKiBkICsgYWEgKiBrICsgVSAqIHAgKyB3ICogeTtcbiAgbFsxMV0gPSBGICogTyArIGFhICogbiArIFUgKiBtICsgdyAqIHg7XG4gIGxbMTJdID0geWMgKiBjICsgSGEgKiBnICsgciAqIGUgKyBKICogSTtcbiAgbFsxM10gPSB5YyAqIGIgKyBIYSAqIGYgKyByICogaCArIEogKiB6O1xuICBsWzE0XSA9IHljICogZCArIEhhICogayArIHIgKiBwICsgSiAqIHk7XG4gIGxbMTVdID0geWMgKiBPICsgSGEgKiBuICsgciAqIG0gKyBKICogeFxufVxuXG5mdW5jdGlvbiBuYShnbCwgcHJvZ3JhbSwgdmVydGljZXNCdWZmZXIsIGluZGljZXNCdWZmZXIsIHZlcnRpY2VzQXJyYXksIGluZGljZXNBcnJheSkge1xuXG4gIGNvbnN0IHNpemUgPSA1MTI7XG4gIGNvbnN0IGUgPSBbXG4gICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aLFxuICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCxcbiAgICBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1osXG4gICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLFxuICAgIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSxcbiAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksXG4gIF07XG5cbiAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlKTtcbiAgRShnbCwgZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuTkVBUkVTVCwgZmFsc2UpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgIGdsLnRleEltYWdlMkQoZVtpXSwgMCwgZ2wuUkdCQSwgc2l6ZSwgc2l6ZSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gIH1cbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG5cbiAgdmFyIHJlbmRlckJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyQnVmZmVyKTtcbiAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBzaXplLCBzaXplKTtcblxuICBsZXQgaCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgIGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGVbaV0sIHRleHR1cmUsIDApO1xuICAgIGgucHVzaChmcmFtZUJ1ZmZlcik7XG4gIH1cblxuICAvL2UgPSBkYS51c2VTaGFkZXIoYiwgNjIpO1xuICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gIGxldCB0ID0gemEoKTtcbiAgbGV0IGMgPSB6YSgpO1xuICB2YXIgayA9IHphKCk7XG5cbiAgdmFyIHAgPSAtMSAvIC05OTk5OS45O1xuICB2YXIgbSA9IDEgLyAoc2l6ZSAvIDIpO1xuXG4gIFJkKGMsIG0sIDAsIDAsIDAsIDAsIC1tLCAwLCAwLCAwLCAwLCAxMDAwMDAuMSAqIHAsIDEsIDAsIDAsIC0oMmU0ICogcCksIDApO1xuICB5ZShrLCBzaXplIC8gMiwgMCwgMCwgMCk7XG4gIFNiKGssIGMpO1xuXG4gIGNvbnN0IG1wID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdtcCcpO1xuICBnbC51bmlmb3JtTWF0cml4NGZ2KG1wLCBmYWxzZSwgayk7XG5cbiAgY29uc3Qgdmlld1BvcnQgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuVklFV1BPUlQpO1xuICBnbC52aWV3cG9ydCgwLCAwLCBzaXplLCBzaXplKTtcblxuICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICBnbC5ibGVuZEZ1bmMoZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICB2YXIgcCA9IHsgeDogMCwgeTogMCwgejogMCB9O1xuICB2YXIgRyA9IHZlcnRpY2VzQXJyYXk7XG4gIHZhciBuID0gRy5sZW5ndGg7XG5cbiAgdmFyIHEgPSAxZTc7XG4gIHZhciBtID0gMDtcbiAgdmFyIEgsIHIsIHU7XG5cbiAgZm9yIChjID0gMDsgYyA8IG47IGMgKz0gMykge1xuICAgIEggPSBHW2NdO1xuICAgIHIgPSBHW2MgKyAxXTtcbiAgICB1ID0gR1tjICsgMl07XG4gICAgSCA9IEggKiBIICsgciAqIHIgKyB1ICogdTtcbiAgICBIIDwgcSAmJiAocSA9IEgpO1xuICAgIEggPiBtICYmIChtID0gSCk7XG4gIH1cblxuICBNYXRoLnNxcnQocSk7XG4gIG0gPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KG0pICsgLypwLmxlbmd0aCgpKi8gMCk7XG4gIC8vbSAqPSAvKmEuZmFyc2NhbGUqLyAxO1xuXG4gIC8vZ2wudW5pZm9ybTFmKGUuciwgbSk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlc0J1ZmZlcik7XG4gIGNvbnN0IHZ4ID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKTtcbiAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodngpO1xuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZ4LCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRpY2VzQnVmZmVyKTtcbiAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgRyA9IHphKCk7XG5cbiAgY29uc3QgbXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ214Jyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBoW2ldKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJCdWZmZXIpO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcblxuICAgIEdkKHQsIGkgPCA0ID8gOTAgKiAoaSAtIDApIDogOTAsIGkgPT0gNCA/IDkwIDogaSA9PSA1ID8gLTkwIDogMCwgMCk7ICAgIC8vIFJvdGF0aW9uP1xuICAgIEFkKEcsIC0xICogcC56LCAxICogcC55LCAxICogcC54KTtcbiAgICBzZSh0LCBHKTtcbiAgICBcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KG14LCBmYWxzZSwgdCk7XG4gICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgaW5kaWNlc0FycmF5Lmxlbmd0aCwgZ2wuVU5TSUdORURfSU5ULCAwKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgfVxuXG4gIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICBnbC52aWV3cG9ydCh2aWV3UG9ydFswXSwgdmlld1BvcnRbMV0sIHZpZXdQb3J0WzJdLCB2aWV3UG9ydFszXSk7XG4gIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihyZW5kZXJCdWZmZXIpO1xuXG4gIHJldHVybiB0ZXh0dXJlO1xufVxuXG4vKipcbiAqIE1ha2UgM0QgbW9kZWwgYXMgZGVwdGggY3ViZSB0ZXh0dXJlLi5cbiAqIEBwYXJhbSB7QXJyYXl9IHBvc2l0aW9ucyAzRCBtb2RlbCBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIDNEIG1vZGVsIGluZGljaWVzLlxuICovXG5EZXB0aG1hcFN0b3JlLnByb3RvdHlwZS5jcmVhdGVDdWJlVGV4dHVyZSA9IGZ1bmN0aW9uIChnbCwgcG9zaXRpb25zLCBpbmRpY2VzKSB7XG5cbiAgZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKTtcblxuICAvLyBEZWZpbmUgdGhlIHZlcnRleCBzaGFkZXIgY29kZVxuICBjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcbiAgICB1bmlmb3JtIG1hdDQgbXgsIG1wO1xuXG4gICAgdmFyeWluZyBmbG9hdCB3O1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjNCB2ID0gbXAgKiBteCAqIHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcbiAgICAgIGdsX1Bvc2l0aW9uID0gdjtcbiAgICAgIHcgPSB2Lnc7XG4gICAgfVxuICBgO1xuXG4gIC8vIERlZmluZSB0aGUgZnJhZ21lbnQgc2hhZGVyIGNvZGVcbiAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjZWxzZVxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAjZW5kaWZcblxuICAgIHZhcnlpbmcgZmxvYXQgdztcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzMgYjtcbiAgICAgIGIueCA9IChnbF9GcmFnQ29vcmQueC0yNTYuMCkvMjU1LjUsXG4gICAgICBiLnkgPSAoZ2xfRnJhZ0Nvb3JkLnktMjU2LjApLzI1NS41LFxuICAgICAgYi56ID0gLTEuMDtcblxuICAgICAgZmxvYXQgZSA9IGxlbmd0aChiKTtcbiAgICAgIGZsb2F0IGMgPSAxLjAgLSB3KmUvMTUuMDtcbiAgICAgIGMgPSBjICogMjU1LjAgKiAyNTUuMCAqIDI1NS4wO1xuXG4gICAgICB2ZWM0IGE7XG4gICAgICBhLnIgPSBmbG9vcihjLzI1Ni4wLzI1Ni4wKSxcbiAgICAgIGEuZyA9IGZsb29yKChjLWEucioyNTYuMCoyNTYuMCkvMjU2LjApLFxuICAgICAgYS5iID0gZmxvb3IoYy1hLnIqMjU2LjAqMjU2LjAtYS5nKjI1Ni4wKSxcbiAgICAgIGEgLz0gMjU1LjAsXG4gICAgICBhLmEgPSAxLjA7XG5cbiAgICAgIGdsX0ZyYWdDb2xvciA9IGE7XG4gICAgfVxuICBgO1xuXG4gIC8vIENyZWF0ZSBhbmQgY29tcGlsZSB0aGUgc2hhZGVyc1xuICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG5cbiAgLy8gQ3JlYXRlIHRoZSBzaGFkZXIgcHJvZ3JhbSBhbmQgYXR0YWNoIHRoZSBzaGFkZXJzXG4gIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAvLyBDb252ZXJ0IHRoZSB2ZXJ0aWNlcyBhbmQgaW5kaWNlcyB0byBGbG9hdDMyQXJyYXkgYW5kIFVpbnQzMkFycmF5XG4gIGNvbnN0IHZlcnRpY2VzQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyk7XG4gIGNvbnN0IGluZGljZXNBcnJheSA9IG5ldyBVaW50MzJBcnJheShpbmRpY2VzKTtcblxuICAvLyBDcmVhdGUgYW5kIGJpbmQgdGhlIGJ1ZmZlciBmb3IgdGhlIHJlY3RhbmdsZSB2ZXJ0aWNlc1xuICBjb25zdCB2ZXJ0aWNlc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXNCdWZmZXIpO1xuICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXNBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gIGNvbnN0IGluZGljZXNCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlc0J1ZmZlcik7XG4gIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGljZXNBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gIHRoaXMuX2N1YmVUZXh0dXJlID0gbmEoZ2wscHJvZ3JhbSwgdmVydGljZXNCdWZmZXIsIGluZGljZXNCdWZmZXIsIHZlcnRpY2VzQXJyYXksIGluZGljZXNBcnJheSk7XG5cbiAgLy8gRGVsZXRlIHJlc291cmNlcy5cbiAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gIGdsLmRlbGV0ZUJ1ZmZlcih2ZXJ0aWNlc0J1ZmZlcik7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihpbmRpY2VzQnVmZmVyKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB1bmRlcmx5aW5nIHtAbGluayBTdGFnZX0uXG4gKiBAcmV0dXJuIHtTdGFnZX1cbiAqL1xuRGVwdGhtYXBTdG9yZS5wcm90b3R5cGUuc3RhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9zdGFnZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRGVwdGhtYXBTdG9yZS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc291cmNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHVuZGVybHlpbmcgc291cmNlIHR5cGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkRlcHRobWFwU3RvcmUucHJvdG90eXBlLnNvdXJjZVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9zb3VyY2VUeXBlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlcHRobWFwIGFzc2V0IHtAbGluayBTb3VyY2V9LlxuICogQHJldHVybiB7QXNzZXR9XG4gKi9cbkRlcHRobWFwU3RvcmUucHJvdG90eXBlLmFzc2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fYXNzZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZGVwdGhtYXAgdGV4dHVyZSB7QGxpbmsgV2ViR2xUZXh0dXJlfS5cbiAqIEByZXR1cm4ge1dlYkdsVGV4dHVyZX1cbiAqL1xuRGVwdGhtYXBTdG9yZS5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZGVwdGhtYXAgY3ViZSB0ZXh0dXJlLlxuICovXG5EZXB0aG1hcFN0b3JlLnByb3RvdHlwZS5jdWJlVGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2N1YmVUZXh0dXJlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXB0aG1hcFN0b3JlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgcG9zaXRpb25BYnNvbHV0ZWx5ID0gcmVxdWlyZSgnLi91dGlsL3Bvc2l0aW9uQWJzb2x1dGVseScpO1xudmFyIHNldFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXRUcmFuc2Zvcm07XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIEBjbGFzcyBIb3RzcG90XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBIb3RzcG90IGFsbG93cyBhIERPTSBlbGVtZW50IHRvIGJlIHBsYWNlZCBhdCBhIGZpeGVkIHBvc2l0aW9uIGluIHRoZVxuICogaW1hZ2UuIFRoZSBwb3NpdGlvbiBpcyB1cGRhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUge0BsaW5rIFZpZXcgdmlld31cbiAqIGNoYW5nZXMuXG4gKlxuICogUG9zaXRpb25pbmcgaXMgcGVyZm9ybWVkIHdpdGggdGhlIGB0cmFuc2Zvcm1gIENTUyBwcm9wZXJ0eSB3aGVuIGF2YWlsYWJsZSxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgYHBvc2l0aW9uYCwgYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzIHdoZW4gbm90LlxuICogSW4gYm90aCBjYXNlcywgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgZWxlbWVudCBpcyBwbGFjZWQgaW4gdGhlIHJlcXVlc3RlZFxuICogcG9zaXRpb247IGNsaWVudHMgYXJlIGV4cGVjdGVkIHRvIHVzZSBhZGRpdGlvbmFsIGNoaWxkcmVuIGVsZW1lbnRzIG9yIG90aGVyXG4gKiBDU1MgcHJvcGVydGllcyB0byBhY2hpZXZlIG1vcmUgc29waGlzdGljYXRlZCBsYXlvdXRzLlxuICpcbiAqIFRoZXJlIGFyZSB0d28ga2luZHMgb2YgaG90c3BvdHM6IHJlZ3VsYXIgYW5kIGVtYmVkZGVkLiBBIHJlZ3VsYXIgaG90c3BvdFxuICogZG9lcyBub3QgY2hhbmdlIHNpemUgZGVwZW5kaW5nIG9uIHRoZSB6b29tIGxldmVsLiBBbiBlbWJlZGRlZCBob3RzcG90IGlzXG4gKiBkaXNwbGF5ZWQgYXQgYSBmaXhlZCBzaXplIHJlbGF0aXZlIHRvIHRoZSBwYW5vcmFtYSwgYWx3YXlzIGNvdmVyaW5nIHRoZVxuICogc2FtZSBwb3J0aW9uIG9mIHRoZSBpbWFnZS5cbiAqXG4gKiBDbGllbnRzIHNob3VsZCBjYWxsIHtAbGluayBIb3RzcG90Q29udGFpbmVyI2NyZWF0ZUhvdHNwb3R9IGluc3RlYWQgb2ZcbiAqIGludm9raW5nIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbUVsZW1lbnQgVGhlIERPTSBlbGVtZW50LlxuICogQHBhcmFtIHtWaWV3fSB2aWV3IFRoZSB2aWV3LlxuICogQHBhcmFtIHtPYmplY3R9IGNvb3JkcyBUaGUgaG90c3BvdCBjb29yZGluYXRlcy5cbiAqICAgICBVc2Uge0BsaW5rIFJlY3RpbGluZWFyVmlld0Nvb3Jkc30gZm9yIGEge0BsaW5rIFJlY3RpbGluZWFyVmlld30gb3JcbiAqICAgICB7QGxpbmsgRmxhdFZpZXdDb29yZHN9IGZvciBhIHtAbGluayBGbGF0Vmlld30uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wZXJzcGVjdGl2ZSBQZXJzcGVjdGl2ZSBvcHRpb25zIGZvciBlbWJlZGRlZCBob3RzcG90cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5wZXJzcGVjdGl2ZS5yYWRpdXM9bnVsbF0gSWYgc2V0LCBlbWJlZCB0aGUgaG90c3BvdFxuICogICAgIGludG8gdGhlIGltYWdlIGJ5IHRyYW5zZm9ybWluZyBpdCBpbnRvIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlIHdpdGggdGhpc1xuICogICAgIHJhZGl1cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXM9bnVsbF0gSWYgc2V0LCBhcHBlbmQgdGhpc1xuICogICAgIHZhbHVlIHRvIHRoZSBDU1MgYHRyYW5zZm9ybWAgcHJvcGVydHkgdXNlZCB0byBwb3NpdGlvbiB0aGUgaG90c3BvdC4gVGhpc1xuICogICAgIG1heSBiZSB1c2VkIHRvIHJvdGF0ZSBhbiBlbWJlZGRlZCBob3RzcG90LlxuICovXG5mdW5jdGlvbiBIb3RzcG90KGRvbUVsZW1lbnQsIHBhcmVudERvbUVsZW1lbnQsIHZpZXcsIGNvb3Jkcywgb3B0cykge1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnBlcnNwZWN0aXZlID0gb3B0cy5wZXJzcGVjdGl2ZSB8fCB7fTtcbiAgb3B0cy5wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXMgPVxuICAgICAgb3B0cy5wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXMgIT0gbnVsbCA/IG9wdHMucGVyc3BlY3RpdmUuZXh0cmFUcmFuc2Zvcm1zIDogXCJcIjtcblxuICB0aGlzLl9kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudCA9IHBhcmVudERvbUVsZW1lbnQ7XG4gIHRoaXMuX3ZpZXcgPSB2aWV3O1xuICB0aGlzLl9jb29yZHMgPSB7fTtcbiAgdGhpcy5fcGVyc3BlY3RpdmUgPSB7fTtcblxuICB0aGlzLnNldFBvc2l0aW9uKGNvb3Jkcyk7XG5cbiAgLy8gQWRkIGhvdHNwb3QgaW50byB0aGUgRE9NLlxuICB0aGlzLl9wYXJlbnREb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2RvbUVsZW1lbnQpO1xuXG4gIHRoaXMuc2V0UGVyc3BlY3RpdmUob3B0cy5wZXJzcGVjdGl2ZSk7XG5cbiAgLy8gV2hldGhlciB0aGUgaG90c3BvdCBpcyB2aXNpYmxlLlxuICAvLyBUaGUgaG90c3BvdCBtYXkgc3RpbGwgYmUgaGlkZGVuIGlmIGl0J3MgaW5zaWRlIGEgaGlkZGVuIEhvdHNwb3RDb250YWluZXIuXG4gIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuXG4gIC8vIFRoZSBjdXJyZW50IGNhbGN1bGF0ZWQgc2NyZWVuIHBvc2l0aW9uLlxuICB0aGlzLl9wb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xufVxuXG5ldmVudEVtaXR0ZXIoSG90c3BvdCk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICogQ2xpZW50cyBzaG91bGQgY2FsbCB7QGxpbmsgSG90c3BvdENvbnRhaW5lciNkZXN0cm95SG90c3BvdH0gaW5zdGVhZC5cbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wYXJlbnREb21FbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX2RvbUVsZW1lbnQpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuSG90c3BvdC5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZG9tRWxlbWVudDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jb29yZHM7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGNvb3Jkc1xuICovXG5Ib3RzcG90LnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKGNvb3Jkcykge1xuICBmb3IgKHZhciBrZXkgaW4gY29vcmRzKSB7XG4gICAgdGhpcy5fY29vcmRzW2tleV0gPSBjb29yZHNba2V5XTtcbiAgfVxuICB0aGlzLl91cGRhdGUoKTtcbiAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGVtaXQgYSBob3RzcG90c0NoYW5nZSBldmVudCBvbiB0aGUgcGFyZW50XG4gIC8vIEhvdHNwb3RDb250YWluZXIuIFdoYXQncyB0aGUgYmVzdCB3YXkgdG8gZG8gc28/XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGVyc3BlY3RpdmU7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKi9cbkhvdHNwb3QucHJvdG90eXBlLnNldFBlcnNwZWN0aXZlID0gZnVuY3Rpb24ocGVyc3BlY3RpdmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHBlcnNwZWN0aXZlKSB7XG4gICAgdGhpcy5fcGVyc3BlY3RpdmVba2V5XSA9IHBlcnNwZWN0aXZlW2tleV07XG4gIH1cbiAgdGhpcy5fdXBkYXRlKCk7XG59O1xuXG5cbi8qKlxuICogU2hvdyB0aGUgaG90c3BvdFxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fdmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogSGlkZSB0aGUgaG90c3BvdFxuICovXG5Ib3RzcG90LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl92aXNpYmxlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG59O1xuXG5cbkhvdHNwb3QucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVsZW1lbnQgPSB0aGlzLl9kb21FbGVtZW50O1xuXG4gIHZhciBwYXJhbXMgPSB0aGlzLl9jb29yZHM7XG4gIHZhciBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuICB2YXIgeCwgeTtcblxuICB2YXIgaXNWaXNpYmxlID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICB2YXIgdmlldyA9IHRoaXMuX3ZpZXc7XG5cbiAgICBpZiAodGhpcy5fcGVyc3BlY3RpdmUucmFkaXVzKSB7XG4gICAgICAvLyBIb3RzcG90cyB0aGF0IGFyZSBlbWJlZGRlZCBpbiB0aGUgcGFub3JhbWEgbWF5IGJlIHZpc2libGUgZXZlbiB3aGVuXG4gICAgICAvLyBwb3NpdGlvbmVkIGJlaGluZCB0aGUgY2FtZXJhLlxuICAgICAgaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3NldEVtYmVkZGVkUG9zaXRpb24odmlldywgcGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVndWxhciBob3RzcG90cyBhcmUgb25seSB2aXNpYmxlIHdoZW4gcG9zaXRpb25lZCBpbiBmcm9udCBvZiB0aGVcbiAgICAgIC8vIGNhbWVyYS4gTm90ZSB0aGF0IHRoZXkgbWF5IGJlIHBhcnRpYWxseSB2aXNpYmxlIHdoZW4gcG9zaXRpb25lZCBvdXRzaWRlXG4gICAgICAvLyB0aGUgdmlld3BvcnQuXG4gICAgICB2aWV3LmNvb3JkaW5hdGVzVG9TY3JlZW4ocGFyYW1zLCBwb3NpdGlvbik7XG4gICAgICB4ID0gcG9zaXRpb24ueDtcbiAgICAgIHkgPSBwb3NpdGlvbi55O1xuXG4gICAgICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICBpc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbih4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTaG93IGlmIHZpc2libGUsIGhpZGUgaWYgbm90LlxuICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgfVxuICBlbHNlIHtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICB9XG5cbn07XG5cblxuSG90c3BvdC5wcm90b3R5cGUuX3NldEVtYmVkZGVkUG9zaXRpb24gPSBmdW5jdGlvbih2aWV3LCBwYXJhbXMpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHZpZXcuY29vcmRpbmF0ZXNUb1BlcnNwZWN0aXZlVHJhbnNmb3JtKFxuICAgICAgcGFyYW1zLCB0aGlzLl9wZXJzcGVjdGl2ZS5yYWRpdXMsIHRoaXMuX3BlcnNwZWN0aXZlLmV4dHJhVHJhbnNmb3Jtcyk7XG4gIHNldFRyYW5zZm9ybSh0aGlzLl9kb21FbGVtZW50LCB0cmFuc2Zvcm0pO1xufTtcblxuXG5Ib3RzcG90LnByb3RvdHlwZS5fc2V0UG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHBvc2l0aW9uQWJzb2x1dGVseSh0aGlzLl9kb21FbGVtZW50LCB4LCB5LCB0aGlzLl9wZXJzcGVjdGl2ZS5leHRyYVRyYW5zZm9ybXMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEhvdHNwb3Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBIb3RzcG90ID0gcmVxdWlyZSgnLi9Ib3RzcG90Jyk7XG52YXIgY2FsY1JlY3QgPSByZXF1aXJlKCcuL3V0aWwvY2FsY1JlY3QnKTtcbnZhciBwb3NpdGlvbkFic29sdXRlbHkgPSByZXF1aXJlKCcuL3V0aWwvcG9zaXRpb25BYnNvbHV0ZWx5Jyk7XG52YXIgc2V0QWJzb2x1dGUgPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0QWJzb2x1dGU7XG52YXIgc2V0T3ZlcmZsb3dIaWRkZW4gPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0T3ZlcmZsb3dIaWRkZW47XG52YXIgc2V0T3ZlcmZsb3dWaXNpYmxlID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldE92ZXJmbG93VmlzaWJsZTtcbnZhciBzZXROdWxsU2l6ZSA9IHJlcXVpcmUoJy4vdXRpbC9kb20nKS5zZXROdWxsU2l6ZTtcbnZhciBzZXRQaXhlbFNpemUgPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0UGl4ZWxTaXplO1xudmFyIHNldFBvaW50ZXJFdmVudHMgPSByZXF1aXJlKCcuL3V0aWwvZG9tJykuc2V0V2l0aFZlbmRvclByZWZpeCgncG9pbnRlci1ldmVudHMnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgaG90c3BvdCBoYXMgYmVlbiBjcmVhdGVkIG9yIGRlc3Ryb3llZCBvbiB0aGUgY29udGFpbmVyLlxuICogQGV2ZW50IEhvdHNwb3RDb250YWluZXIjaG90c3BvdHNDaGFuZ2VcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBIb3RzcG90Q29udGFpbmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ3JlYXRlcyBhIERPTSBlbGVtZW50IHRvIGhvbGQge0BsaW5rIEhvdHNwb3QgaG90c3BvdHN9IGFuZCB1cGRhdGVzIHRoZWlyXG4gKiBwb3NpdGlvbiB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudERvbUVsZW1lbnQgVGhlIERPTSBlbGVtZW50IGluc2lkZSB3aGljaCB0aGUgY29udGFpbmVyXG4gKiAgICAgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUgdW5kZXJseWluZyBzdGFnZS5cbiAqIEBwYXJhbSB7Vmlld30gdmlldyBUaGUgdmlldyBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIGhvdHNwb3RzIGFyZSBwb3NpdGlvbmVkLlxuICogQHBhcmFtIHtSZW5kZXJMb29wfSByZW5kZXJMb29wIFRoZSByZW5kZXIgbG9vcCBpbmRpY2F0aW5nIHdoZW4gdGhlIGhvdHNwb3RzXG4gKiAgICAgbXVzdCBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge1JlY3RTcGVjfSBvcHRzLnJlY3QgUmVjdGFuZ3VsYXIgcmVnaW9uIGNvdmVyZWQgYnkgdGhlIGNvbnRhaW5lci4gU2VlXG4gKiAgICB7QGxpbmsgRWZmZWN0cyNyZWN0fS5cbiAqL1xuZnVuY3Rpb24gSG90c3BvdENvbnRhaW5lcihwYXJlbnREb21FbGVtZW50LCBzdGFnZSwgdmlldywgcmVuZGVyTG9vcCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB0aGlzLl9wYXJlbnREb21FbGVtZW50ID0gcGFyZW50RG9tRWxlbWVudDtcbiAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcbiAgdGhpcy5fdmlldyA9IHZpZXc7XG4gIHRoaXMuX3JlbmRlckxvb3AgPSByZW5kZXJMb29wO1xuXG4gIC8vIEhvdHNwb3QgbGlzdC5cbiAgdGhpcy5faG90c3BvdHMgPSBbXTtcblxuICAvLyBXaGV0aGVyIHRoZSBob3RzcG90IGNvbnRhaW5lciBzaG91bGQgYmUgdmlzaWJsZS5cbiAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG5cbiAgLy8gVGhlIGN1cnJlbnQgcmVjdC5cbiAgdGhpcy5fcmVjdCA9IG9wdHMucmVjdDtcblxuICAvLyBXaGV0aGVyIHRoZSB2aXNpYmlsaXR5IG9yIHRoZSByZWN0IGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBET00gdXBkYXRlLlxuICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IHRydWU7XG5cbiAgLy8gVGhlIGxhc3Qgc2VlbiBzdGFnZSBkaW1lbnNpb25zLlxuICB0aGlzLl9zdGFnZVdpZHRoID0gbnVsbDtcbiAgdGhpcy5fc3RhZ2VIZWlnaHQgPSBudWxsO1xuXG4gIC8vIFRlbXBvcmFyeSB2YXJpYWJsZSB0byBob2xkIHRoZSBjYWxjdWxhdGVkIHBvc2l0aW9uIGFuZCBzaXplLlxuICB0aGlzLl90bXBSZWN0ID0ge307XG5cbiAgLy8gV3JhcHBlciBlbGVtZW50LiBXaGVuIHRoZSByZWN0IGVmZmVjdCBpcyBzZXQsIHRoZSB3cmFwcGVyIHdpbGwgaGF2ZSBub256ZXJvXG4gIC8vIGRpbWVuc2lvbnMgYW5kIGBwb2ludGVyLWV2ZW50czogbm9uZWAgc28gdGhhdCBob3RzcG90cyBvdXRzaWRlIHRoZSByZWN0IGFyZVxuICAvLyBoaWRkZW4sIGJ1dCBubyBtb3VzZSBldmVudHMgYXJlIGhpamFja2VkLlxuICB0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzZXRBYnNvbHV0ZSh0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlcik7XG4gIHNldFBvaW50ZXJFdmVudHModGhpcy5faG90c3BvdENvbnRhaW5lcldyYXBwZXIsICdub25lJyk7XG4gIHRoaXMuX3BhcmVudERvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5faG90c3BvdENvbnRhaW5lcldyYXBwZXIpO1xuXG4gIC8vIEhvdHNwb3QgY29udGFpbmVyIGVsZW1lbnQuIEl0IGhhcyB6ZXJvIGRpbWVuc2lvbnMgYW5kIGBwb2ludGVyLWV2ZW50czogYWxsYFxuICAvLyB0byBvdmVycmlkZSB0aGUgYHBvaW50ZXItZXZlbnRzOiBub25lYCBvbiB0aGUgd3JhcHBlciBhbmQgYWxsb3cgaG90c3BvdHMgdG9cbiAgLy8gYmUgaW50ZXJhY3RlZCB3aXRoLlxuICB0aGlzLl9ob3RzcG90Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNldEFic29sdXRlKHRoaXMuX2hvdHNwb3RDb250YWluZXIpO1xuICBzZXRQb2ludGVyRXZlbnRzKHRoaXMuX2hvdHNwb3RDb250YWluZXIsICdhbGwnKTtcbiAgdGhpcy5faG90c3BvdENvbnRhaW5lcldyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5faG90c3BvdENvbnRhaW5lcik7XG5cbiAgLy8gVXBkYXRlIHdoZW4gdGhlIGhvdHNwb3RzIGNoYW5nZSBvciBzY2VuZSBpcyByZS1yZW5kZXJlZC5cbiAgdGhpcy5fdXBkYXRlSGFuZGxlciA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICB0aGlzLl9yZW5kZXJMb29wLmFkZEV2ZW50TGlzdGVuZXIoJ2FmdGVyUmVuZGVyJywgdGhpcy5fdXBkYXRlSGFuZGxlcik7XG59XG5cbmV2ZW50RW1pdHRlcihIb3RzcG90Q29udGFpbmVyKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMuX2hvdHNwb3RzLmxlbmd0aCkge1xuICAgIHRoaXMuZGVzdHJveUhvdHNwb3QodGhpcy5faG90c3BvdHNbMF0pO1xuICB9XG5cbiAgdGhpcy5fcGFyZW50RG9tRWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlcik7XG5cbiAgdGhpcy5fcmVuZGVyTG9vcC5yZW1vdmVFdmVudExpc3RlbmVyKCdhZnRlclJlbmRlcicsIHRoaXMuX3VwZGF0ZUhhbmRsZXIpO1xuXG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5kb21FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9ob3RzcG90Q29udGFpbmVyO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7UmVjdH0gcmVjdFxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5zZXRSZWN0ID0gZnVuY3Rpb24ocmVjdCkge1xuICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgdGhpcy5fdmlzaWJpbGl0eU9yUmVjdENoYW5nZWQgPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge1JlY3R9XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JlY3Q7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBob3RzcG90IGluIHRoaXMgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tRWxlbWVudCBET00gZWxlbWVudCB0byB1c2UgZm9yIHRoZSBob3RzcG90XG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIFRoZSBob3RzcG90IGNvb3JkaW5hdGVzLlxuICogICAgIFVzZSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3Q29vcmRzfWAgZm9yIGEge0BsaW5rIFJlY3RpbGluZWFyVmlld30gb3JcbiAqICAgICB7QGxpbmsgRmxhdFZpZXdDb29yZHN9IGZvciBhIHtAbGluayBGbGF0Vmlld30uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgYG9wdHNgIGFyZ3VtZW50IHRvXG4gKiAgICAgdGhlIHtAbGluayBIb3RzcG90fSBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm4ge0hvdHNwb3R9XG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmNyZWF0ZUhvdHNwb3QgPSBmdW5jdGlvbihkb21FbGVtZW50LCBjb29yZHMsIG9wdHMpIHtcbiAgY29vcmRzID0gY29vcmRzIHx8IHt9O1xuXG4gIHZhciBob3RzcG90ID0gbmV3IEhvdHNwb3QoXG4gICAgICBkb21FbGVtZW50LCB0aGlzLl9ob3RzcG90Q29udGFpbmVyLCB0aGlzLl92aWV3LCBjb29yZHMsIG9wdHMpO1xuICB0aGlzLl9ob3RzcG90cy5wdXNoKGhvdHNwb3QpO1xuICBob3RzcG90Ll91cGRhdGUoKTtcblxuICB0aGlzLmVtaXQoJ2hvdHNwb3RzQ2hhbmdlJyk7XG5cbiAgcmV0dXJuIGhvdHNwb3Q7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtIb3RzcG90fSBob3RzcG90XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Ib3RzcG90Q29udGFpbmVyLnByb3RvdHlwZS5oYXNIb3RzcG90ID0gZnVuY3Rpb24oaG90c3BvdCkge1xuICByZXR1cm4gdGhpcy5faG90c3BvdHMuaW5kZXhPZihob3RzcG90KSA+PSAwO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0hvdHNwb3RbXX1cbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUubGlzdEhvdHNwb3RzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXS5jb25jYXQodGhpcy5faG90c3BvdHMpO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYSBob3RzcG90IGZyb20gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0ge0hvdHNwb3R9IGhvdHNwb3RcbiAqL1xuSG90c3BvdENvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveUhvdHNwb3QgPSBmdW5jdGlvbihob3RzcG90KSB7XG4gIHZhciBpID0gdGhpcy5faG90c3BvdHMuaW5kZXhPZihob3RzcG90KTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGhvdHNwb3QnKTtcbiAgfVxuICB0aGlzLl9ob3RzcG90cy5zcGxpY2UoaSwgMSk7XG5cbiAgaG90c3BvdC5kZXN0cm95KCk7XG4gIHRoaXMuZW1pdCgnaG90c3BvdHNDaGFuZ2UnKTtcbn07XG5cblxuLyoqXG4gKiBIaWRlIHRoZSBjb250YWluZXIncyBET00gZWxlbWVudCwgY2F1c2luZyBldmVyeSBjb250YWluZWQge0BsaW5rIEhvdHNwb3R9IHRvXG4gKiBiZSBoaWRkZW4uXG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fdmlzaWJpbGl0eU9yUmVjdENoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU2hvdyB0aGUgY29udGFpbmVyJ3MgRE9NIGVsZW1lbnQsIGNhdXNpbmcgZXZlcnkgY29udGFpbmVkIHtAbGluayBIb3RzcG90fSB0b1xuICogYmUgc2hvd24uXG4gKi9cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl92aXNpYmxlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5fdmlzaWJpbGl0eU9yUmVjdENoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG59O1xuXG5cbkhvdHNwb3RDb250YWluZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdyYXBwZXIgPSB0aGlzLl9ob3RzcG90Q29udGFpbmVyV3JhcHBlcjtcbiAgdmFyIHdpZHRoID0gdGhpcy5fc3RhZ2Uud2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHRoaXMuX3N0YWdlLmhlaWdodCgpO1xuICB2YXIgdG1wUmVjdCA9IHRoaXMuX3RtcFJlY3Q7XG5cbiAgLy8gQXZvaWQgdXBkYXRpbmcgdGhlIHdyYXBwZXIgRE9NIHVubGVzcyBuZWNlc3NhcnkuXG4gIGlmICh0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCB8fFxuICAgICAgKHRoaXMuX3JlY3QgJiYgKHdpZHRoICE9PSB0aGlzLl9zdGFnZVdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5fc3RhZ2VIZWlnaHQpKSkge1xuICAgIHZhciB2aXNpYmxlID0gdGhpcy5fdmlzaWJsZTtcbiAgICB3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJztcblxuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICBpZiAodGhpcy5fcmVjdCkge1xuICAgICAgICBjYWxjUmVjdCh3aWR0aCwgaGVpZ2h0LCB0aGlzLl9yZWN0LCB0bXBSZWN0KTtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZWx5KHdyYXBwZXIsIHdpZHRoICogdG1wUmVjdC54LCBoZWlnaHQgKiB0bXBSZWN0LnkpO1xuICAgICAgICBzZXRQaXhlbFNpemUod3JhcHBlciwgd2lkdGggKiB0bXBSZWN0LndpZHRoLCBoZWlnaHQgKiB0bXBSZWN0LmhlaWdodCk7XG4gICAgICAgIHNldE92ZXJmbG93SGlkZGVuKHdyYXBwZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZWx5KHdyYXBwZXIsIDAsIDApO1xuICAgICAgICBzZXROdWxsU2l6ZSh3cmFwcGVyKTtcbiAgICAgICAgc2V0T3ZlcmZsb3dWaXNpYmxlKHdyYXBwZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YWdlV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9zdGFnZUhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl92aXNpYmlsaXR5T3JSZWN0Q2hhbmdlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVXBkYXRlIGhvdHNwb3RzIHVuY29uZGl0aW9uYWxseSwgYXMgdGhlIHZpZXcgcGFyYW1ldGVycyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvdHNwb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5faG90c3BvdHNbaV0uX3VwZGF0ZSgpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSG90c3BvdENvbnRhaW5lcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi91dGlsL2V4dGVuZCcpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgdGhlIGxheWVyIGhhcyBiZWVuIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhYmxlIFdoZXRoZXIgYWxsIHRpbGVzIHdlcmUgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHdpdGhvdXRcbiAqICAgICBtaXNzaW5nIHRleHR1cmVzIG9yIHJlc29ydGluZyB0byBmYWxsYmFja3MuXG4gKiBAZXZlbnQgTGF5ZXIjcmVuZGVyQ29tcGxldGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBMYXllclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgTGF5ZXIgaXMgYSBjb21iaW5hdGlvbiBvZiB7QGxpbmsgU291cmNlfSwge0BsaW5rIEdlb21ldHJ5fSwge0BsaW5rIFZpZXd9XG4gKiBhbmQge0BsaW5rIFRleHR1cmVTdG9yZX0gdGhhdCBtYXkgYmUgYWRkZWQgaW50byBhIHtAbGluayBTdGFnZX0gYW5kIHJlbmRlcmVkXG4gKiB3aXRoIHtAbGluayBFZmZlY3RzfS5cbiAqXG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeVxuICogQHBhcmFtIHtzdHJpbmd9IGRlcHRobWFwXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXdcbiAqIEBwYXJhbSB7VGV4dHVyZVN0b3JlfSB0ZXh0dXJlU3RvcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge0VmZmVjdHN9IG9wdHMuZWZmZWN0c1xuKi9cbmZ1bmN0aW9uIExheWVyKHNvdXJjZSwgZ2VvbWV0cnksIGRlcHRobWFwLCB2aWV3LCB0ZXh0dXJlU3RvcmUsIGRlcHRobWFwU3RvcmUsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgdGhpcy5fZGVwdGhtYXAgPSBkZXB0aG1hcDtcbiAgdGhpcy5fdmlldyA9IHZpZXc7XG4gIHRoaXMuX3RleHR1cmVTdG9yZSA9IHRleHR1cmVTdG9yZTtcbiAgdGhpcy5fZGVwdGhtYXBTdG9yZSA9IGRlcHRobWFwU3RvcmU7XG5cbiAgdGhpcy5fZWZmZWN0cyA9IG9wdHMuZWZmZWN0cyB8fCB7fTtcblxuICB0aGlzLl9maXhlZExldmVsSW5kZXggPSBudWxsO1xuXG4gIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgndmlld0NoYW5nZScsIHNlbGYudmlldygpKTtcbiAgfTtcblxuICB0aGlzLl92aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcblxuICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgndGV4dHVyZVN0b3JlQ2hhbmdlJywgc2VsZi50ZXh0dXJlU3RvcmUoKSk7XG4gIH07XG5cbiAgdGhpcy5fdGV4dHVyZVN0b3JlLmFkZEV2ZW50TGlzdGVuZXIoJ3RleHR1cmVMb2FkJyxcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmVDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdGV4dHVyZVN0b3JlLmFkZEV2ZW50TGlzdGVuZXIoJ3RleHR1cmVFcnJvcicsXG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlcik7XG4gIHRoaXMuX3RleHR1cmVTdG9yZS5hZGRFdmVudExpc3RlbmVyKCd0ZXh0dXJlSW52YWxpZCcsXG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlcik7XG59XG5cbmV2ZW50RW1pdHRlcihMYXllcik7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5MYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlcik7XG4gIHRoaXMuX3RleHR1cmVTdG9yZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXh0dXJlTG9hZCcsXG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlQ2hhbmdlSGFuZGxlcik7XG4gIHRoaXMuX3RleHR1cmVTdG9yZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXh0dXJlRXJyb3InLFxuICAgIHRoaXMuX3RleHR1cmVTdG9yZUNoYW5nZUhhbmRsZXIpO1xuICB0aGlzLl90ZXh0dXJlU3RvcmUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZUludmFsaWQnLFxuICAgIHRoaXMuX3RleHR1cmVTdG9yZUNoYW5nZUhhbmRsZXIpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgU291cmNlIHNvdXJjZX0uXG4gKiBAcmV0dXJuIHtTb3VyY2V9XG4gKi9cbkxheWVyLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9zb3VyY2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgZGVwdGhtYXAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5MYXllci5wcm90b3R5cGUuZGVwdGhtYXAgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9kZXB0aG1hcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBHZW9tZXRyeSBnZW9tZXRyeX0uXG4gKiBAcmV0dXJuIHtHZW9tZXRyeX1cbiAqL1xuTGF5ZXIucHJvdG90eXBlLmdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgVmlldyB2aWV3fS5cbiAqIEByZXR1cm4ge1ZpZXd9XG4gKi9cbkxheWVyLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdmlldztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBUZXh0dXJlU3RvcmUgdGV4dHVyZSBzdG9yZX0uXG4gKiBAcmV0dXJuIHtUZXh0dXJlU3RvcmV9XG4gKi9cbkxheWVyLnByb3RvdHlwZS50ZXh0dXJlU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl90ZXh0dXJlU3RvcmU7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgRGVwdGhtYXBTdG9yZSBkYXRlIHN0b3JlfS5cbiAqIEByZXR1cm4ge0RlcHRobWFwU3RvcmV9XG4gKi9cbkxheWVyLnByb3RvdHlwZS5kZXB0aG1hcFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZGVwdGhtYXBTdG9yZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgc2V0IHtAbGluayBFZmZlY3RzIGVmZmVjdHN9LlxuICogQHJldHVybiB7RWZmZWN0c31cbiAqL1xuTGF5ZXIucHJvdG90eXBlLmVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9lZmZlY3RzO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIHtAbGluayBFZmZlY3RzIGVmZmVjdHN9LlxuICogQHBhcmFtIHtFZmZlY3RzfSBlZmZlY3RzXG4gKi9cbkxheWVyLnByb3RvdHlwZS5zZXRFZmZlY3RzID0gZnVuY3Rpb24gKGVmZmVjdHMpIHtcbiAgdGhpcy5fZWZmZWN0cyA9IGVmZmVjdHM7XG4gIHRoaXMuZW1pdCgnZWZmZWN0c0NoYW5nZScsIHRoaXMuX2VmZmVjdHMpO1xufTtcblxuXG4vKipcbiAqIE1lcmdlcyBlZmZlY3RzIGludG8gdGhlIGN1cnJlbnRseSBzZXQgb25lcy4gVGhlIG1lcmdlIGlzIG5vbi1yZWN1cnNpdmU7IGZvclxuICogaW5zdGFuY2UsIGlmIGN1cnJlbnQgZWZmZWN0cyBhcmUgYHsgcmVjdDogeyByZWxhdGl2ZVdpZHRoOiAwLjUgfSB9YCxcbiAqIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBgeyByZWN0OiB7IHJlbGF0aXZlWDogMC41IH19YCB3aWxsIHJlc2V0XG4gKiBgcmVjdC5yZWxhdGl2ZVdpZHRoYC5cbiAqXG4gKiBAcGFyYW0ge0VmZmVjdHN9IGVmZmVjdHNcbiAqL1xuTGF5ZXIucHJvdG90eXBlLm1lcmdlRWZmZWN0cyA9IGZ1bmN0aW9uIChlZmZlY3RzKSB7XG4gIGV4dGVuZCh0aGlzLl9lZmZlY3RzLCBlZmZlY3RzKTtcbiAgdGhpcy5lbWl0KCdlZmZlY3RzQ2hhbmdlJywgdGhpcy5fZWZmZWN0cyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZml4ZWQgbGV2ZWwgaW5kZXguXG4gKiBAcmV0dXJuIHsobnVtYmVyfG51bGwpfVxuICovXG5MYXllci5wcm90b3R5cGUuZml4ZWRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ZpeGVkTGV2ZWxJbmRleDtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBmaXhlZCBsZXZlbCBpbmRleC4gV2hlbiBzZXQsIHRoZSBjb3JyZXNwb25kaW5nIGxldmVsIHdpbGwgYmVcbiAqIHVzZWQgcmVnYXJkbGVzcyBvZiB0aGUgdmlldyBwYXJhbWV0ZXJzLiBVbnNldCB3aXRoIGEgbnVsbCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0geyhudW1iZXJ8bnVsbCl9IGxldmVsSW5kZXhcbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGxldmVsIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAqL1xuTGF5ZXIucHJvdG90eXBlLnNldEZpeGVkTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWxJbmRleCkge1xuICBpZiAobGV2ZWxJbmRleCAhPT0gdGhpcy5fZml4ZWRMZXZlbEluZGV4KSB7XG4gICAgaWYgKGxldmVsSW5kZXggIT0gbnVsbCAmJiAobGV2ZWxJbmRleCA+PSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3QubGVuZ3RoIHx8XG4gICAgICBsZXZlbEluZGV4IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxldmVsIGluZGV4IG91dCBvZiByYW5nZTogXCIgKyBsZXZlbEluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5fZml4ZWRMZXZlbEluZGV4ID0gbGV2ZWxJbmRleDtcbiAgICB0aGlzLmVtaXQoJ2ZpeGVkTGV2ZWxDaGFuZ2UnLCB0aGlzLl9maXhlZExldmVsSW5kZXgpO1xuICB9XG59O1xuXG5cbkxheWVyLnByb3RvdHlwZS5fc2VsZWN0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZXZlbDtcbiAgaWYgKHRoaXMuX2ZpeGVkTGV2ZWxJbmRleCAhPSBudWxsKSB7XG4gICAgbGV2ZWwgPSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3RbdGhpcy5fZml4ZWRMZXZlbEluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICBsZXZlbCA9IHRoaXMuX3ZpZXcuc2VsZWN0TGV2ZWwodGhpcy5fZ2VvbWV0cnkuc2VsZWN0YWJsZUxldmVsTGlzdCk7XG4gIH1cbiAgcmV0dXJuIGxldmVsO1xufTtcblxuXG5MYXllci5wcm90b3R5cGUudmlzaWJsZVRpbGVzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9zZWxlY3RMZXZlbCgpO1xuICByZXR1cm4gdGhpcy5fZ2VvbWV0cnkudmlzaWJsZVRpbGVzKHRoaXMuX3ZpZXcsIGxldmVsLCByZXN1bHQpO1xufTtcblxuXG4vKipcbiAqIFBpbiBhIHdob2xlIGxldmVsIGludG8gdGhlIHRleHR1cmUgc3RvcmUuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxJbmRleFxuICovXG5MYXllci5wcm90b3R5cGUucGluTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWxJbmRleCkge1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9nZW9tZXRyeS5sZXZlbExpc3RbbGV2ZWxJbmRleF07XG4gIHZhciB0aWxlcyA9IHRoaXMuX2dlb21ldHJ5LmxldmVsVGlsZXMobGV2ZWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fdGV4dHVyZVN0b3JlLnBpbih0aWxlc1tpXSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBVbnBpbiBhIHdob2xlIGxldmVsIGZyb20gdGhlIHRleHR1cmUgc3RvcmUuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWxJbmRleFxuICovXG5MYXllci5wcm90b3R5cGUudW5waW5MZXZlbCA9IGZ1bmN0aW9uIChsZXZlbEluZGV4KSB7XG4gIHZhciBsZXZlbCA9IHRoaXMuX2dlb21ldHJ5LmxldmVsTGlzdFtsZXZlbEluZGV4XTtcbiAgdmFyIHRpbGVzID0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxUaWxlcyhsZXZlbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl90ZXh0dXJlU3RvcmUudW5waW4odGlsZXNbaV0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGluIHRoZSBmaXJzdCBsZXZlbC4gRXF1aXZhbGVudCB0byBgcGluTGV2ZWwoMClgLlxuICovXG5MYXllci5wcm90b3R5cGUucGluRmlyc3RMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGluTGV2ZWwoMCk7XG59O1xuXG5cbi8qKlxuICogVW5waW4gdGhlIGZpcnN0IGxldmVsLiBFcXVpdmFsZW50IHRvIGB1bnBpbkxldmVsKDApYC5cbiAqL1xuTGF5ZXIucHJvdG90eXBlLnVucGluRmlyc3RMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudW5waW5MZXZlbCgwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMYXllcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlsL2luaGVyaXRzJyk7XG5cbi8qKlxuICogQGNsYXNzIE5ldHdvcmtFcnJvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGNsYXNzZGVzY1xuICpcbiAqIFNpZ25hbHMgYW4gZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGlsZSBmZXRjaGluZyBhIFVSTC4gVGhpcyBpcyB1c2VkIGJ5XG4gKiB7QGxpbmsgTG9hZGVyIGxvYWRlcnN9IHRvIGRpc3Rpbmd1aXNoIG5ldHdvcmsgZmFpbHVyZXMgZnJvbSBvdGhlciBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIE5ldHdvcmtFcnJvcihtZXNzYWdlKSB7XG4gIC8vIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4MjEwNy93aGF0cy1hLWdvb2Qtd2F5LXRvLWV4dGVuZC1lcnJvci1pbi1qYXZhc2NyaXB0XG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbmluaGVyaXRzKE5ldHdvcmtFcnJvciwgRXJyb3IpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtFcnJvcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBTaWduYWxzIHRoYXQge0BsaW5rIFN0YWdlI3JlbmRlcn0gaXMgYWJvdXQgdG8gYmUgY2FsbGVkLlxuICogQGV2ZW50IFJlbmRlckxvb3AjYmVmb3JlUmVuZGVyXG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQge0BsaW5rIFN0YWdlI3JlbmRlcn0gaGFzIGp1c3QgYmVlbiBjYWxsZWQuXG4gKiBAZXZlbnQgUmVuZGVyTG9vcCNhZnRlclJlbmRlclxuICovXG5cbi8qKlxuICogQGNsYXNzIFJlbmRlckxvb3BcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFJlbmRlckxvb3Agd3JhcHMgYSB7QGxpbmsgU3RhZ2V9IGFuZCBjYWxscyB7QGxpbmsgU3RhZ2UjcmVuZGVyfSBvbiB0aGUgbmV4dFxuICogZnJhbWUgd2hlbmV2ZXIgaXQgZmlyZXMge0BsaW5rIFN0YWdlI3JlbmRlckludmFsaWR9LiBJdCBtYXkgYmUgc3RhcnRlZCBhbmRcbiAqIHN0b3BwZWQsIGFuZCBpcyBpbml0aWFsbHkgaW4gdGhlIHN0b3BwZWQgc3RhdGUsIGluIHdoaWNoIG5vIGNhbGwgdG9cbiAqIHtAbGluayBTdGFnZSNyZW5kZXJ9IG9jY3Vycy5cbiAqXG4gKiBAbGlzdGVucyBTdGFnZSNyZW5kZXJJbnZhbGlkXG4gKlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2VcbiAqL1xuZnVuY3Rpb24gUmVuZGVyTG9vcChzdGFnZSkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBUaGUgc3RhZ2Ugd3JhcHBlZCBieSB0aGUgbG9vcC5cbiAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcblxuICAvLyBXaGV0aGVyIHRoZSBsb29wIGlzIHJ1bm5pbmcuXG4gIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblxuICAvLyBXaGV0aGVyIHRoZSBsb29wIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuXG4gIHRoaXMuX3JlbmRlcmluZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBjdXJyZW50IHJlcXVlc3RBbmltYXRpb25GcmFtZSBoYW5kbGUuXG4gIHRoaXMuX3JlcXVlc3RIYW5kbGUgPSBudWxsO1xuXG4gIC8vIFRoZSBjYWxsYmFjayBwYXNzZWQgaW50byByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gIHRoaXMuX2JvdW5kTG9vcCA9IHRoaXMuX2xvb3AuYmluZCh0aGlzKTtcblxuICAvLyBIYW5kbGVyIGZvciByZW5kZXJJbnZhbGlkIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBzdGFnZS5cbiAgdGhpcy5fcmVuZGVySW52YWxpZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSByZW5kZXJpbmcsIHRoZXJlJ3Mgbm8gbmVlZCB0byBzY2hlZHVsZSBhIG5ldyByZW5kZXJcbiAgICAvLyBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICBpZiAoIXNlbGYuX3JlbmRlcmluZykge1xuICAgICAgc2VsZi5yZW5kZXJPbk5leHRGcmFtZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIYW5kbGUgcmVuZGVySW52YWxpZCBldmVudHMgZW1pdHRlZCBieSB0aGUgc3RhZ2UuXG4gIHRoaXMuX3N0YWdlLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbmRlckludmFsaWQnLCB0aGlzLl9yZW5kZXJJbnZhbGlkSGFuZGxlcik7XG5cbn1cblxuZXZlbnRFbWl0dGVyKFJlbmRlckxvb3ApO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuUmVuZGVyTG9vcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0b3AoKTtcbiAgdGhpcy5fc3RhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVuZGVySW52YWxpZCcsIHRoaXMuX3JlbmRlckludmFsaWRIYW5kbGVyKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgc3RhZ2UuXG4gKiBAcmV0dXJuIHtTdGFnZX1cbiAqL1xuUmVuZGVyTG9vcC5wcm90b3R5cGUuc3RhZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YWdlO1xufTtcblxuXG4vKipcbiAqIFN0YXJ0cyB0aGUgcmVuZGVyIGxvb3AuXG4gKi9cblJlbmRlckxvb3AucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICB0aGlzLnJlbmRlck9uTmV4dEZyYW1lKCk7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgdGhlIHJlbmRlciBsb29wLlxuICovXG5SZW5kZXJMb29wLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9yZXF1ZXN0SGFuZGxlKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RIYW5kbGUpO1xuICAgIHRoaXMuX3JlcXVlc3RIYW5kbGUgPSBudWxsO1xuICB9XG4gIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBGb3JjZXMgdGhlIHN0YWdlIHRvIHJlbmRlciBvbiB0aGUgbmV4dCBmcmFtZSwgZXZlbiBpZiBpdHMgY29udGVudHMgcmVtYWluXG4gKiB2YWxpZC4gRG9lcyBub3RoaW5nIGlmIHRoZSBsb29wIGlzIHN0b3BwZWQuXG4gKi9cblJlbmRlckxvb3AucHJvdG90eXBlLnJlbmRlck9uTmV4dEZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9ydW5uaW5nICYmICF0aGlzLl9yZXF1ZXN0SGFuZGxlKSB7XG4gICAgdGhpcy5fcmVxdWVzdEhhbmRsZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fYm91bmRMb29wKTtcbiAgfVxufTtcblxuXG5SZW5kZXJMb29wLnByb3RvdHlwZS5fbG9vcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlciBsb29wIHJ1bm5pbmcgd2hpbGUgaW4gc3RvcHBlZCBzdGF0ZScpO1xuICB9XG4gIHRoaXMuX3JlcXVlc3RIYW5kbGUgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2JlZm9yZVJlbmRlcicpO1xuICB0aGlzLl9yZW5kZXJpbmcgPSBmYWxzZTtcbiAgdGhpcy5fc3RhZ2UucmVuZGVyKCk7XG4gIHRoaXMuZW1pdCgnYWZ0ZXJSZW5kZXInKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJMb29wO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyk7XG52YXIgVGV4dHVyZVN0b3JlID0gcmVxdWlyZSgnLi9UZXh0dXJlU3RvcmUnKTtcbnZhciBEZXB0aG1hcFN0b3JlID0gcmVxdWlyZSgnLi9EZXB0aG1hcFN0b3JlJyk7XG52YXIgSG90c3BvdENvbnRhaW5lciA9IHJlcXVpcmUoJy4vSG90c3BvdENvbnRhaW5lcicpO1xudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIG5vdyA9IHJlcXVpcmUoJy4vdXRpbC9ub3cnKTtcbnZhciBub29wID0gcmVxdWlyZSgnLi91dGlsL25vb3AnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi91dGlsL3R5cGUnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vdXRpbC9kZWZhdWx0cycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgdGhlIHNjZW5lJ3MgdmlldyBoYXMgY2hhbmdlZC4gU2VlIHtAbGluayBWaWV3I2V2ZW50OmNoYW5nZX0uXG4gKiBAZXZlbnQgU2NlbmUjdmlld0NoYW5nZVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSBzY2VuZSdzIGxheWVycyBoYXZlIGNoYW5nZWQuXG4gKiBAZXZlbnQgU2NlbmUjbGF5ZXJDaGFuZ2VcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBTY2VuZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgU2NlbmUgaXMgYSBzdGFjayBvZiB7QGxpbmsgTGF5ZXIgbGF5ZXJzfSBzaGFyaW5nIHRoZSBzYW1lIHtAbGluayBWaWV3IHZpZXd9XG4gKiBhbmQge0BsaW5rIEhvdHNwb3RDb250YWluZXIgaG90c3BvdCBjb250YWluZXJ9LiBJdCBiZWxvbmdzIHRvIHRoZVxuICoge0BsaW5rIFZpZXdlciB2aWV3ZXJ9IGluc2lkZSB3aGljaCBpdCBpcyBkaXNwbGF5ZWQuXG4gKlxuICogQ2xpZW50cyBzaG91bGQgY2FsbCB7QGxpbmsgVmlld2VyI2NyZWF0ZVNjZW5lfSBpbnN0ZWFkIG9mIGludm9raW5nIHRoZVxuICogY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtWaWV3ZXJ9IHZpZXdlciBUaGUgdmlld2VyIHRoaXMgc2NlbmUgYmVsb25ncyB0by5cbiAqIEBwYXJhbSB7Vmlld30gdmlldyBUaGUgc2NlbmUncyB1bmRlcmx5aW5nIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIFNjZW5lKHZpZXdlciwgdmlldykge1xuICB0aGlzLl92aWV3ZXIgPSB2aWV3ZXI7XG4gIHRoaXMuX3ZpZXcgPSB2aWV3O1xuICB0aGlzLl9sYXllcnMgPSBbXTtcblxuICAvLyBIb3RzcG90IGNvbnRhaW5lci4gQXNzdW1lIGl0IG9jY3VwaWVzIGEgZnVsbCByZWN0LlxuICB0aGlzLl9ob3RzcG90Q29udGFpbmVyID0gbmV3IEhvdHNwb3RDb250YWluZXIoXG4gICAgdmlld2VyLl9jb250cm9sQ29udGFpbmVyLFxuICAgIHZpZXdlci5zdGFnZSgpLFxuICAgIHRoaXMuX3ZpZXcsXG4gICAgdmlld2VyLnJlbmRlckxvb3AoKSk7XG5cbiAgLy8gVGhlIGN1cnJlbnQgbW92ZW1lbnQuXG4gIHRoaXMuX21vdmVtZW50ID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRTdGFydFRpbWUgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudFN0ZXAgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudFBhcmFtcyA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50Q2FsbGJhY2sgPSBudWxsO1xuXG4gIC8vIEV2ZW50IGxpc3RlbmVyIGZvciB1cGRhdGluZyB0aGUgdmlldyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgbW92ZW1lbnQuXG4gIC8vIFRoZSBsaXN0ZW5lciBpcyBzZXQvdW5zZXQgb24gdGhlIHJlbmRlciBsb29wIHdoZW4gYSBtb3ZlbWVudCBzdGFydHMvc3RvcHMuXG4gIHRoaXMuX3VwZGF0ZU1vdmVtZW50SGFuZGxlciA9IHRoaXMuX3VwZGF0ZU1vdmVtZW50LmJpbmQodGhpcyk7XG5cbiAgLy8gU2hvdyBvciBoaWRlIGhvdHNwb3RzIHdoZW4gc2NlbmUgY2hhbmdlcy5cbiAgdGhpcy5fdXBkYXRlSG90c3BvdENvbnRhaW5lckhhbmRsZXIgPSB0aGlzLl91cGRhdGVIb3RzcG90Q29udGFpbmVyLmJpbmQodGhpcyk7XG4gIHRoaXMuX3ZpZXdlci5hZGRFdmVudExpc3RlbmVyKCdzY2VuZUNoYW5nZScsIHRoaXMuX3VwZGF0ZUhvdHNwb3RDb250YWluZXJIYW5kbGVyKTtcblxuICAvLyBFbWl0IGV2ZW50IHdoZW4gdmlldyBjaGFuZ2VzLlxuICB0aGlzLl92aWV3Q2hhbmdlSGFuZGxlciA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICd2aWV3Q2hhbmdlJyk7XG4gIHRoaXMuX3ZpZXcuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgaG90c3BvdCBjb250YWluZXIuXG4gIHRoaXMuX3VwZGF0ZUhvdHNwb3RDb250YWluZXIoKTtcbn1cblxuZXZlbnRFbWl0dGVyKFNjZW5lKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuIENsaWVudHMgc2hvdWxkIGNhbGwge0BsaW5rIFZpZXdlciNkZXN0cm95U2NlbmV9IGluc3RlYWQuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl92aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcbiAgdGhpcy5fdmlld2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NjZW5lQ2hhbmdlJywgdGhpcy5fdXBkYXRlSG90c3BvdENvbnRhaW5lckhhbmRsZXIpO1xuXG4gIGlmICh0aGlzLl9tb3ZlbWVudCkge1xuICAgIHRoaXMuc3RvcE1vdmVtZW50KCk7XG4gIH1cblxuICB0aGlzLl9ob3RzcG90Q29udGFpbmVyLmRlc3Ryb3koKTtcblxuICB0aGlzLmRlc3Ryb3lBbGxMYXllcnMoKTtcblxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB7QGxpbmsgSG90c3BvdENvbnRhaW5lciBob3RzcG90IGNvbnRhaW5lcn0gZm9yIHRoZSBzY2VuZS5cbiAqIEByZXR1cm4ge0xheWVyfVxuICovXG5TY2VuZS5wcm90b3R5cGUuaG90c3BvdENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hvdHNwb3RDb250YWluZXI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IG9mIHRoZSB7QGxpbmsgTGF5ZXIgbGF5ZXJzfSBiZWxvbmdpbmcgdG8gdGhlIHNjZW5lLCBvclxuICogbnVsbCBpZiB0aGUgc2NlbmUgaGFzIG5vIGxheWVycy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBTY2VuZSNsaXN0TGF5ZXJzWzBdYC4gSXQgbWF5IGJlIHJlbW92ZWQgaW4gdGhlXG4gKiBmdXR1cmUuXG4gKlxuICogQHJldHVybiB7TGF5ZXJ9XG4gKi9cblNjZW5lLnByb3RvdHlwZS5sYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbn07XG5cbi8qKlxuKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwge0BsaW5rIExheWVyIGxheWVyc30gYmVsb25naW5nIHRvIHRoZSBzY2VuZS4gVGhlXG4qIHJldHVybmVkIGxpc3QgaXMgaW4gZGlzcGxheSBvcmRlciwgYmFja2dyb3VuZCB0byBmb3JlZ3JvdW5kLlxuKiBAcmV0dXJuIHtMYXllcltdfVxuICovXG5TY2VuZS5wcm90b3R5cGUubGlzdExheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLl9sYXllcnMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjZW5lJ3MgdW5kZXJseWluZyB7QGxpbmsgVmlldyB2aWV3fS5cbiAqIEByZXR1cm4ge1ZpZXd9XG4gKi9cblNjZW5lLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdmlldztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB7QGxpbmsgVmlld2VyIHZpZXdlcn0gdGhlIHNjZW5lIGJlbG9uZ3MgdG8uXG4gKiBAcmV0dXJuIHtWaWV3ZXJ9XG4gKi9cblNjZW5lLnByb3RvdHlwZS52aWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl92aWV3ZXI7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBzY2VuZSBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblNjZW5lLnByb3RvdHlwZS52aXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdmlld2VyLnNjZW5lKCkgPT09IHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGFuZCBhZGRzIGl0IGludG8gdGhlIHNjZW5lIGluIHRoZVxuICogZm9yZWdyb3VuZCBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBMYXllciBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtTb3VyY2V9IG9wdHMuc291cmNlIFRoZSBsYXllcidzIHVuZGVybHlpbmcge0BsaW5rIFNvdXJjZX0uXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBvcHRzLmdlb21ldHJ5IFRoZSBsYXllcidzIHVuZGVybHlpbmcge0BsaW5rIEdlb21ldHJ5fS5cbiAqIEBwYXJhbSB7U291cmNlfSBvcHRzLmRlcHRobWFwIFRoZSBsYXllcidzIHVuZGVybHlpbmcgZGVwdGhtYXAge0BsaW5rIFNvdXJjZX0uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnBpbkZpcnN0TGV2ZWw9ZmFsc2VdIFdoZXRoZXIgdG8gcGluIHRoZSBmaXJzdCBsZXZlbCB0b1xuICogICAgIHByb3ZpZGUgYSBmYWxsYmFjayBvZiBsYXN0IHJlc29ydCwgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5IGNvbnN1bXB0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnRleHR1cmVTdG9yZU9wdHM9e31dIE9wdGlvbnMgdG8gcGFzcyB0byB0aGVcbiAqICAgICB7QGxpbmsgVGV4dHVyZVN0b3JlfSBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5sYXllck9wdHM9e31dIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUge0BsaW5rIExheWVyfVxuICogICAgIGNvbnN0cnVjdG9yLlxuICogQHJldHVybiB7TGF5ZXJ9XG4gKi9cblNjZW5lLnByb3RvdHlwZS5jcmVhdGVMYXllciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciB0ZXh0dXJlU3RvcmVPcHRzID0gb3B0cy50ZXh0dXJlU3RvcmVPcHRzIHx8IHt9O1xuICB2YXIgZGVwdGhtYXBTdG9yZU9wdHMgPSBvcHRzLmRlcHRobWFwU3RvcmVPcHRzIHx8IHt9O1xuICB2YXIgbGF5ZXJPcHRzID0gb3B0cy5sYXllck9wdHMgfHwge307XG5cbiAgdmFyIHNvdXJjZSA9IG9wdHMuc291cmNlO1xuICB2YXIgZ2VvbWV0cnkgPSBvcHRzLmdlb21ldHJ5O1xuICB2YXIgZGVwdGhtYXAgPSBvcHRzLmRlcHRobWFwO1xuICB2YXIgdmlldyA9IHRoaXMuX3ZpZXc7XG4gIHZhciBzdGFnZSA9IHRoaXMuX3ZpZXdlci5zdGFnZSgpO1xuICB2YXIgdGV4dHVyZVN0b3JlID0gbmV3IFRleHR1cmVTdG9yZShzb3VyY2UsIHN0YWdlLCB0ZXh0dXJlU3RvcmVPcHRzKTtcbiAgdmFyIGRlcHRobWFwU3RvcmUgPSBkZXB0aG1hcCAmJiBuZXcgRGVwdGhtYXBTdG9yZShkZXB0aG1hcCwgc3RhZ2UsIGRlcHRobWFwU3RvcmVPcHRzKTtcblxuICB2YXIgbGF5ZXIgPSBuZXcgTGF5ZXIoc291cmNlLCBnZW9tZXRyeSwgZGVwdGhtYXAsIHZpZXcsIHRleHR1cmVTdG9yZSwgZGVwdGhtYXBTdG9yZSwgbGF5ZXJPcHRzKTtcblxuICB0aGlzLl9sYXllcnMucHVzaChsYXllcik7XG5cbiAgaWYgKG9wdHMucGluRmlyc3RMZXZlbCkge1xuICAgIGxheWVyLnBpbkZpcnN0TGV2ZWwoKTtcbiAgfVxuXG4gIC8vIFNpZ25hbCB0aGF0IHRoZSBsYXllcnMgaGF2ZSBjaGFuZ2VkLlxuICB0aGlzLmVtaXQoJ2xheWVyQ2hhbmdlJyk7XG5cbiAgcmV0dXJuIGxheWVyO1xufTtcblxuXG4vKipcbiAqIERlc3Ryb3lzIGEge0BsaW5rIExheWVyIGxheWVyfSBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBzY2VuZS5cbiAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBsYXllciBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIHNjZW5lLlxuICovXG5TY2VuZS5wcm90b3R5cGUuZGVzdHJveUxheWVyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIHZhciBpID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICBpZiAoaSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggbGF5ZXIgaW4gc2NlbmUnKTtcbiAgfVxuXG4gIHRoaXMuX2xheWVycy5zcGxpY2UoaSwgMSk7XG5cbiAgLy8gU2lnbmFsIHRoYXQgdGhlIGxheWVycyBoYXZlIGNoYW5nZWQuXG4gIHRoaXMuZW1pdCgnbGF5ZXJDaGFuZ2UnKTtcblxuICBsYXllci50ZXh0dXJlU3RvcmUoKS5kZXN0cm95KCk7XG4gIGxheWVyLmRlc3Ryb3koKTtcbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyBhbGwge0BsaW5rIExheWVyIGxheWVyc30gYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBzY2VuZS5cbiAqL1xuU2NlbmUucHJvdG90eXBlLmRlc3Ryb3lBbGxMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHdoaWxlICh0aGlzLl9sYXllcnMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuZGVzdHJveUxheWVyKHRoaXMuX2xheWVyc1swXSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTd2l0Y2hlcyB0byB0aGUgc2NlbmUuXG4gKlxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcge0BsaW5rIFZpZXdlciNzd2l0Y2hTY2VuZX0gb24gdGhpcyBzY2VuZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zIHRvIHBhc3MgaW50byB7QGxpbmsgVmlld2VyI3N3aXRjaFNjZW5lfS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzd2l0Y2ggaXMgY29tcGxldGUuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5zd2l0Y2hUbyA9IGZ1bmN0aW9uIChvcHRzLCBkb25lKSB7XG4gIHJldHVybiB0aGlzLl92aWV3ZXIuc3dpdGNoU2NlbmUodGhpcywgb3B0cywgZG9uZSk7XG59O1xuXG5cbi8qKlxuICogVHdlZW5zIHRoZSBzY2VuZSdzIHVuZGVybHlpbmcge0BsaW5rIFZpZXcgdmlld30uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUYXJnZXQgdmlldyBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVHJhbnNpdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdHMuZWFzZT1lYXNlSW5PdXRRdWFkXSBUd2VlbiBlYXNpbmcgZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5jb250cm9sc0ludGVycnVwdD1mYWxzZV0gYWxsb3cgY29udHJvbHMgdG8gaW50ZXJydXB0XG4gKiAgICAgYW4gb25nb2luZyB0d2Vlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50cmFuc2l0aW9uRHVyYXRpb249MTAwMF0gVHdlZW4gZHVyYXRpb24sIGluXG4gKiAgICAgbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmNsb3Nlc3Q9dHJ1ZV0gV2hldGhlciB0byB0d2VlbiB0aHJvdWdoIHRoZSBzaG9ydGVzdFxuICogICAgcGF0aCBiZXR3ZWVuIHRoZSBpbml0aWFsIGFuZCBmaW5hbCB2aWV3IHBhcmFtZXRlcnMuIFRoaXMgcmVxdWlyZXNcbiAqICAgIHtAbGluayBWaWV3I25vcm1hbGl6ZVRvQ2xvc2VzdH0gdG8gYmUgaW1wbGVtZW50ZWQsIGFuZCBkb2VzIG5vdGhpbmdcbiAqICAgIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB0d2VlbiBmaW5pc2hlcyBvciBpc1xuICogICAgaW50ZXJydXB0ZWQuXG4gKi9cblNjZW5lLnByb3RvdHlwZS5sb29rVG8gPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRzLCBkb25lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgZG9uZSA9IGRvbmUgfHwgbm9vcDtcblxuICBpZiAodHlwZShwYXJhbXMpICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRhcmdldCB2aWV3IHBhcmFtZXRlcnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cblxuICAvLyBRdWFkcmF0aWMgaW4vb3V0IGVhc2luZy5cbiAgdmFyIGVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICB9XG4gICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICB9O1xuXG4gIHZhciBlYXNlID0gb3B0cy5lYXNlICE9IG51bGwgPyBvcHRzLmVhc2UgOiBlYXNlSW5PdXRRdWFkO1xuICB2YXIgY29udHJvbHNJbnRlcnJ1cHQgPSBvcHRzLmNvbnRyb2xzSW50ZXJydXB0ICE9IG51bGwgPyBvcHRzLmNvbnRyb2xzSW50ZXJydXB0IDogZmFsc2U7XG4gIHZhciBkdXJhdGlvbiA9IG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uICE9IG51bGwgPyBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiA6IDEwMDA7XG4gIHZhciBzaG9ydGVzdCA9IG9wdHMuc2hvcnRlc3QgIT0gbnVsbCA/IG9wdHMuc2hvcnRlc3QgOiB0cnVlO1xuXG4gIHZhciB2aWV3ID0gdGhpcy5fdmlldztcblxuICB2YXIgaW5pdGlhbFBhcmFtcyA9IHZpZXcucGFyYW1ldGVycygpO1xuXG4gIHZhciBmaW5hbFBhcmFtcyA9IHt9O1xuICBkZWZhdWx0cyhmaW5hbFBhcmFtcywgcGFyYW1zKTtcbiAgZGVmYXVsdHMoZmluYWxQYXJhbXMsIGluaXRpYWxQYXJhbXMpO1xuXG4gIC8vIFR3ZWVuIHRocm91Z2ggdGhlIHNob3J0ZXN0IHBhdGggaWYgcmVxdWVzdGVkLlxuICAvLyBUaGUgdmlldyBtdXN0IGltcGxlbWVudCB0aGUgbm9ybWFsaXplVG9DbG9zZXN0KCkgbWV0aG9kLlxuICBpZiAoc2hvcnRlc3QgJiYgdmlldy5ub3JtYWxpemVUb0Nsb3Nlc3QpIHtcbiAgICB2aWV3Lm5vcm1hbGl6ZVRvQ2xvc2VzdChmaW5hbFBhcmFtcywgZmluYWxQYXJhbXMpO1xuICB9XG5cbiAgdmFyIG1vdmVtZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGZpbmFsVXBkYXRlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmFtcywgZWxhcHNlZCkge1xuXG4gICAgICBpZiAoZWxhcHNlZCA+PSBkdXJhdGlvbiAmJiBmaW5hbFVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gTWF0aC5taW4oZWxhcHNlZCAvIGR1cmF0aW9uLCAxKTtcblxuICAgICAgZm9yICh2YXIgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGluaXRpYWxQYXJhbXNbcGFyYW1dO1xuICAgICAgICB2YXIgZW5kID0gZmluYWxQYXJhbXNbcGFyYW1dO1xuICAgICAgICBwYXJhbXNbcGFyYW1dID0gc3RhcnQgKyBlYXNlKGRlbHRhKSAqIChlbmQgLSBzdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGZpbmFsVXBkYXRlID0gZWxhcHNlZCA+PSBkdXJhdGlvbjtcblxuICAgICAgcmV0dXJuIHBhcmFtcztcblxuICAgIH07XG4gIH07XG5cbiAgdmFyIHJlZW5hYmxlQ29udHJvbHMgPSB0aGlzLl92aWV3ZXIuY29udHJvbHMoKS5lbmFibGVkKCk7XG5cbiAgaWYgKCFjb250cm9sc0ludGVycnVwdCkge1xuICAgIHRoaXMuX3ZpZXdlci5jb250cm9scygpLmRpc2FibGUoKTtcbiAgfVxuXG4gIHRoaXMuc3RhcnRNb3ZlbWVudChtb3ZlbWVudCwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWVuYWJsZUNvbnRyb2xzKSB7XG4gICAgICBzZWxmLl92aWV3ZXIuY29udHJvbHMoKS5lbmFibGUoKTtcbiAgICB9XG4gICAgZG9uZSgpO1xuICB9KTtcblxufTtcblxuXG4vKipcbiAqIFN0YXJ0cyBhIG1vdmVtZW50LCBwb3NzaWJseSByZXBsYWNpbmcgdGhlIGN1cnJlbnQgbW92ZW1lbnQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIG1vdmVtZW50IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZG9uZSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbW92ZW1lbnQgZmluaXNoZXMgb3IgaXNcbiAqICAgICBpbnRlcnJ1cHRlZC5cbiAqL1xuU2NlbmUucHJvdG90eXBlLnN0YXJ0TW92ZW1lbnQgPSBmdW5jdGlvbiAoZm4sIGRvbmUpIHtcblxuICB2YXIgcmVuZGVyTG9vcCA9IHRoaXMuX3ZpZXdlci5yZW5kZXJMb29wKCk7XG5cbiAgaWYgKHRoaXMuX21vdmVtZW50KSB7XG4gICAgdGhpcy5zdG9wTW92ZW1lbnQoKTtcbiAgfVxuXG4gIHZhciBzdGVwID0gZm4oKTtcbiAgaWYgKHR5cGVvZiBzdGVwICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgbW92ZW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX21vdmVtZW50ID0gZm47XG4gIHRoaXMuX21vdmVtZW50U3RlcCA9IHN0ZXA7XG4gIHRoaXMuX21vdmVtZW50U3RhcnRUaW1lID0gbm93KCk7XG4gIHRoaXMuX21vdmVtZW50UGFyYW1zID0ge307XG4gIHRoaXMuX21vdmVtZW50Q2FsbGJhY2sgPSBkb25lO1xuXG4gIHJlbmRlckxvb3AuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlUmVuZGVyJywgdGhpcy5fdXBkYXRlTW92ZW1lbnRIYW5kbGVyKTtcbiAgcmVuZGVyTG9vcC5yZW5kZXJPbk5leHRGcmFtZSgpO1xufTtcblxuXG4vKipcbiAqIFN0b3BzIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICovXG5TY2VuZS5wcm90b3R5cGUuc3RvcE1vdmVtZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBkb25lID0gdGhpcy5fbW92ZW1lbnRDYWxsYmFjaztcbiAgdmFyIHJlbmRlckxvb3AgPSB0aGlzLl92aWV3ZXIucmVuZGVyTG9vcCgpO1xuXG4gIGlmICghdGhpcy5fbW92ZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDbGVhciBzdGF0ZSBiZWZvcmUgY2FsbGluZyBkb25lLCB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agd2hlbiB0aGVcbiAgLy8gY2FsbGJhY2sgc3RhcnRzIGEgbmV3IG1vdmVtZW50LlxuICB0aGlzLl9tb3ZlbWVudCA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50U3RlcCA9IG51bGw7XG4gIHRoaXMuX21vdmVtZW50U3RhcnRUaW1lID0gbnVsbDtcbiAgdGhpcy5fbW92ZW1lbnRQYXJhbXMgPSBudWxsO1xuICB0aGlzLl9tb3ZlbWVudENhbGxiYWNrID0gbnVsbDtcblxuICByZW5kZXJMb29wLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZVJlbmRlcicsIHRoaXMuX3VwZGF0ZU1vdmVtZW50SGFuZGxlcik7XG5cbiAgaWYgKGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cblNjZW5lLnByb3RvdHlwZS5tb3ZlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX21vdmVtZW50O1xufTtcblxuXG5TY2VuZS5wcm90b3R5cGUuX3VwZGF0ZU1vdmVtZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gIGlmICghdGhpcy5fbW92ZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgY2FsbCB1cGRhdGUnKTtcbiAgfVxuXG4gIHZhciByZW5kZXJMb29wID0gdGhpcy5fdmlld2VyLnJlbmRlckxvb3AoKTtcbiAgdmFyIHZpZXcgPSB0aGlzLl92aWV3O1xuXG4gIHZhciBlbGFwc2VkID0gbm93KCkgLSB0aGlzLl9tb3ZlbWVudFN0YXJ0VGltZTtcbiAgdmFyIHN0ZXAgPSB0aGlzLl9tb3ZlbWVudFN0ZXA7XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9tb3ZlbWVudFBhcmFtcztcblxuICBwYXJhbXMgPSB2aWV3LnBhcmFtZXRlcnMocGFyYW1zKTtcbiAgcGFyYW1zID0gc3RlcChwYXJhbXMsIGVsYXBzZWQpO1xuICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICB0aGlzLnN0b3BNb3ZlbWVudCgpO1xuICB9IGVsc2Uge1xuICAgIHZpZXcuc2V0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgIHJlbmRlckxvb3AucmVuZGVyT25OZXh0RnJhbWUoKTtcbiAgfVxuXG59O1xuXG5cblNjZW5lLnByb3RvdHlwZS5fdXBkYXRlSG90c3BvdENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudmlzaWJsZSgpKSB7XG4gICAgdGhpcy5faG90c3BvdENvbnRhaW5lci5zaG93KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5faG90c3BvdENvbnRhaW5lci5oaWRlKCk7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2VuZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIE1hcCA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbnMvTWFwJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9ucy9TZXQnKTtcbnZhciBMcnVTZXQgPSByZXF1aXJlKCcuL2NvbGxlY3Rpb25zL0xydVNldCcpO1xudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi91dGlsL2RlZmF1bHRzJyk7XG52YXIgcmV0cnkgPSByZXF1aXJlKCcuL3V0aWwvcmV0cnknKTtcbnZhciBjaGFpbiA9IHJlcXVpcmUoJy4vdXRpbC9jaGFpbicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlsL2luaGVyaXRzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVidWcgPSB0eXBlb2YgTUFSWklQQU5PREVCVUcgIT09ICd1bmRlZmluZWQnICYmIE1BUlpJUEFOT0RFQlVHLnRleHR1cmVTdG9yZTtcblxuXG4vLyBBIFN0YWdlIGluZm9ybXMgdGhlIFRleHR1cmVTdG9yZSBhYm91dCB0aGUgc2V0IG9mIHZpc2libGUgdGlsZXMgZHVyaW5nIGFcbi8vIGZyYW1lIGJ5IGNhbGxpbmcgc3RhcnRGcmFtZSwgbWFya1RpbGUgYW5kIGVuZEZyYW1lLiBJbiBhIHBhcnRpY3VsYXIgZnJhbWUsXG4vLyBUZXh0dXJlU3RvcmUgZXhwZWN0cyBvbmUgb3IgbW9yZSBjYWxscyB0byBzdGFydEZyYW1lLCBmb2xsb3dlZCBieSB6ZXJvIG9yXG4vLyBtb3JlIGNhbGxzIHRvIG1hcmtUaWxlLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBjYWxscyB0byBlbmRGcmFtZS4gVGhlXG4vLyBudW1iZXIgb2YgY2FsbHMgdG8gc3RhcnRGcmFtZSBhbmQgZW5kRnJhbWUgbXVzdCBtYXRjaC4gQ2FsbHMgdG8gb3RoZXJcbi8vIFRleHR1cmVTdG9yZSBtZXRob2RzIG1heSBiZSBmcmVlbHkgaW50ZXJsZWF2ZWQgd2l0aCB0aGlzIHNlcXVlbmNlLlxuLy9cbi8vIEF0IGFueSBnaXZlbiB0aW1lLCBUZXh0dXJlU3RvcmUgaXMgaW4gb25lIG9mIGZvdXIgc3RhdGVzLiBUaGUgU1RBUlQgc3RhdGVcbi8vIGNvcnJlc3BvbmRzIHRvIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBmaXJzdCBzdGFydEZyYW1lIGFuZCB0aGUgZmlyc3Rcbi8vIG1hcmtUaWxlIG9mIGEgZnJhbWUuIFRoZSBNQVJLIHN0YXRlIGNvcnJlc3BvbmRzIHRvIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZVxuLy8gZmlyc3QgbWFya1RpbGUgYW5kIHRoZSBmaXJzdCBlbmRGcmFtZS4gVGhlIEVORCBzdGF0ZSBjb3JyZXNwb25kcyB0byB0aGVcbi8vIGludGVydmFsIGJldHdlZW4gdGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBlbmRGcmFtZS4gQXQgYW55IG90aGVyIHRpbWUsIHRoZVxuLy8gVGV4dHVyZVN0b3JlIGlzIGluIHRoZSBJRExFIHN0YXRlLlxudmFyIFN0YXRlID0ge1xuICBJRExFOiAwLFxuICBTVEFSVDogMSxcbiAgTUFSSzogMixcbiAgRU5EOiAzXG59O1xuXG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgY2FjaGVkIHRleHR1cmVzIGZvciBwcmV2aW91c2x5IHZpc2libGUgdGlsZXMuXG4gIHByZXZpb3VzbHlWaXNpYmxlQ2FjaGVTaXplOiA1MTJcbn07XG5cblxuLy8gQXNzaWduIGFuIGlkIHRvIGVhY2ggb3BlcmF0aW9uIHNvIHdlIGNhbiB0cmFjayBpdHMgc3RhdGUuXG4vLyBXZSBhY3R1YWxseSBvbmx5IG5lZWQgdGhpcyBpbiBkZWJ1ZyBtb2RlLCBidXQgdGhlIGNvZGUgaXMgbGVzcyBjb252b2x1dGVkXG4vLyBpZiB3ZSB0cmFjayB1bmNvbmRpdGlvbmFsbHksIGFuZCB0aGUgcGVyZm9ybWFuY2UgaGl0IGlzIG1pbmltYWwgYW55d2F5LlxudmFyIG5leHRJZCA9IDA7XG5cblxuLy8gRGlzdGluZ3Vpc2hlcyBhIGNhbmNlbGxhdGlvbiBmcm9tIG90aGVyIGtpbmRzIG9mIGVycm9ycy5cbmZ1bmN0aW9uIENhbmNlbEVycm9yKCkge31cbmluaGVyaXRzKENhbmNlbEVycm9yLCBFcnJvcik7XG5cblxuLyoqXG4gKiBAY2xhc3MgVGV4dHVyZVN0b3JlSXRlbVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEFuIGl0ZW0gc2F2ZWQgaW4gYSB7QGxpbmsgVGV4dHVyZVN0b3JlfS5cbiAqXG4gKiBDbGllbnRzIGRvIG5vdCBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuIEl0IGlzIGF1dG9tYXRpY2FsbHkgaW5zdGFudGlhdGVkIGJ5XG4gKiBhIHtAbGluayBUZXh0dXJlU3RvcmV9IHRvIG1hbmFnZSB0aGUgbGlmZXRpbWUgb2YgYSBzdG9yZWQgaXRlbTogbG9hZGluZyxcbiAqIHJlZnJlc2hpbmcsIHVubG9hZGluZyBhbmQgZW1pdHRpbmcgYXNzb2NpYXRlZCBldmVudHMuXG4gKlxuICogQHBhcmFtIHtUZXh0dXJlU3RvcmV9IHN0b3JlIFRoZSB1bmRlcmx5aW5nIHtAbGluayBUZXh0dXJlU3RvcmV9LlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB1bmRlcmx5aW5nIHRpbGUuXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmVTdG9yZUl0ZW0oc3RvcmUsIHRpbGUpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGlkID0gbmV4dElkKys7XG5cbiAgc2VsZi5faWQgPSBpZDtcbiAgc2VsZi5fc3RvcmUgPSBzdG9yZTtcbiAgc2VsZi5fdGlsZSA9IHRpbGU7XG5cbiAgc2VsZi5fYXNzZXQgPSBudWxsO1xuICBzZWxmLl90ZXh0dXJlID0gbnVsbDtcblxuICBzZWxmLl9jaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgc3RvcmUuZW1pdCgndGV4dHVyZUludmFsaWQnLCB0aWxlKTtcbiAgfTtcblxuICB2YXIgc291cmNlID0gc3RvcmUuc291cmNlKCk7XG4gIHZhciBzdGFnZSA9IHN0b3JlLnN0YWdlKCk7XG5cbiAgdmFyIGxvYWRBc3NldCA9IHNvdXJjZS5sb2FkQXNzZXQuYmluZChzb3VyY2UpO1xuICB2YXIgY3JlYXRlVGV4dHVyZSA9IHN0YWdlLmNyZWF0ZVRleHR1cmUuYmluZChzdGFnZSk7XG5cbiAgLy8gUmV0cnkgbG9hZGluZyB0aGUgYXNzZXQgdW50aWwgaXQgc3VjY2VlZHMsIHRoZW4gY3JlYXRlIHRoZSB0ZXh0dXJlIGZyb20gaXQuXG4gIC8vIFRoaXMgcHJvY2VzcyBtYXkgYmUgY2FuY2VsZWQgYXQgYW55IHBvaW50IGJ5IGNhbGxpbmcgdGhlIGRlc3Ryb3koKSBtZXRob2QuXG4gIHZhciBmbiA9IGNoYWluKHJldHJ5KGxvYWRBc3NldCksIGNyZWF0ZVRleHR1cmUpO1xuXG4gIHN0b3JlLmVtaXQoJ3RleHR1cmVTdGFydExvYWQnLCB0aWxlKTtcbiAgaWYgKGRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coJ2xvYWRpbmcnLCBpZCwgdGlsZSk7XG4gIH1cblxuICBzZWxmLl9jYW5jZWwgPSBmbihzdGFnZSwgdGlsZSwgZnVuY3Rpb24oZXJyLCBfdGlsZSwgYXNzZXQsIHRleHR1cmUpIHtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkbyBub3QgY2FsbCBjYW5jZWwgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICBzZWxmLl9jYW5jZWwgPSBudWxsO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgLy8gVGhlIGxvYWRpbmcgcHJvY2VzcyB3YXMgaW50ZXJydXB0ZWQgYnkgYW4gZXJyb3IuXG4gICAgICAvLyBUaGlzIGNvdWxkIGVpdGhlciBiZSBiZWNhdXNlIHRoZSB0ZXh0dXJlIGNyZWF0aW9uIGZhaWxlZCwgb3IgYmVjYXVzZVxuICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgY2FuY2VsZWQgYmVmb3JlIHRoZSBsb2FkaW5nIHdhcyBjb21wbGV0ZS5cblxuICAgICAgLy8gRGVzdHJveSB0aGUgYXNzZXQgYW5kIHRleHR1cmUsIGlmIHRoZXkgZXhpc3QuXG4gICAgICBpZiAoYXNzZXQpIHtcbiAgICAgICAgYXNzZXQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVtaXQgZXZlbnRzLlxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENhbmNlbEVycm9yKSB7XG4gICAgICAgIHN0b3JlLmVtaXQoJ3RleHR1cmVDYW5jZWwnLCB0aWxlKTtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2NhbmNlbCcsIGlkLCB0aWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuZW1pdCgndGV4dHVyZUVycm9yJywgdGlsZSwgZXJyKTtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yJywgaWQsIHRpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTYXZlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIHRoZSB0ZXh0dXJlLlxuICAgIHNlbGYuX3RleHR1cmUgPSB0ZXh0dXJlO1xuXG4gICAgLy8gSWYgdGhlIGFzc2V0IGlzIGR5bmFtaWMsIHNhdmUgYSBsb2NhbCByZWZlcmVuY2UgdG8gaXQgYW5kIHNldCB1cCBhXG4gICAgLy8gaGFuZGxlciB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgaXQgY2hhbmdlcy4gT3RoZXJ3aXNlLCBkZXN0cm95IHRoZSBhc3NldFxuICAgIC8vIGFzIHdlIHdvbid0IGJlIG5lZWRpbmcgaXQgYW55IGxvbmdlci5cbiAgICBpZiAoYXNzZXQuaXNEeW5hbWljKCkpIHtcbiAgICAgIHNlbGYuX2Fzc2V0ID0gYXNzZXQ7XG4gICAgICBhc3NldC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBzZWxmLl9jaGFuZ2VIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXQuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8vIEVtaXQgZXZlbnQuXG4gICAgc3RvcmUuZW1pdCgndGV4dHVyZUxvYWQnLCB0aWxlKTtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdsb2FkJywgaWQsIHRpbGUpO1xuICAgIH1cbiAgfSk7XG5cbn1cblxuXG5UZXh0dXJlU3RvcmVJdGVtLnByb3RvdHlwZS5hc3NldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXNzZXQ7XG59O1xuXG5cblRleHR1cmVTdG9yZUl0ZW0ucHJvdG90eXBlLnRleHR1cmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG59O1xuXG5cblRleHR1cmVTdG9yZUl0ZW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG4gIHZhciBzdG9yZSA9IHRoaXMuX3N0b3JlO1xuICB2YXIgdGlsZSA9IHRoaXMuX3RpbGU7XG4gIHZhciBhc3NldCA9IHRoaXMuX2Fzc2V0O1xuICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gIHZhciBjYW5jZWwgPSB0aGlzLl9jYW5jZWw7XG5cbiAgaWYgKGNhbmNlbCkge1xuICAgIC8vIFRoZSB0ZXh0dXJlIGlzIHN0aWxsIGxvYWRpbmcsIHNvIGNhbmNlbCBpdC5cbiAgICBjYW5jZWwobmV3IENhbmNlbEVycm9yKCdUZXh0dXJlIGxvYWQgY2FuY2VsbGVkJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlc3Ryb3kgYXNzZXQuXG4gIGlmIChhc3NldCkge1xuICAgIGFzc2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2NoYW5nZUhhbmRsZXIpO1xuICAgIGFzc2V0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIERlc3Ryb3kgdGV4dHVyZS5cbiAgaWYgKHRleHR1cmUpIHtcbiAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIEVtaXQgZXZlbnQuXG4gIHN0b3JlLmVtaXQoJ3RleHR1cmVVbmxvYWQnLCB0aWxlKTtcbiAgaWYgKGRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coJ3VubG9hZCcsIGlkLCB0aWxlKTtcbiAgfVxuXG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbmV2ZW50RW1pdHRlcihUZXh0dXJlU3RvcmVJdGVtKTtcblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSB0ZXh0dXJlIGhhcyBzdGFydGVkIHRvIGxvYWQuXG4gKlxuICogVGhpcyBldmVudCBpcyBmb2xsb3dlZCBieSBlaXRoZXIge0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlTG9hZH0sXG4gKiB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVFcnJvcn0gb3Ige0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlQ2FuY2VsfS5cbiAqXG4gKiBAZXZlbnQgVGV4dHVyZVN0b3JlI3RleHR1cmVTdGFydExvYWRcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgaGFzIHN0YXJ0ZWQgdG8gbG9hZC5cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gbG9hZGVkLlxuICpcbiAqIEBldmVudCBUZXh0dXJlU3RvcmUjdGV4dHVyZUxvYWRcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgd2FzIGxvYWRlZC5cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gdW5sb2FkZWQuXG4gKlxuICogQGV2ZW50IFRleHR1cmVTdG9yZSN0ZXh0dXJlVW5sb2FkXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgZm9yIHdoaWNoIHRoZSB0ZXh0dXJlIHdhcyB1bmxvYWRlZC5cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gaW52YWxpZGF0ZWQuXG4gKlxuICogVGhpcyBldmVudCBtYXkgYmUgcmFpc2VkIGZvciBhIHRleHR1cmUgd2l0aCBhbiB1bmRlcmx5aW5nIGR5bmFtaWMgYXNzZXQuIEl0XG4gKiBtYXkgb25seSBvY2N1ciB3aGlsZSB0aGUgdGV4dHVyZSBpcyBsb2FkZWQsIGkuZS4sIGluIGJldHdlZW5cbiAqIHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZUxvYWR9IGFuZCB7QGxpbmsgVGV4dHVyZVN0b3JlI3RleHR1cmVVbmxvYWR9LlxuICpcbiAqIEBldmVudCBUZXh0dXJlU3RvcmUjdGV4dHVyZUludmFsaWRcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgd2FzIGludmFsaWRhdGVkLlxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGxvYWRpbmcgYSB0ZXh0dXJlIGhhcyBiZWVuIGNhbmNlbGxlZC5cbiAqXG4gKiBUaGlzIGV2ZW50IG1heSBmb2xsb3cge0BsaW5rIFRleHR1cmVTdG9yZSN0ZXh0dXJlU3RhcnRMb2FkfSBpZiB0aGUgdGV4dHVyZVxuICogYmVjb21lcyB1bm5lY2Vzc2FyeSBiZWZvcmUgaXQgZmluaXNoZXMgbG9hZGluZy5cbiAqXG4gKiBAZXZlbnQgVGV4dHVyZVN0b3JlI3RleHR1cmVDYW5jZWxcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgbG9hZGluZyB3YXMgY2FuY2VsbGVkLlxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGxvYWRpbmcgYSB0ZXh0dXJlIGhhcyBmYWlsZWQuXG4gKlxuICogVGhpcyBldmVudCBtYXkgZm9sbG93IHtAbGluayBUZXh0dXJlU3RvcmUjdGV4dHVyZVN0YXJ0TG9hZH0gaWYgdGhlIHRleHR1cmVcbiAqIGZhaWxzIHRvIGxvYWQuXG4gKlxuICogQGV2ZW50IFRleHR1cmVTdG9yZSN0ZXh0dXJlRXJyb3JcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSBmb3Igd2hpY2ggdGhlIHRleHR1cmUgbG9hZGluZyBoYXMgZmFpbGVkLlxuICovXG5cbi8qKlxuICogQGNsYXNzIFRleHR1cmVTdG9yZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgVGV4dHVyZVN0b3JlIG1haW50YWlucyBhIGNhY2hlIG9mIHRleHR1cmVzIHVzZWQgdG8gcmVuZGVyIGEge0BsaW5rIExheWVyfS5cbiAqXG4gKiBBIHtAbGluayBTdGFnZX0gY29tbXVuaWNhdGVzIHdpdGggdGhlIFRleHR1cmVTdG9yZSB0aHJvdWdoIHRoZSBzdGFydEZyYW1lKCksXG4gKiBtYXJrVGlsZSgpIGFuZCBlbmRGcmFtZSgpIG1ldGhvZHMsIHdoaWNoIGluZGljYXRlIHRoZSB0aWxlcyB0aGF0IGFyZSB2aXNpYmxlXG4gKiBpbiB0aGUgY3VycmVudCBmcmFtZS4gVGV4dHVyZXMgZm9yIHZpc2libGUgdGlsZXMgYXJlIGxvYWRlZCBhbmQgcmV0YWluZWRcbiAqIGFzIGxvbmcgYXMgdGhlIHRpbGVzIHJlbWFpbiB2aXNpYmxlLiBBIGxpbWl0ZWQgYW1vdW50IG9mIHRleHR1cmVzIHdob3NlXG4gKiB0aWxlcyB3ZXJlIHByZXZpb3VzbHkgdmlzaWJsZSBhcmUgY2FjaGVkIGFjY29yZGluZyB0byBhbiBMUlUgcG9saWN5LiBUaWxlc1xuICogbWF5IGJlIHBpbm5lZCB0byBrZWVwIHRoZWlyIHJlc3BlY3RpdmUgdGV4dHVyZXMgY2FjaGVkIGV2ZW4gd2hlbiB0aGV5IGFyZVxuICogaW52aXNpYmxlOyB0aGVzZSB0ZXh0dXJlcyBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgcHJldmlvdXNseSB2aXNpYmxlIGxpbWl0LlxuICpcbiAqIE11bHRpcGxlIGxheWVycyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgdW5kZXJseWluZyB7QGxpbmsgV2ViR2xTdGFnZX0gbWF5XG4gKiBzaGFyZSB0aGUgc2FtZSBUZXh0dXJlU3RvcmUuIExheWVycyBiZWxvbmdpbmcgdG8gZGlzdGluY3Qge0BsaW5rIFdlYkdsU3RhZ2V9XG4gKiBpbnN0YW5jZXMgbWF5IG5vdCBkbyBzbyBkdWUgdG8gcmVzdHJpY3Rpb25zIG9uIHRoZSB1c2Ugb2YgdGV4dHVyZXMgYWNyb3NzXG4gKiBzdGFnZXMuXG4gKlxuICogQHBhcmFtIHtTb3VyY2V9IHNvdXJjZSBUaGUgdW5kZXJseWluZyBzb3VyY2UuXG4gKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUgdW5kZXJseWluZyBzdGFnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMucHJldmlvdXNseVZpc2libGVDYWNoZVNpemU9MzJdIFRoZSBtYXhpbXVtIG51bWJlciBvZlxuICogICAgIHByZXZpb3VzbHkgdmlzaWJsZSB0ZXh0dXJlcyB0byBjYWNoZSBhY2NvcmRpbmcgdG8gYW4gTFJVIHBvbGljeS5cbiAqL1xuZnVuY3Rpb24gVGV4dHVyZVN0b3JlKHNvdXJjZSwgc3RhZ2UsIG9wdHMpIHtcbiAgb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRpb25zKTtcblxuICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG5cbiAgLy8gVGhlIGN1cnJlbnQgc3RhdGUuXG4gIHRoaXMuX3N0YXRlID0gU3RhdGUuSURMRTtcblxuICAvLyBUaGUgbnVtYmVyIG9mIHN0YXJ0RnJhbWUgY2FsbHMgeWV0IHRvIGJlIG1hdGNoZWQgYnkgZW5kRnJhbWUgY2FsbHMgZHVyaW5nXG4gIC8vIHRoZSBjdXJyZW50IGZyYW1lLlxuICB0aGlzLl9kZWxpbUNvdW50ID0gMDtcblxuICAvLyBUaGUgY2FjaGUgcHJvcGVyOiBtYXAgY2FjaGVkIHRpbGVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgdGV4dHVyZXMvYXNzZXRzLlxuICB0aGlzLl9pdGVtTWFwID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRoZSBzdWJzZXQgb2YgY2FjaGVkIHRpbGVzIHRoYXQgYXJlIGN1cnJlbnRseSB2aXNpYmxlLlxuICB0aGlzLl92aXNpYmxlID0gbmV3IFNldCgpO1xuXG4gIC8vIFRoZSBzdWJzZXQgb2YgY2FjaGVkIHRpbGVzIHRoYXQgd2VyZSB2aXNpYmxlIHJlY2VudGx5LCBidXQgYXJlIG5vdFxuICAvLyB2aXNpYmxlIHJpZ2h0IG5vdy4gTmV3bHkgaW5zZXJ0ZWQgdGlsZXMgcmVwbGFjZSBvbGRlciBvbmVzLlxuICB0aGlzLl9wcmV2aW91c2x5VmlzaWJsZSA9IG5ldyBMcnVTZXQob3B0cy5wcmV2aW91c2x5VmlzaWJsZUNhY2hlU2l6ZSk7XG5cbiAgLy8gVGhlIHN1YnNldCBvZiBjYWNoZWQgdGlsZXMgdGhhdCBzaG91bGQgbmV2ZXIgYmUgZXZpY3RlZCBmcm9tIHRoZSBjYWNoZS5cbiAgLy8gQSB0aWxlIG1heSBiZSBwaW5uZWQgbW9yZSB0aGFuIG9uY2U7IG1hcCBlYWNoIHRpbGUgaW50byBhIHJlZmVyZW5jZSBjb3VudC5cbiAgdGhpcy5fcGluTWFwID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRlbXBvcmFyeSB2YXJpYWJsZXMuXG4gIHRoaXMuX25ld1Zpc2libGUgPSBuZXcgU2V0KCk7XG4gIHRoaXMuX25vTG9uZ2VyVmlzaWJsZSA9IFtdO1xuICB0aGlzLl92aXNpYmxlQWdhaW4gPSBbXTtcbiAgdGhpcy5fZXZpY3RlZCA9IFtdO1xufVxuXG5ldmVudEVtaXR0ZXIoVGV4dHVyZVN0b3JlKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNsZWFyKCk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHVuZGVybHlpbmcge0BsaW5rIFN0YWdlfS5cbiAqIEByZXR1cm4ge1N0YWdlfVxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnN0YWdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zdGFnZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHVuZGVybHlpbmcge0BsaW5rIFNvdXJjZX0uXG4gKiBAcmV0dXJuIHtTb3VyY2V9XG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zb3VyY2U7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0ZXh0dXJlcyBmcm9tIHRoZSBUZXh0dXJlU3RvcmUsIGluY2x1ZGluZyBwaW5uZWQgdGV4dHVyZXMuXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIENvbGxlY3QgbGlzdCBvZiB0aWxlcyB0byBiZSBldmljdGVkLlxuICBzZWxmLl9ldmljdGVkLmxlbmd0aCA9IDA7XG4gIHNlbGYuX2l0ZW1NYXAuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgc2VsZi5fZXZpY3RlZC5wdXNoKHRpbGUpO1xuICB9KTtcblxuICAvLyBFdmljdCB0aWxlcy5cbiAgc2VsZi5fZXZpY3RlZC5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBzZWxmLl91bmxvYWRUaWxlKHRpbGUpO1xuICB9KTtcblxuICAvLyBDbGVhciBhbGwgaW50ZXJuYWwgc3RhdGUuXG4gIHNlbGYuX2l0ZW1NYXAuY2xlYXIoKTtcbiAgc2VsZi5fdmlzaWJsZS5jbGVhcigpO1xuICBzZWxmLl9wcmV2aW91c2x5VmlzaWJsZS5jbGVhcigpO1xuICBzZWxmLl9waW5NYXAuY2xlYXIoKTtcbiAgc2VsZi5fbmV3VmlzaWJsZS5jbGVhcigpO1xuICBzZWxmLl9ub0xvbmdlclZpc2libGUubGVuZ3RoID0gMDtcbiAgc2VsZi5fdmlzaWJsZUFnYWluLmxlbmd0aCA9IDA7XG4gIHNlbGYuX2V2aWN0ZWQubGVuZ3RoID0gMDtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYWxsIHRleHR1cmVzIGluIHRoZSBUZXh0dXJlU3RvcmUsIGV4Y2x1ZGluZyB1bnBpbm5lZCB0ZXh0dXJlcy5cbiAqL1xuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5jbGVhck5vdFBpbm5lZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gQ29sbGVjdCBsaXN0IG9mIHRpbGVzIHRvIGJlIGV2aWN0ZWQuXG4gIHNlbGYuX2V2aWN0ZWQubGVuZ3RoID0gMDtcbiAgc2VsZi5faXRlbU1hcC5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBpZiAoIXNlbGYuX3Bpbk1hcC5oYXModGlsZSkpIHtcbiAgICAgIHNlbGYuX2V2aWN0ZWQucHVzaCh0aWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEV2aWN0IHRpbGVzLlxuICBzZWxmLl9ldmljdGVkLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIHNlbGYuX3VubG9hZFRpbGUodGlsZSk7XG4gIH0pO1xuXG4gIC8vIENsZWFyIGFsbCBjYWNoZXMgZXhjZXB0IHRoZSBwaW5uZWQgc2V0LlxuICBzZWxmLl92aXNpYmxlLmNsZWFyKCk7XG4gIHNlbGYuX3ByZXZpb3VzbHlWaXNpYmxlLmNsZWFyKCk7XG5cbiAgLy8gQ2xlYXIgdGVtcG9yYXJ5IHZhcmlhYmxlcy5cbiAgc2VsZi5fZXZpY3RlZC5sZW5ndGggPSAwO1xufTtcblxuXG4vKipcbiAqIFNpZ25hbCB0aGUgYmVnaW5uaW5nIG9mIGEgZnJhbWUuIENhbGxlZCBmcm9tIHtAbGluayBTdGFnZX0uXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuc3RhcnRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBDaGVjayB0aGF0IHdlIGFyZSBpbiBhbiBhcHByb3ByaWF0ZSBzdGF0ZS5cbiAgaWYgKHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5JRExFICYmIHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5TVEFSVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZVN0b3JlOiBzdGFydEZyYW1lIGNhbGxlZCBvdXQgb2Ygc2VxdWVuY2UnKTtcbiAgfVxuXG4gIC8vIEVudGVyIHRoZSBTVEFSVCBzdGF0ZSwgaWYgbm90IGFscmVhZHkgdGhlcmUuXG4gIHRoaXMuX3N0YXRlID0gU3RhdGUuU1RBUlQ7XG5cbiAgLy8gRXhwZWN0IG9uZSBtb3JlIGVuZEZyYW1lIGNhbGwuXG4gIHRoaXMuX2RlbGltQ291bnQrKztcbn07XG5cblxuLyoqXG4gKiBNYXJrIGEgdGlsZSBhcyB2aXNpYmxlIHdpdGhpbiB0aGUgY3VycmVudCBmcmFtZS4gQ2FsbGVkIGZyb20ge0BsaW5rIFN0YWdlfS5cbiAqIEBwYXJhbSB7VGlsZX0gdGlsZSBUaGUgdGlsZSB0byBtYXJrLlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLm1hcmtUaWxlID0gZnVuY3Rpb24odGlsZSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGFyZSBpbiBhbiBhcHByb3ByaWF0ZSBzdGF0ZS5cbiAgaWYgKHRoaXMuX3N0YXRlICE9PSBTdGF0ZS5TVEFSVCAmJiB0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuTUFSSykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZVN0b3JlOiBtYXJrVGlsZSBjYWxsZWQgb3V0IG9mIHNlcXVlbmNlJyk7XG4gIH1cblxuICAvLyBFbnRlciB0aGUgTUFSSyBzdGF0ZSwgaWYgbm90IGFscmVhZHkgdGhlcmUuXG4gIHRoaXMuX3N0YXRlID0gU3RhdGUuTUFSSztcblxuICAvLyBSZWZyZXNoIHRleHR1cmUgZm9yIGR5bmFtaWMgYXNzZXRzLlxuICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICB2YXIgdGV4dHVyZSA9IGl0ZW0gJiYgaXRlbS50ZXh0dXJlKCk7XG4gIHZhciBhc3NldCA9IGl0ZW0gJiYgaXRlbS5hc3NldCgpO1xuICBpZiAodGV4dHVyZSAmJiBhc3NldCkge1xuICAgIHRleHR1cmUucmVmcmVzaCh0aWxlLCBhc3NldCk7XG4gIH1cblxuICAvLyBBZGQgdGlsZSB0byB0aGUgdmlzaWJsZSBzZXQuXG4gIHRoaXMuX25ld1Zpc2libGUuYWRkKHRpbGUpO1xufTtcblxuXG4vKipcbiAqIFNpZ25hbCB0aGUgZW5kIG9mIGEgZnJhbWUuIENhbGxlZCBmcm9tIHtAbGluayBTdGFnZX0uXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuZW5kRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgaW4gYW4gYXBwcm9wcmlhdGUgc3RhdGUuXG4gIGlmICh0aGlzLl9zdGF0ZSAhPT0gU3RhdGUuU1RBUlQgJiYgdGhpcy5fc3RhdGUgIT09IFN0YXRlLk1BUksgJiYgdGhpcy5fc3RhdGUgIT09IFN0YXRlLkVORCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZVN0b3JlOiBlbmRGcmFtZSBjYWxsZWQgb3V0IG9mIHNlcXVlbmNlJyk7XG4gIH1cblxuICAvLyBFbnRlciB0aGUgRU5EIHN0YXRlLCBpZiBub3QgYWxyZWFkeSB0aGVyZS5cbiAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5FTkQ7XG5cbiAgLy8gRXhwZWN0IG9uZSBsZXNzIGNhbGwgdG8gZW5kRnJhbWUuXG4gIHRoaXMuX2RlbGltQ291bnQtLTtcblxuICAvLyBJZiBubyBmdXJ0aGVyIGNhbGxzIGFyZSBleHBlY3RlZCwgcHJvY2VzcyBmcmFtZSBhbmQgZW50ZXIgdGhlIElETEUgc3RhdGUuXG4gIGlmICghdGhpcy5fZGVsaW1Db3VudCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIHRoaXMuX3N0YXRlID0gU3RhdGUuSURMRTtcbiAgfVxufTtcblxuXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgc2V0IG9mIHRpbGVzIHRoYXQgdXNlZCB0byBiZSB2aXNpYmxlIGJ1dCBubyBsb25nZXIgYXJlLlxuICBzZWxmLl9ub0xvbmdlclZpc2libGUubGVuZ3RoID0gMDtcbiAgc2VsZi5fdmlzaWJsZS5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBpZiAoIXNlbGYuX25ld1Zpc2libGUuaGFzKHRpbGUpKSB7XG4gICAgICBzZWxmLl9ub0xvbmdlclZpc2libGUucHVzaCh0aWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgc2V0IG9mIHRpbGVzIHRoYXQgd2VyZSB2aXNpYmxlIHJlY2VudGx5IGFuZCBoYXZlIGJlY29tZVxuICAvLyB2aXNpYmxlIGFnYWluLlxuICBzZWxmLl92aXNpYmxlQWdhaW4ubGVuZ3RoID0gMDtcbiAgc2VsZi5fbmV3VmlzaWJsZS5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBpZiAoc2VsZi5fcHJldmlvdXNseVZpc2libGUuaGFzKHRpbGUpKSB7XG4gICAgICBzZWxmLl92aXNpYmxlQWdhaW4ucHVzaCh0aWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFJlbW92ZSB0aWxlcyB0aGF0IGhhdmUgYmVjb21lIHZpc2libGUgYWdhaW4gZnJvbSB0aGUgbGlzdCBvZiBwcmV2aW91c2x5XG4gIC8vIHZpc2libGUgdGlsZXMuXG4gIHNlbGYuX3Zpc2libGVBZ2Fpbi5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICBzZWxmLl9wcmV2aW91c2x5VmlzaWJsZS5yZW1vdmUodGlsZSk7XG4gIH0pO1xuXG4gIC8vIENhbmNlbCBsb2FkaW5nIG9mIHRpbGVzIHRoYXQgYXJlIG5vIGxvbmdlciB2aXNpYmxlLlxuICAvLyBNb3ZlIG5vIGxvbmdlciB2aXNpYmxlIHRpbGVzIHdpdGggYSBsb2FkZWQgdGV4dHVyZSBpbnRvIHRoZSBwcmV2aW91c2x5XG4gIC8vIHZpc2libGUgc2V0LCBhbmQgY29sbGVjdCB0aGUgdGlsZXMgZXZpY3RlZCBmcm9tIHRoZSBsYXR0ZXIuXG4gIHNlbGYuX2V2aWN0ZWQubGVuZ3RoID0gMDtcbiAgc2VsZi5fbm9Mb25nZXJWaXNpYmxlLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIHZhciBpdGVtID0gc2VsZi5faXRlbU1hcC5nZXQodGlsZSk7XG4gICAgdmFyIHRleHR1cmUgPSBpdGVtICYmIGl0ZW0udGV4dHVyZSgpO1xuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB2YXIgb3RoZXJUaWxlID0gc2VsZi5fcHJldmlvdXNseVZpc2libGUuYWRkKHRpbGUpO1xuICAgICAgaWYgKG90aGVyVGlsZSAhPSBudWxsKSB7XG4gICAgICAgIHNlbGYuX2V2aWN0ZWQucHVzaChvdGhlclRpbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXRlbSkge1xuICAgICAgc2VsZi5fdW5sb2FkVGlsZSh0aWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFVubG9hZCBldmljdGVkIHRpbGVzLCB1bmxlc3MgdGhleSBhcmUgcGlubmVkLlxuICBzZWxmLl9ldmljdGVkLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgIGlmICghc2VsZi5fcGluTWFwLmhhcyh0aWxlKSkge1xuICAgICAgc2VsZi5fdW5sb2FkVGlsZSh0aWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIExvYWQgdmlzaWJsZSB0aWxlcyB0aGF0IGFyZSBub3QgYWxyZWFkeSBpbiB0aGUgc3RvcmUuXG4gIC8vIFJlZnJlc2ggdGV4dHVyZSBvbiB2aXNpYmxlIHRpbGVzIGZvciBkeW5hbWljIGFzc2V0cy5cbiAgc2VsZi5fbmV3VmlzaWJsZS5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICB2YXIgaXRlbSA9IHNlbGYuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgc2VsZi5fbG9hZFRpbGUodGlsZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBTd2FwIHRoZSBvbGQgdmlzaWJsZSBzZXQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgdmFyIHRtcCA9IHNlbGYuX3Zpc2libGU7XG4gIHNlbGYuX3Zpc2libGUgPSBzZWxmLl9uZXdWaXNpYmxlO1xuICBzZWxmLl9uZXdWaXNpYmxlID0gdG1wO1xuXG4gIC8vIENsZWFyIHRoZSBuZXcgdmlzaWJsZSBzZXQuXG4gIHNlbGYuX25ld1Zpc2libGUuY2xlYXIoKTtcblxuICAvLyBDbGVhciB0ZW1wb3JhcnkgdmFyaWFibGVzLlxuICBzZWxmLl9ub0xvbmdlclZpc2libGUubGVuZ3RoID0gMDtcbiAgc2VsZi5fdmlzaWJsZUFnYWluLmxlbmd0aCA9IDA7XG4gIHNlbGYuX2V2aWN0ZWQubGVuZ3RoID0gMDtcbn07XG5cblxuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS5fbG9hZFRpbGUgPSBmdW5jdGlvbih0aWxlKSB7XG4gIGlmICh0aGlzLl9pdGVtTWFwLmhhcyh0aWxlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZVN0b3JlOiBsb2FkaW5nIHRleHR1cmUgYWxyZWFkeSBpbiBjYWNoZScpO1xuICB9XG4gIHZhciBpdGVtID0gbmV3IFRleHR1cmVTdG9yZUl0ZW0odGhpcywgdGlsZSk7XG4gIHRoaXMuX2l0ZW1NYXAuc2V0KHRpbGUsIGl0ZW0pO1xufTtcblxuXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLl91bmxvYWRUaWxlID0gZnVuY3Rpb24odGlsZSkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1NYXAuZGVsKHRpbGUpO1xuICBpZiAoIWl0ZW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmVTdG9yZTogdW5sb2FkaW5nIHRleHR1cmUgbm90IGluIGNhY2hlJyk7XG4gIH1cbiAgaXRlbS5kZXN0cm95KCk7XG59O1xuXG5cblRleHR1cmVTdG9yZS5wcm90b3R5cGUuYXNzZXQgPSBmdW5jdGlvbih0aWxlKSB7XG4gIHZhciBpdGVtID0gdGhpcy5faXRlbU1hcC5nZXQodGlsZSk7XG4gIGlmIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uYXNzZXQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuVGV4dHVyZVN0b3JlLnByb3RvdHlwZS50ZXh0dXJlID0gZnVuY3Rpb24odGlsZSkge1xuICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1NYXAuZ2V0KHRpbGUpO1xuICBpZiAoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnRleHR1cmUoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBQaW4gYSB0aWxlLiBUZXh0dXJlcyBmb3IgcGlubmVkIHRpbGVzIGFyZSBuZXZlciBldmljdGVkIGZyb20gdGhlIHN0b3JlLlxuICogVXBvbiBwaW5uaW5nLCB0aGUgdGV4dHVyZSBpcyBjcmVhdGVkIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuIFBpbnMgYXJlXG4gKiByZWZlcmVuY2UtY291bnRlZDsgYSB0aWxlIG1heSBiZSBwaW5uZWQgbXVsdGlwbGUgdGltZXMgYW5kIG11c3QgYmUgdW5waW5uZWRcbiAqIHRoZSBjb3JyZXNwb25kaW5nIG51bWJlciBvZiB0aW1lcy4gUGlubmluZyBpcyB1c2VmdWwgZS5nLiB0byBlbnN1cmUgdGhhdFxuICogdGhlIGxvd2VzdC1yZXNvbHV0aW9uIGxldmVsIG9mIGFuIGltYWdlIGlzIGFsd2F5cyBhdmFpbGFibGUgdG8gZmFsbCBiYWNrXG4gKiBvbnRvLlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIHRoZSB0aWxlIHRvIHBpblxuICogQHJldHVybnMge251bWJlcn0gdGhlIHBpbiByZWZlcmVuY2UgY291bnQuXG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUucGluID0gZnVuY3Rpb24odGlsZSkge1xuICAvLyBJbmNyZW1lbnQgcmVmZXJlbmNlIGNvdW50LlxuICB2YXIgY291bnQgPSAodGhpcy5fcGluTWFwLmdldCh0aWxlKSB8fCAwKSArIDE7XG4gIHRoaXMuX3Bpbk1hcC5zZXQodGlsZSwgY291bnQpO1xuICAvLyBJZiB0aGUgdGV4dHVyZSBmb3IgdGhlIHRpbGUgaXMgbm90IHByZXNlbnQsIGxvYWQgaXQgbm93LlxuICBpZiAoIXRoaXMuX2l0ZW1NYXAuaGFzKHRpbGUpKSB7XG4gICAgdGhpcy5fbG9hZFRpbGUodGlsZSk7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuXG4vKipcbiAqIFVucGluIGEgdGlsZS4gUGlucyBhcmUgcmVmZXJlbmNlLWNvdW50ZWQ7IGEgdGlsZSBtYXkgYmUgcGlubmVkIG11bHRpcGxlXG4gKiB0aW1lcyBhbmQgbXVzdCBiZSB1bnBpbm5lZCB0aGUgY29ycmVzcG9uZGluZyBudW1iZXIgb2YgdGltZXMuXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgdGhlIHRpbGUgdG8gdW5waW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBwaW4gcmVmZXJlbmNlIGNvdW50LlxuICovXG5UZXh0dXJlU3RvcmUucHJvdG90eXBlLnVucGluID0gZnVuY3Rpb24odGlsZSkge1xuICB2YXIgY291bnQgPSB0aGlzLl9waW5NYXAuZ2V0KHRpbGUpO1xuICAvLyBDb25zaXN0ZW5jeSBjaGVjay5cbiAgaWYgKCFjb3VudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZVN0b3JlOiB1bnBpbiB3aGVuIG5vdCBwaW5uZWQnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50LlxuICAgIGNvdW50LS07XG4gICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgdGhpcy5fcGluTWFwLnNldCh0aWxlLCBjb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Bpbk1hcC5kZWwodGlsZSk7XG4gICAgICAvLyBJZiB0aGUgdGlsZSBkb2VzIG5vdCBiZWxvbmcgdG8gZWl0aGVyIHRoZSB2aXNpYmxlIG9yIHByZXZpb3VzbHlcbiAgICAgIC8vIHZpc2libGUgc2V0cywgZXZpY3QgaXQgZnJvbSB0aGUgY2FjaGUuXG4gICAgICBpZiAoIXRoaXMuX3Zpc2libGUuaGFzKHRpbGUpICYmICF0aGlzLl9wcmV2aW91c2x5VmlzaWJsZS5oYXModGlsZSkpIHtcbiAgICAgICAgdGhpcy5fdW5sb2FkVGlsZSh0aWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuXG4vKipcbiAqIFJldHVybiB0eXBlIGZvciB7QGxpbmsgVGV4dHVyZVN0b3JlI3F1ZXJ5fS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbGVTdGF0ZVxuICogQHByb3BlcnR5IHtib29sZWFufSB2aXNpYmxlIFdoZXRoZXIgdGhlIHRpbGUgaXMgaW4gdGhlIHZpc2libGUgc2V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBwcmV2aW91c2x5VmlzaWJsZSBXaGV0aGVyIHRoZSB0aWxlIGlzIGluIHRoZSBwcmV2aW91c2x5XG4gKiAgICAgdmlzaWJsZSBzZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc0Fzc2V0IFdoZXRoZXIgdGhlIGFzc2V0IGZvciB0aGUgdGlsZSBpcyBwcmVzZW50LlxuICogQHByb3BlcnR5IHtib29sZWFufSBoYXNUZXh0dXJlIFdoZXRoZXIgdGhlIHRleHR1cmUgZm9yIHRoZSB0aWxlIGlzIHByZXNlbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBpbm5lZCBXaGV0aGVyIHRoZSB0aWxlIGlzIGluIHRoZSBwaW5uZWQgc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpbkNvdW50IFRoZSBwaW4gcmVmZXJlbmNlIGNvdW50IGZvciB0aGUgdGlsZS5cbiAqL1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdGF0ZSBvZiBhIHRpbGUuXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGUgVGhlIHRpbGUgdG8gcXVlcnkuXG4gKiBAcmV0dXJuIHtUaWxlU3RhdGV9XG4gKi9cblRleHR1cmVTdG9yZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih0aWxlKSB7XG4gIHZhciBpdGVtID0gdGhpcy5faXRlbU1hcC5nZXQodGlsZSk7XG4gIHZhciBwaW5Db3VudCA9IHRoaXMuX3Bpbk1hcC5nZXQodGlsZSkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB2aXNpYmxlOiB0aGlzLl92aXNpYmxlLmhhcyh0aWxlKSxcbiAgICBwcmV2aW91c2x5VmlzaWJsZTogdGhpcy5fcHJldmlvdXNseVZpc2libGUuaGFzKHRpbGUpLFxuICAgIGhhc0Fzc2V0OiBpdGVtICE9IG51bGwgJiYgaXRlbS5hc3NldCgpICE9IG51bGwsXG4gICAgaGFzVGV4dHVyZTogaXRlbSAhPSBudWxsICYmIGl0ZW0udGV4dHVyZSgpICE9IG51bGwsXG4gICAgcGlubmVkOiBwaW5Db3VudCAhPT0gMCxcbiAgICBwaW5Db3VudDogcGluQ291bnRcbiAgfTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlU3RvcmU7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXQgPSByZXF1aXJlKCcuL2NvbGxlY3Rpb25zL1NldCcpO1xuXG4vKipcbiAqIEBjbGFzcyBUaWxlU2VhcmNoZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFRpbGVTZWFyY2hlciBwZXJmb3JtcyBzZWFyY2hlcyBmb3IgdmlzaWJsZSB0aWxlcy5cbiAqL1xuZnVuY3Rpb24gVGlsZVNlYXJjaGVyKCkge1xuICAvLyBTdGFjayBvZiB0aWxlcyB0byBiZSBleHBsb3JlZC5cbiAgdGhpcy5fc3RhY2sgPSBbXTtcblxuICAvLyBTZXQgb2YgYWxyZWFkeSBleHBsb3JlZCB0aWxlcy5cbiAgdGhpcy5fdmlzaXRlZCA9IG5ldyBTZXQoKTtcblxuICAvLyBUaWxlIHZlcnRpY2VzLiBBbGxvY2F0ZWQgYnkgVGlsZSN2ZXJ0aWNlcyBvbiBmaXJzdCB1c2UuXG4gIHRoaXMuX3ZlcnRpY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNlYXJjaCBmb3IgdmlzaWJsZSB0aWxlcyBieSBzdGFydGluZyBhdCBhIGdpdmVuIHRpbGUgYW5kXG4gKiByZWN1cnNpdmVseSBleHBsb3JpbmcgbmVpZ2hib3JzIHVudGlsIG5vIG1vcmUgdmlzaWJsZSB0aWxlcyBhcmUgZm91bmQuXG4gKlxuICogQHBhcmFtIHtWaWV3fSB2aWV3IFRoZSB2aWV3IHVzZWQgdG8gZGVlbSB3aGV0aGVyIGEgdGlsZSBpcyB2aXNpYmxlLlxuICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSBzdGFydGluZyB0aWxlLlxuICogQHBhcmFtIHtUaWxlW119IHJlc3VsdCBBbiBhcnJheSB0byBhcHBlbmQgdGhlIHZpc2libGUgdGlsZXMgdG8sIGluY2x1ZGluZyB0aGVcbiAqICAgICBzdGFydGluZyB0aWxlIHdoZW4gdmlzaWJsZS4gRXhpc3RpbmcgYXJyYXkgbWVtYmVycyBhcmUgcHJlc2VydmVkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHZpc2libGUgdGlsZXMgZm91bmQuXG4gKi9cblRpbGVTZWFyY2hlci5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24odmlldywgc3RhcnRpbmdUaWxlLCByZXN1bHQpIHtcbiAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2s7XG4gIHZhciB2aXNpdGVkID0gdGhpcy5fdmlzaXRlZDtcbiAgdmFyIHZlcnRpY2VzID0gdGhpcy5fdmVydGljZXM7XG5cbiAgdmFyIGNvdW50ID0gMDtcblxuICAvLyBDbGVhciBpbnRlcm5hbCBzdGF0ZS5cbiAgdGhpcy5fY2xlYXIoKTtcblxuICBzdGFjay5wdXNoKHN0YXJ0aW5nVGlsZSk7XG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGlsZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKHZpc2l0ZWQuaGFzKHRpbGUpKSB7XG4gICAgICAvLyBTa2lwIGFscmVhZHkgdmlzaXRlZCB0aWxlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCF2aWV3LmludGVyc2VjdHModGlsZS52ZXJ0aWNlcyh2ZXJ0aWNlcykpKSB7XG4gICAgICAvLyBTa2lwIG5vbi12aXNpYmxlIHRpbGUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHRpbGUgYXMgdmlzaXRlZC5cbiAgICB2aXNpdGVkLmFkZCh0aWxlKTtcblxuICAgIC8vIEFkZCBuZWlnaGJvcnMgdG8gdGhlIHN0YWNrIG9mIHRpbGVzIHRvIGV4cGxvcmUuXG4gICAgdmFyIG5laWdoYm9ycyA9IHRpbGUubmVpZ2hib3JzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YWNrLnB1c2gobmVpZ2hib3JzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gcmVzdWx0LlxuICAgIHJlc3VsdC5wdXNoKHRpbGUpO1xuXG4gICAgY291bnQrKztcbiAgfVxuXG4gIC8vIFJldXNlIHRoZSB2ZXJ0aWNlcyBhcnJheSBpbiBmdXR1cmUgc2VhcmNoZXMuXG4gIHRoaXMuX3ZlcnRpY2VzID0gdmVydGljZXM7XG5cbiAgLy8gQ2xlYXIgaW50ZXJuYWwgc3RhdGUuXG4gIHRoaXMuX2NsZWFyKCk7XG5cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuVGlsZVNlYXJjaGVyLnByb3RvdHlwZS5fY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RhY2subGVuZ3RoID0gMDtcbiAgdGhpcy5fdmlzaXRlZC5jbGVhcigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaWxlU2VhcmNoZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vdXRpbC9kZWZhdWx0cycpO1xudmFyIG5vdyA9IHJlcXVpcmUoJy4vdXRpbC9ub3cnKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBkdXJhdGlvbjogSW5maW5pdHlcbn07XG5cblxuLyoqXG4gKiBTaWduYWxzIGEgdGltZW91dC5cbiAqIEBldmVudCBUaW1lciN0aW1lb3V0XG4gKi9cblxuXG4vKipcbiAqIEBjbGFzcyBUaW1lclxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgVGltZXIgcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gcmVjZWl2ZSBhbiBldmVudCBhZnRlciBhIHRpbWVvdXQuXG4gKlxuICogQSB0aW1lciBoYXMgYSBzZXQgZHVyYXRpb24sIGFuZCBpcyBlaXRoZXIgc3RhcnRlZCBvciBzdG9wcGVkIGF0IGEgZ2l2ZW4gdGltZS5cbiAqIFRoZSB0aW1lciBpcyBpbml0aWFsbHkgc3RvcHBlZC4gV2hlbiB0aGUgdGltZXIgaXMgc3RhcnRlZCwgYSB0aW1lb3V0IGV2ZW50IGlzXG4gKiBzY2hlZHVsZWQgdG8gZmlyZSBvbmNlIHRoZSBzZXQgZHVyYXRpb24gZWxhcHNlcy4gV2hlbiB0aGUgdGltZXIgaXMgc3RvcHBlZCxcbiAqIHRoZSBzY2hlZHVsZWQgdGltZW91dCBldmVudCBpcyBjYW5jZWxsZWQuIFdoZW4gYSB0aW1lb3V0IGV2ZW50IGZpcmVzLCB0aGVcbiAqIHRpbWVyIHJldHVybnMgdG8gdGhlIHN0b3BwZWQgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmR1cmF0aW9uPUluZmluaXR5XSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gVGltZXIob3B0cykge1xuXG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5fZHVyYXRpb24gPSBvcHRzLmR1cmF0aW9uO1xuXG4gIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cbiAgdGhpcy5faGFuZGxlID0gbnVsbDtcblxuICB0aGlzLl9jaGVjayA9IHRoaXMuX2NoZWNrLmJpbmQodGhpcyk7XG5cbn1cblxuZXZlbnRFbWl0dGVyKFRpbWVyKTtcblxuXG4vKipcbiAqIFN0YXJ0cyB0aGUgdGltZXIuIElmIHRoZSB0aW1lciBpcyBhbHJlYWR5IHN0YXJ0ZWQsIHRoaXMgaGFzIHRoZSBlZmZlY3Qgb2ZcbiAqIHN0b3BwaW5nIGFuZCBzdGFydGluZyBhZ2FpbiAoaS5lLiByZXNldHRpbmcgdGhlIHRpbWVyKS5cbiAqL1xuVGltZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N0YXJ0VGltZSA9IG5vdygpO1xuICBpZiAodGhpcy5faGFuZGxlID09IG51bGwgJiYgdGhpcy5fZHVyYXRpb24gPCBJbmZpbml0eSkge1xuICAgIHRoaXMuX3NldHVwKHRoaXMuX2R1cmF0aW9uKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdGltZXIgaXMgaW4gdGhlIHN0YXJ0ZWQgc3RhdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UaW1lci5wcm90b3R5cGUuc3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc3RhcnRUaW1lICE9IG51bGw7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgdGhlIHRpbWVyLlxuICovXG5UaW1lci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuICBpZiAodGhpcy5faGFuZGxlICE9IG51bGwpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5faGFuZGxlKTtcbiAgICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICB9XG59O1xuXG5cblRpbWVyLnByb3RvdHlwZS5fc2V0dXAgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICB0aGlzLl9oYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMuX2NoZWNrLCBpbnRlcnZhbCk7XG59O1xuXG5cblRpbWVyLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX2hhbmRsZSk7XG4gIHRoaXMuX2hhbmRsZSA9IG51bGw7XG59O1xuXG5cblRpbWVyLnByb3RvdHlwZS5fY2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gbm93KCk7XG4gIHZhciBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLl9zdGFydFRpbWU7XG4gIHZhciByZW1haW5pbmcgPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XG5cbiAgdGhpcy5fdGVhcmRvd24oKTtcblxuICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICB0aGlzLmVtaXQoJ3RpbWVvdXQnKTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuICB9IGVsc2UgaWYgKHJlbWFpbmluZyA8IEluZmluaXR5KSB7XG4gICAgdGhpcy5fc2V0dXAocmVtYWluaW5nKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBzZXQgZHVyYXRpb24uXG4gKi9cblRpbWVyLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZHVyYXRpb247XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgZHVyYXRpb24uIElmIHRoZSB0aW1lciBpcyBhbHJlYWR5IHN0YXJ0ZWQsIHRoZSB0aW1lb3V0IGV2ZW50IGlzXG4gKiByZXNjaGVkdWxlZCB0byBvY2N1ciBvbmNlIHRoZSBuZXcgZHVyYXRpb24gaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgY2FsbFxuICogdG8gc3RhcnQuIEluIHBhcnRpY3VsYXIsIGlmIGFuIGFtb3VudCBvZiB0aW1lIGxhcmdlciB0aGFuIHRoZSBuZXcgZHVyYXRpb25cbiAqIGhhcyBhbHJlYWR5IGVsYXBzZWQsIHRoZSB0aW1lb3V0IGV2ZW50IGZpcmVzIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKi9cblRpbWVyLnByb3RvdHlwZS5zZXREdXJhdGlvbiA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gIGlmICh0aGlzLl9zdGFydFRpbWUgIT0gbnVsbCkge1xuICAgIHRoaXMuX2NoZWNrKCk7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xuXG52YXIgUmVuZGVyTG9vcCA9IHJlcXVpcmUoJy4vUmVuZGVyTG9vcCcpO1xudmFyIENvbnRyb2xzID0gcmVxdWlyZSgnLi9jb250cm9scy9Db250cm9scycpO1xudmFyIFNjZW5lID0gcmVxdWlyZSgnLi9TY2VuZScpO1xudmFyIFRpbWVyID0gcmVxdWlyZSgnLi9UaW1lcicpO1xuXG52YXIgV2ViR2xTdGFnZSA9IHJlcXVpcmUoJy4vc3RhZ2VzL1dlYkdsJyk7XG5cbnZhciBDb250cm9sQ3Vyc29yID0gcmVxdWlyZSgnLi9jb250cm9scy9Db250cm9sQ3Vyc29yJyk7XG52YXIgSGFtbWVyR2VzdHVyZXMgPSByZXF1aXJlKCcuL2NvbnRyb2xzL0hhbW1lckdlc3R1cmVzJyk7XG5cbnZhciByZWdpc3RlckRlZmF1bHRDb250cm9scyA9IHJlcXVpcmUoJy4vY29udHJvbHMvcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMnKTtcbnZhciByZWdpc3RlckRlZmF1bHRSZW5kZXJlcnMgPSByZXF1aXJlKCcuL3JlbmRlcmVycy9yZWdpc3RlckRlZmF1bHRSZW5kZXJlcnMnKTtcblxudmFyIHNldE92ZXJmbG93SGlkZGVuID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldE92ZXJmbG93SGlkZGVuO1xudmFyIHNldEFic29sdXRlID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldEFic29sdXRlO1xudmFyIHNldEZ1bGxTaXplID0gcmVxdWlyZSgnLi91dGlsL2RvbScpLnNldEZ1bGxTaXplO1xuXG52YXIgdHdlZW4gPSByZXF1aXJlKCcuL3V0aWwvdHdlZW4nKTtcbnZhciBub29wID0gcmVxdWlyZSgnLi91dGlsL25vb3AnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSBjdXJyZW50IHNjZW5lIGhhcyBjaGFuZ2VkLlxuICogQGV2ZW50IFZpZXdlciNzY2VuZUNoYW5nZVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IHRoZSB2aWV3IG9mIHRoZSBjdXJyZW50IHNjZW5lIGhhcyBjaGFuZ2VkLiBTZWVcbiAqIHtAbGluayBWaWV3I2V2ZW50OmNoYW5nZX0uXG4gKiBAZXZlbnQgVmlld2VyI3ZpZXdDaGFuZ2VcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBWaWV3ZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFZpZXdlciBpcyBhIGNvbnRhaW5lciBmb3IgbXVsdGlwbGUge0BsaW5rIFNjZW5lIHNjZW5lc30gdG8gYmUgZGlzcGxheWVkXG4gKiBpbnNpZGUgYSB7QGxpbmsgU3RhZ2Ugc3RhZ2V9IGNvbnRhaW5lZCBpbiB0aGUgRE9NLlxuICpcbiAqIFNjZW5lcyBtYXkgYmUgY3JlYXRlZCBieSBjYWxsaW5nIHtAbGluayBWaWV3ZXIjY3JlYXRlU2NlbmV9LiBFeGNlcHQgZHVyaW5nIGFcbiAqIHNjZW5lIHN3aXRjaCwgYSBzaW5nbGUgb25lIG9mIHRoZW0sIGNhbGxlZCB0aGUgY3VycmVudCBzY2VuZSwgaXMgdmlzaWJsZS5cbiAqIENhbGxpbmcge0BsaW5rIFZpZXdlciNzd2l0Y2hTY2VuZX0gc2V0cyB0aGUgY3VycmVudCBzY2VuZSBhbmQgc3dpdGNoZXMgdG8gaXQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50IFRoZSBET00gZWxlbWVudCB0byBjb250YWluIHRoZSBzdGFnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFZpZXdlciBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29udHJvbHMgT3B0aW9ucyB0byBiZSBwYXNzZWQgdG9cbiAqICAgICB7QGxpbmsgcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHN9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuc3RhZ2UgT3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIHtAbGluayBTdGFnZX1cbiAqICAgICBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmN1cnNvcnMgQ3Vyc29yIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jdXJzb3JzLmRyYWcgRHJhZyBjdXJzb3Igb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlXG4gKiAgICAge0BsaW5rIENvbnRyb2xDdXJzb3J9IGNvbnN0cnVjdG9yLlxuICovXG5mdW5jdGlvbiBWaWV3ZXIoZG9tRWxlbWVudCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB0aGlzLl9kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxuICAvLyBBZGQgYG92ZXJmbG93OiBoaWRkZW5gIHRvIHRoZSBkb21FbGVtZW50LlxuICBzZXRPdmVyZmxvd0hpZGRlbihkb21FbGVtZW50KTtcblxuICAvLyBDcmVhdGUgc3RhZ2UuXG4gIHRoaXMuX3N0YWdlID0gbmV3IFdlYkdsU3RhZ2Uob3B0cy5zdGFnZSk7XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIGRlZmF1bHQgcmVuZGVyZXJzIGZvciB0aGUgc2VsZWN0ZWQgc3RhZ2UuXG4gIHJlZ2lzdGVyRGVmYXVsdFJlbmRlcmVycyh0aGlzLl9zdGFnZSk7XG5cbiAgLy8gQWRkIHRoZSBzdGFnZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAgdGhpcy5fZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9zdGFnZS5kb21FbGVtZW50KCkpO1xuXG4gIC8vIENyZWF0ZSBjb250cm9sIGNvbnRhaW5lci5cbiAgLy8gQ29udHJvbHMgY2Fubm90IGJlIHBsYWNlZCBkaXJlY3RseSBvbiB0aGUgcm9vdCBET00gZWxlbWVudCBiZWNhdXNlXG4gIC8vIEhhbW1lci5qcyB3aWxsIHByZXZlbnQgY2xpY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGVsZW1lbnRzIGJlbmVhdGguXG5cbiAgLy8gVGhlIGhvdHNwb3QgY29udGFpbmVycyB3aWxsIGJlIGFkZGVkIGluc2lkZSB0aGUgY29udHJvbHMgY29udGFpbmVyLlxuICB0aGlzLl9jb250cm9sQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHNldEFic29sdXRlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xuICBzZXRGdWxsU2l6ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcbiAgZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcblxuICAvLyBSZXNwb25kIHRvIHdpbmRvdyBzaXplIGNoYW5nZXMuXG4gIHRoaXMuX3NpemUgPSB7fTtcbiAgdGhpcy51cGRhdGVTaXplKCk7XG4gIHRoaXMuX3VwZGF0ZVNpemVMaXN0ZW5lciA9IHRoaXMudXBkYXRlU2l6ZS5iaW5kKHRoaXMpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fdXBkYXRlU2l6ZUxpc3RlbmVyKTtcblxuICAvLyBDcmVhdGUgcmVuZGVyIGxvb3AuXG4gIHRoaXMuX3JlbmRlckxvb3AgPSBuZXcgUmVuZGVyTG9vcCh0aGlzLl9zdGFnZSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBjb250cm9scyBhbmQgcmVnaXN0ZXIgdGhlbSB3aXRoIHRoZSByZW5kZXIgbG9vcC5cbiAgdGhpcy5fY29udHJvbHMgPSBuZXcgQ29udHJvbHMoKTtcbiAgdGhpcy5fY29udHJvbE1ldGhvZHMgPSByZWdpc3RlckRlZmF1bHRDb250cm9scyh0aGlzLl9jb250cm9scywgdGhpcy5fY29udHJvbENvbnRhaW5lciwgb3B0cy5jb250cm9scyk7XG4gIHRoaXMuX2NvbnRyb2xzLmF0dGFjaCh0aGlzLl9yZW5kZXJMb29wKTtcblxuICAvLyBFeHBvc2UgSGFtbWVySlMuXG4gIHRoaXMuX2hhbW1lck1hbmFnZXJUb3VjaCA9IEhhbW1lckdlc3R1cmVzLmdldCh0aGlzLl9jb250cm9sQ29udGFpbmVyLCAndG91Y2gnKTtcbiAgdGhpcy5faGFtbWVyTWFuYWdlck1vdXNlID0gSGFtbWVyR2VzdHVyZXMuZ2V0KHRoaXMuX2NvbnRyb2xDb250YWluZXIsICdtb3VzZScpO1xuXG4gIC8vIEluaXRpYWxpemUgZHJhZyBjdXJzb3IuXG4gIHRoaXMuX2RyYWdDdXJzb3IgPSBuZXcgQ29udHJvbEN1cnNvcih0aGlzLl9jb250cm9scywgJ21vdXNlVmlld0RyYWcnLCBkb21FbGVtZW50LCBvcHRzLmN1cnNvcnMgJiYgb3B0cy5jdXJzb3JzLmRyYWcgfHwge30pO1xuXG4gIC8vIFN0YXJ0IHRoZSByZW5kZXIgbG9vcC5cbiAgdGhpcy5fcmVuZGVyTG9vcC5zdGFydCgpO1xuXG4gIC8vIFNjZW5lIGxpc3QuXG4gIHRoaXMuX3NjZW5lcyA9IFtdO1xuXG4gIC8vIFRoZSBjdXJyZW50bHkgdmlzaWJsZSBzY2VuZS5cbiAgLy8gRHVyaW5nIGEgc2NlbmUgdHJhbnNpdGlvbiwgdGhpcyBpcyB0aGUgc2NlbmUgYmVpbmcgc3dpdGNoZWQgdG8uXG4gIHRoaXMuX2N1cnJlbnRTY2VuZSA9IG51bGw7XG5cbiAgLy8gVGhlIHNjZW5lIGJlaW5nIHN3aXRjaGVkIGZyb20gZHVyaW5nIGEgc2NlbmUgdHJhbnNpdGlvbi5cbiAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gdXBkYXRlIHRoZSBsYXllcnMgY29ycmVjdGx5IHdoZW4gdGhleSBhcmUgYWRkZWQgb3JcbiAgLy8gcmVtb3ZlZCBkdXJpbmcgYSB0cmFuc2l0aW9uLlxuICB0aGlzLl9yZXBsYWNlZFNjZW5lID0gbnVsbDtcblxuICAvLyBUaGUgY3VycmVudCB0cmFuc2l0aW9uLlxuICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4gPSBudWxsO1xuXG4gIC8vIFRoZSBldmVudCBsaXN0ZW5lciBmaXJlZCB3aGVuIHRoZSBjdXJyZW50IHNjZW5lIGxheWVycyBjaGFuZ2UuXG4gIC8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIGNvcnJlY3Qgc2NlbmUgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgc2NlbmUgY2hhbmdlcy5cbiAgdGhpcy5fbGF5ZXJDaGFuZ2VIYW5kbGVyID0gdGhpcy5fdXBkYXRlU2NlbmVMYXllcnMuYmluZCh0aGlzKTtcblxuICAvLyBUaGUgZXZlbnQgbGlzdGVuZXIgZmlyZWQgd2hlbiB0aGUgY3VycmVudCBzY2VuZSB2aWV3IGNoYW5nZXMuXG4gIC8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIGNvcnJlY3Qgc2NlbmUgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgc2NlbmUgY2hhbmdlcy5cbiAgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAndmlld0NoYW5nZScpO1xuXG4gIC8vIFNldHVwIHRoZSBpZGxlIHRpbWVyLlxuICAvLyBCeSBkZWZhdWx0LCB0aGUgdGltZXIgaGFzIGFuIGluZmluaXRlIGR1cmF0aW9uIHNvIGl0IGRvZXMgbm90aGluZy5cbiAgdGhpcy5faWRsZVRpbWVyID0gbmV3IFRpbWVyKCk7XG4gIHRoaXMuX2lkbGVUaW1lci5zdGFydCgpO1xuXG4gIC8vIFJlc2V0IHRoZSB0aW1lciB3aGVuZXZlciB0aGUgdmlldyBjaGFuZ2VzLlxuICB0aGlzLl9yZXNldElkbGVUaW1lckhhbmRsZXIgPSB0aGlzLl9yZXNldElkbGVUaW1lci5iaW5kKHRoaXMpO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZpZXdDaGFuZ2UnLCB0aGlzLl9yZXNldElkbGVUaW1lckhhbmRsZXIpO1xuXG4gIC8vIFN0YXJ0IHRoZSBpZGxlIG1vdmVtZW50IHdoZW4gdGhlIGlkbGUgdGltZXIgZmlyZXMuXG4gIHRoaXMuX3RyaWdnZXJJZGxlVGltZXJIYW5kbGVyID0gdGhpcy5fdHJpZ2dlcklkbGVUaW1lci5iaW5kKHRoaXMpO1xuICB0aGlzLl9pZGxlVGltZXIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIHRoaXMuX3RyaWdnZXJJZGxlVGltZXJIYW5kbGVyKTtcblxuICAvLyBTdG9wIGFuIG9uZ29pbmcgbW92ZW1lbnQgd2hlbiB0aGUgY29udHJvbHMgYXJlIGFjdGl2YXRlZCBvciB3aGVuIHRoZVxuICAvLyBzY2VuZSBjaGFuZ2VzLlxuICB0aGlzLl9zdG9wTW92ZW1lbnRIYW5kbGVyID0gdGhpcy5zdG9wTW92ZW1lbnQuYmluZCh0aGlzKTtcbiAgdGhpcy5fY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgdGhpcy5fc3RvcE1vdmVtZW50SGFuZGxlcik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignc2NlbmVDaGFuZ2UnLCB0aGlzLl9zdG9wTW92ZW1lbnRIYW5kbGVyKTtcblxuICAvLyBUaGUgY3VycmVudGx5IHByb2dyYW1tZWQgaWRsZSBtb3ZlbWVudC5cbiAgdGhpcy5faWRsZU1vdmVtZW50ID0gbnVsbDtcbn1cblxuZXZlbnRFbWl0dGVyKFZpZXdlcik7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3VwZGF0ZVNpemVMaXN0ZW5lcik7XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnRTY2VuZSkge1xuICAgIHRoaXMuX3JlbW92ZVNjZW5lRXZlbnRMaXN0ZW5lcnModGhpcy5fY3VycmVudFNjZW5lKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXBsYWNlZFNjZW5lKSB7XG4gICAgdGhpcy5fcmVtb3ZlU2NlbmVFdmVudExpc3RlbmVycyh0aGlzLl9yZXBsYWNlZFNjZW5lKTtcbiAgfVxuXG4gIHRoaXMuX2RyYWdDdXJzb3IuZGVzdHJveSgpO1xuXG4gIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gdGhpcy5fY29udHJvbE1ldGhvZHMpIHtcbiAgICB0aGlzLl9jb250cm9sTWV0aG9kc1ttZXRob2ROYW1lXS5kZXN0cm95KCk7XG4gIH1cblxuICB3aGlsZSAodGhpcy5fc2NlbmVzLmxlbmd0aCkge1xuICAgIHRoaXMuZGVzdHJveVNjZW5lKHRoaXMuX3NjZW5lc1swXSk7XG4gIH1cblxuICB0aGlzLl9kb21FbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3N0YWdlLmRvbUVsZW1lbnQoKSk7XG5cbiAgdGhpcy5fc3RhZ2UuZGVzdHJveSgpO1xuICB0aGlzLl9yZW5kZXJMb29wLmRlc3Ryb3koKTtcbiAgdGhpcy5fY29udHJvbHMuZGVzdHJveSgpO1xuICB0aGlzLl9jb250cm9scyA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX2NhbmNlbEN1cnJlbnRUd2Vlbikge1xuICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRUd2VlbigpO1xuICB9XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YWdlIHNpemUgdG8gZmlsbCB0aGUgY29udGFpbmluZyBlbGVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHJlc2l6ZWQuXG4gKiBNb3N0IGNsaWVudHMgd29uJ3QgbmVlZCB0byBleHBsaWNpdGx5IGNhbGwgaXQgdG8ga2VlcCB0aGUgc2l6ZSB1cCB0byBkYXRlLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgc2l6ZS53aWR0aCA9IHRoaXMuX2RvbUVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gdGhpcy5fZG9tRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHRoaXMuX3N0YWdlLnNldFNpemUoc2l6ZSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgU3RhZ2Ugc3RhZ2V9LlxuICogQHJldHVybiB7U3RhZ2V9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuc3RhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9zdGFnZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBSZW5kZXJMb29wIHJlbmRlciBsb29wfS5cbiAqIEByZXR1cm4ge1JlbmRlckxvb3B9XG4gKi9cblZpZXdlci5wcm90b3R5cGUucmVuZGVyTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlbmRlckxvb3A7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgQ29udHJvbHMgY29udHJvbHN9LlxuICogQHJldHVybiB7Q29udHJvbHN9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuY29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9jb250cm9scztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIERPTSBlbGVtZW50LlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5kb21FbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZG9tRWxlbWVudDtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBTY2VuZSBzY2VuZX0gd2l0aCBhIHNpbmdsZSBsYXllciBhbmQgYWRkcyBpdCB0byB0aGVcbiAqIHZpZXdlci5cbiAqXG4gKiBUaGUgY3VycmVudCBzY2VuZSBkb2VzIG5vdCBjaGFuZ2UuIFRvIHN3aXRjaCB0byB0aGUgc2NlbmUsIGNhbGxcbiAqIHtAbGluayBWaWV3ZXIjc3dpdGNoU2NlbmV9LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFNjZW5lIGNyZWF0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0ge1ZpZXd9IG9wdHMudmlldyBUaGUgc2NlbmUncyB1bmRlcmx5aW5nIHtAbGluayBWaWV3fS5cbiAqIEBwYXJhbSB7U291cmNlfSBvcHRzLnNvdXJjZSBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIHtAbGluayBTb3VyY2V9LlxuICogQHBhcmFtIHtHZW9tZXRyeX0gb3B0cy5nZW9tZXRyeSBUaGUgbGF5ZXIncyB1bmRlcmx5aW5nIHtAbGluayBHZW9tZXRyeX0uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnBpbkZpcnN0TGV2ZWw9ZmFsc2VdIFdoZXRoZXIgdG8gcGluIHRoZSBmaXJzdCBsZXZlbCB0b1xuICogICAgIHByb3ZpZGUgYSBmYWxsYmFjayBvZiBsYXN0IHJlc29ydCwgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5IGNvbnN1bXB0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnRleHR1cmVTdG9yZU9wdHM9e31dIE9wdGlvbnMgdG8gcGFzcyB0byB0aGVcbiAqICAgICB7QGxpbmsgVGV4dHVyZVN0b3JlfSBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5sYXllck9wdHM9e31dIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUge0BsaW5rIExheWVyfVxuICogICAgIGNvbnN0cnVjdG9yLlxuICogQHJldHVybiB7U2NlbmV9XG4gKi9cblZpZXdlci5wcm90b3R5cGUuY3JlYXRlU2NlbmUgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgc2NlbmUgPSB0aGlzLmNyZWF0ZUVtcHR5U2NlbmUoeyB2aWV3OiBvcHRzLnZpZXcgfSk7XG5cbiAgc2NlbmUuY3JlYXRlTGF5ZXIoe1xuICAgIHNvdXJjZTogb3B0cy5zb3VyY2UsXG4gICAgZ2VvbWV0cnk6IG9wdHMuZ2VvbWV0cnksXG4gICAgZGVwdGhtYXA6IG9wdHMuZGVwdGhtYXAsXG4gICAgcGluRmlyc3RMZXZlbDogb3B0cy5waW5GaXJzdExldmVsLFxuICAgIHRleHR1cmVTdG9yZU9wdHM6IG9wdHMudGV4dHVyZVN0b3JlT3B0cyxcbiAgICBsYXllck9wdHM6IG9wdHMubGF5ZXJPcHRzXG4gIH0pO1xuXG4gIHJldHVybiBzY2VuZTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBTY2VuZSBzY2VuZX0gd2l0aCBubyBsYXllcnMgYW5kIGFkZHMgaXQgdG8gdGhlIHZpZXdlci5cbiAqXG4gKiBMYXllcnMgbWF5IGJlIGFkZGVkIHRvIHRoZSBzY2VuZSBieSBjYWxsaW5nIHtAbGluayBTY2VuZSNjcmVhdGVMYXllcn0uXG4gKiBIb3dldmVyLCBpZiB0aGUgc2NlbmUgaGFzIGEgc2luZ2xlIGxheWVyLCBpdCBpcyBzaW1wbGVyIHRvIGNhbGxcbiAqIHtAbGluayBWaWV3ZXIjY3JlYXRlU2NlbmV9IGluc3RlYWQgb2YgdGhpcyBtZXRob2QuXG4gKlxuICogVGhlIGN1cnJlbnQgc2NlbmUgZG9lcyBub3QgY2hhbmdlLiBUbyBzd2l0Y2ggdG8gdGhlIHNjZW5lLCBjYWxsXG4gKiB7QGxpbmsgVmlld2VyI3N3aXRjaFNjZW5lfS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBTY2VuZSBjcmVhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIHtWaWV3fSBvcHRzLnZpZXcgVGhlIHNjZW5lJ3MgdW5kZXJseWluZyB7QGxpbmsgVmlld30uXG4gKiBAcmV0dXJuIHtTY2VuZX1cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5jcmVhdGVFbXB0eVNjZW5lID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHNjZW5lID0gbmV3IFNjZW5lKHRoaXMsIG9wdHMudmlldyk7XG4gIHRoaXMuX3NjZW5lcy5wdXNoKHNjZW5lKTtcblxuICByZXR1cm4gc2NlbmU7XG59O1xuXG5cblZpZXdlci5wcm90b3R5cGUuX3VwZGF0ZVNjZW5lTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgdmFyIGxheWVyO1xuXG4gIHZhciBzdGFnZSA9IHRoaXMuX3N0YWdlO1xuICB2YXIgY3VycmVudFNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICB2YXIgcmVwbGFjZWRTY2VuZSA9IHRoaXMuX3JlcGxhY2VkU2NlbmU7XG5cbiAgdmFyIG9sZExheWVycyA9IHN0YWdlLmxpc3RMYXllcnMoKTtcblxuICAvLyBUaGUgc3RhZ2UgY29udGFpbnMgbGF5ZXJzIGZyb20gYXQgbW9zdCB0d28gc2NlbmVzOiB0aGUgY3VycmVudCBvbmUsIG9uIHRvcCxcbiAgLy8gYW5kIHRoZSBvbmUgY3VycmVudGx5IGJlaW5nIHN3aXRjaGVkIGF3YXkgZnJvbSwgb24gdGhlIGJvdHRvbS5cbiAgdmFyIG5ld0xheWVycyA9IFtdO1xuICBpZiAocmVwbGFjZWRTY2VuZSkge1xuICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5jb25jYXQocmVwbGFjZWRTY2VuZS5saXN0TGF5ZXJzKCkpO1xuICB9XG4gIGlmIChjdXJyZW50U2NlbmUpIHtcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuY29uY2F0KGN1cnJlbnRTY2VuZS5saXN0TGF5ZXJzKCkpO1xuICB9XG5cbiAgLy8gQSBzaW5nbGUgbGF5ZXIgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgc2NlbmUgYXQgYSB0aW1lLlxuICBpZiAoTWF0aC5hYnMob2xkTGF5ZXJzLmxlbmd0aCAtIG5ld0xheWVycy5sZW5ndGgpICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBhbmQgc2NlbmUgb3V0IG9mIHN5bmMnKTtcbiAgfVxuXG4gIGlmIChuZXdMYXllcnMubGVuZ3RoIDwgb2xkTGF5ZXJzLmxlbmd0aCkge1xuICAgIC8vIEEgbGF5ZXIgd2FzIHJlbW92ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IG9sZExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGF5ZXIgPSBvbGRMYXllcnNbaV07XG4gICAgICBpZiAobmV3TGF5ZXJzLmluZGV4T2YobGF5ZXIpIDwgMCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVMYXllckZyb21TdGFnZShsYXllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3TGF5ZXJzLmxlbmd0aCA+IG9sZExheWVycy5sZW5ndGgpIHtcbiAgICAvLyBBIGxheWVyIHdhcyBhZGRlZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsYXllciA9IG5ld0xheWVyc1tpXTtcbiAgICAgIGlmIChvbGRMYXllcnMuaW5kZXhPZihsYXllcikgPCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZExheWVyVG9TdGFnZShsYXllciwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogV2hlbiBpbiB0aGUgbWlkZGxlIG9mIGEgc2NlbmUgdHJhbnNpdGlvbiwgY2FsbCB0aGUgdHJhbnNpdGlvbiB1cGRhdGVcbiAgLy8gZnVuY3Rpb24gaW1tZWRpYXRlbHkgdG8gcHJldmVudCBhbiBhZGRlZCBsYXllciBmcm9tIGZsYXNoaW5nIHdpdGggdGhlIHdyb25nXG4gIC8vIG9wYWNpdHkuXG59O1xuXG5cblZpZXdlci5wcm90b3R5cGUuX2FkZExheWVyVG9TdGFnZSA9IGZ1bmN0aW9uIChsYXllciwgaSkge1xuICAvLyBQaW4gdGhlIGZpcnN0IGxldmVsIHRvIGVuc3VyZSBhIGZhbGxiYWNrIHdoaWxlIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBgcGluRmlyc3RMZXZlbGAgb3B0aW9uIHBhc3NlZCB0b1xuICAvLyBjcmVhdGVTY2VuZSgpLCB3aGljaCBwaW5zIHRoZSBsYXllciBldmVuIHdoZW4gaXQncyBub3QgdmlzaWJsZS5cbiAgbGF5ZXIucGluRmlyc3RMZXZlbCgpO1xuICB0aGlzLl9zdGFnZS5hZGRMYXllcihsYXllciwgaSk7XG59O1xuXG5cblZpZXdlci5wcm90b3R5cGUuX3JlbW92ZUxheWVyRnJvbVN0YWdlID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIHRoaXMuX3N0YWdlLnJlbW92ZUxheWVyKGxheWVyKTtcbiAgbGF5ZXIudW5waW5GaXJzdExldmVsKCk7XG4gIGxheWVyLnRleHR1cmVTdG9yZSgpLmNsZWFyTm90UGlubmVkKCk7XG59O1xuXG5cblZpZXdlci5wcm90b3R5cGUuX2FkZFNjZW5lRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgc2NlbmUuYWRkRXZlbnRMaXN0ZW5lcignbGF5ZXJDaGFuZ2UnLCB0aGlzLl9sYXllckNoYW5nZUhhbmRsZXIpO1xuICBzY2VuZS5hZGRFdmVudExpc3RlbmVyKCd2aWV3Q2hhbmdlJywgdGhpcy5fdmlld0NoYW5nZUhhbmRsZXIpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9yZW1vdmVTY2VuZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKHNjZW5lKSB7XG4gIHNjZW5lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xheWVyQ2hhbmdlJywgdGhpcy5fbGF5ZXJDaGFuZ2VIYW5kbGVyKTtcbiAgc2NlbmUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX3ZpZXdDaGFuZ2VIYW5kbGVyKTtcbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyBhIHtAbGluayBTY2VuZSBzY2VuZX0gYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgdmlld2VyLlxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAqL1xuVmlld2VyLnByb3RvdHlwZS5kZXN0cm95U2NlbmUgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgdmFyIGkgPSB0aGlzLl9zY2VuZXMuaW5kZXhPZihzY2VuZSk7XG4gIGlmIChpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBzY2VuZSBpbiB2aWV3ZXInKTtcbiAgfVxuXG4gIHZhciBqO1xuICB2YXIgbGF5ZXJzO1xuXG4gIGlmICh0aGlzLl9jdXJyZW50U2NlbmUgPT09IHNjZW5lKSB7XG4gICAgLy8gVGhlIGRlc3Ryb3llZCBzY2VuZSBpcyB0aGUgY3VycmVudCBzY2VuZS5cbiAgICAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLCByZW1vdmUgbGF5ZXJzIGZyb20gc3RhZ2UgYW5kIGNhbmNlbCB0cmFuc2l0aW9uLlxuICAgIHRoaXMuX3JlbW92ZVNjZW5lRXZlbnRMaXN0ZW5lcnMoc2NlbmUpO1xuICAgIGxheWVycyA9IHNjZW5lLmxpc3RMYXllcnMoKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbGF5ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICB0aGlzLl9yZW1vdmVMYXllckZyb21TdGFnZShsYXllcnNbal0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FuY2VsQ3VycmVudFR3ZWVuKSB7XG4gICAgICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4oKTtcbiAgICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRUd2VlbiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRTY2VuZSA9IG51bGw7XG4gICAgdGhpcy5lbWl0KCdzY2VuZUNoYW5nZScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3JlcGxhY2VkU2NlbmUgPT09IHNjZW5lKSB7XG4gICAgLy8gVGhlIGRlc3Ryb3llZCBzY2VuZSBpcyBiZWluZyBzd2l0Y2hlZCBhd2F5IGZyb20uXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVtb3ZlIGxheWVycyBmcm9tIHN0YWdlLlxuICAgIHRoaXMuX3JlbW92ZVNjZW5lRXZlbnRMaXN0ZW5lcnMoc2NlbmUpO1xuICAgIGxheWVycyA9IHNjZW5lLmxpc3RMYXllcnMoKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbGF5ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICB0aGlzLl9yZW1vdmVMYXllckZyb21TdGFnZShsYXllcnNbal0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXBsYWNlZFNjZW5lID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuX3NjZW5lcy5zcGxpY2UoaSwgMSk7XG5cbiAgc2NlbmUuZGVzdHJveSgpO1xufTtcblxuXG4vKipcbiAqIERlc3Ryb3lzIGFsbCB7QGxpbmsgU2NlbmUgc2NlbmVzfSBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIHZpZXdlci5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5kZXN0cm95QWxsU2NlbmVzID0gZnVuY3Rpb24gKCkge1xuICB3aGlsZSAodGhpcy5fc2NlbmVzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmRlc3Ryb3lTY2VuZSh0aGlzLl9zY2VuZXNbMF0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB2aWV3ZXIgY29udGFpbnMgYSB7QGxpbmsgU2NlbmUgc2NlbmV9LlxuICogQHBhcmFtIHtTY2VuZX0gc2NlbmVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblZpZXdlci5wcm90b3R5cGUuaGFzU2NlbmUgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgcmV0dXJuIHRoaXMuX3NjZW5lcy5pbmRleE9mKHNjZW5lKSA+PSAwO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB7QGxpbmsgU2NlbmUgc2NlbmVzfS5cbiAqIEByZXR1cm4ge1NjZW5lW119XG4gKi9cblZpZXdlci5wcm90b3R5cGUubGlzdFNjZW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLl9zY2VuZXMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQge0BsaW5rIFNjZW5lIHNjZW5lfSwgb3IgbnVsbCBpZiB0aGVyZSBpc24ndCBvbmUuXG4gKlxuICogVG8gY2hhbmdlIHRoZSBjdXJyZW50IHNjZW5lLCBjYWxsIHtAbGluayBWaWV3ZXIjc3dpdGNoU2NlbmV9LlxuICpcbiAqIEByZXR1cm4ge1NjZW5lfVxuICovXG5WaWV3ZXIucHJvdG90eXBlLnNjZW5lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fY3VycmVudFNjZW5lO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHtAbGluayBWaWV3IHZpZXd9IGZvciB0aGUgY3VycmVudCB7QGxpbmsgU2NlbmUgc2NlbmV9LCBvciBudWxsXG4gKiBpZiB0aGVyZSBpc24ndCBvbmUuXG4gKiBAcmV0dXJuIHtWaWV3fVxuICovXG5WaWV3ZXIucHJvdG90eXBlLnZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKHNjZW5lKSB7XG4gICAgcmV0dXJuIHNjZW5lLnZpZXcoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBUd2VlbnMgdGhlIHtAbGluayBWaWV3IHZpZXd9IGZvciB0aGUgY3VycmVudCB7QGxpbmsgU2NlbmUgc2NlbmV9LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgU2NlbmUjbG9va1RvfSBvbiB0aGUgY3VycmVudFxuICogc2NlbmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9ucyB0byBwYXNzIGludG8ge0BsaW5rIFNjZW5lI2xvb2tUb30uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdHdlZW4gaXMgY29tcGxldGUuXG4gKi9cblZpZXdlci5wcm90b3R5cGUubG9va1RvID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0cywgZG9uZSkge1xuICAvLyBUT0RPOiBpcyBpdCBhbiBlcnJvciB0byBjYWxsIGxvb2tUbyB3aGVuIG5vIHNjZW5lIGlzIGRpc3BsYXllZD9cbiAgdmFyIHNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICBpZiAoc2NlbmUpIHtcbiAgICBzY2VuZS5sb29rVG8ocGFyYW1zLCBvcHRzLCBkb25lKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFN0YXJ0cyBhIG1vdmVtZW50LCBwb3NzaWJseSByZXBsYWNpbmcgdGhlIGN1cnJlbnQgbW92ZW1lbnQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIHtAbGluayBTY2VuZSNzdGFydE1vdmVtZW50fSBvbiB0aGVcbiAqIGN1cnJlbnQgc2NlbmUuIElmIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2NlbmUsIHRoaXMgaXMgYSBuby1vcC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgbW92ZW1lbnQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBtb3ZlbWVudCBmaW5pc2hlcyBvciBpc1xuICogICAgIGludGVycnVwdGVkLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLnN0YXJ0TW92ZW1lbnQgPSBmdW5jdGlvbiAoZm4sIGRvbmUpIHtcbiAgdmFyIHNjZW5lID0gdGhpcy5fY3VycmVudFNjZW5lO1xuICBpZiAoIXNjZW5lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNjZW5lLnN0YXJ0TW92ZW1lbnQoZm4sIGRvbmUpO1xufTtcblxuXG4vKipcbiAqIFN0b3BzIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgU2NlbmUjc3RvcE1vdmVtZW50fSBvbiB0aGVcbiAqIGN1cnJlbnQgc2NlbmUuIElmIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2NlbmUsIHRoaXMgaXMgYSBuby1vcC5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zdG9wTW92ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzY2VuZSA9IHRoaXMuX2N1cnJlbnRTY2VuZTtcbiAgaWYgKCFzY2VuZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzY2VuZS5zdG9wTW92ZW1lbnQoKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1vdmVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgU2NlbmUjbW92ZW1lbnR9IG9uIHRoZVxuICogY3VycmVudCBzY2VuZS4gSWYgdGhlcmUgaXMgbm8gY3VycmVudCBzY2VuZSwgdGhpcyBpcyBhIG5vLW9wLlxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5WaWV3ZXIucHJvdG90eXBlLm1vdmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2NlbmUgPSB0aGlzLl9jdXJyZW50U2NlbmU7XG4gIGlmICghc2NlbmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHNjZW5lLm1vdmVtZW50KCk7XG59O1xuXG5cbi8qKlxuICogU2NoZWR1bGVzIGFuIGlkbGUgbW92ZW1lbnQgdG8gYmUgYXV0b21hdGljYWxseSBzdGFydGVkIHdoZW4gdGhlIHZpZXcgcmVtYWluc1xuICogdW5jaGFuZ2VkIGZvciB0aGUgZ2l2ZW4gdGltZW91dCBwZXJpb2QuXG4gKlxuICogQ2hhbmdpbmcgdGhlIHZpZXcgd2hpbGUgdGhlIGlkbGUgbW92ZW1lbnQgaXMgYWN0aXZlIHN0b3BzIHRoZSBtb3ZlbWVudCBhbmRcbiAqIHNjaGVkdWxlcyBpdCB0byBzdGFydCBhZ2FpbiBhZnRlciB0aGUgc2FtZSB0aW1lb3V0IHBlcmlvZC4gVG8gZGlzYWJsZSBpdFxuICogcGVybWFuZW50bHksIGNhbGwgd2l0aCBhIG51bGwgbW92ZW1lbnQgb3IgYW4gaW5maW5pdGUgdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBUaW1lb3V0IHBlcmlvZCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb3ZlbWVudCBBdXRvbWF0aWMgbW92ZW1lbnQgZnVuY3Rpb24sIG9yIG51bGwgdG8gZGlzYWJsZS5cbiAqL1xuVmlld2VyLnByb3RvdHlwZS5zZXRJZGxlTW92ZW1lbnQgPSBmdW5jdGlvbiAodGltZW91dCwgbW92ZW1lbnQpIHtcbiAgdGhpcy5faWRsZVRpbWVyLnNldER1cmF0aW9uKHRpbWVvdXQpO1xuICB0aGlzLl9pZGxlTW92ZW1lbnQgPSBtb3ZlbWVudDtcbn07XG5cblxuLyoqXG4gKiBTdG9wcyB0aGUgaWRsZSBtb3ZlbWVudC4gSXQgd2lsbCBiZSBzdGFydGVkIGFnYWluIGFmdGVyIHRoZSB0aW1lb3V0IHNldCBieVxuICoge0BsaW5rIFZpZXdlciNzZXRJZGxlTW92ZW1lbnR9LlxuICovXG5WaWV3ZXIucHJvdG90eXBlLmJyZWFrSWRsZU1vdmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0b3BNb3ZlbWVudCgpO1xuICB0aGlzLl9yZXNldElkbGVUaW1lcigpO1xufTtcblxuXG5WaWV3ZXIucHJvdG90eXBlLl9yZXNldElkbGVUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faWRsZVRpbWVyLnN0YXJ0KCk7XG59O1xuXG5cblZpZXdlci5wcm90b3R5cGUuX3RyaWdnZXJJZGxlVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZGxlTW92ZW1lbnQgPSB0aGlzLl9pZGxlTW92ZW1lbnQ7XG4gIGlmICghaWRsZU1vdmVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuc3RhcnRNb3ZlbWVudChpZGxlTW92ZW1lbnQpO1xufTtcblxuXG52YXIgZGVmYXVsdFN3aXRjaER1cmF0aW9uID0gMTAwMDtcblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zaXRpb25VcGRhdGUodmFsLCBuZXdTY2VuZSwgb2xkU2NlbmUpIHtcbiAgdmFyIGxheWVycyA9IG5ld1NjZW5lLmxpc3RMYXllcnMoKTtcbiAgbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIubWVyZ2VFZmZlY3RzKHsgb3BhY2l0eTogdmFsIH0pO1xuICB9KTtcblxuICBuZXdTY2VuZS5faG90c3BvdENvbnRhaW5lci5kb21FbGVtZW50KCkuc3R5bGUub3BhY2l0eSA9IHZhbDtcbn1cblxuXG4vKipcbiAqIFN3aXRjaGVzIHRvIGFub3RoZXIge0BsaW5rIFNjZW5lIHNjZW5lfSB3aXRoIGEgZmFkZSB0cmFuc2l0aW9uLiBUaGlzIHNjZW5lXG4gKiBiZWNvbWVzIHRoZSBjdXJyZW50IG9uZS5cbiAqXG4gKiBJZiBhIHRyYW5zaXRpb24gaXMgYWxyZWFkeSB0YWtpbmcgcGxhY2UsIGl0IGlzIGludGVycnVwdGVkIGJlZm9yZSB0aGUgbmV3IG9uZVxuICogc3RhcnRzLlxuICpcbiAqIEBwYXJhbSB7U2NlbmV9IG5ld1NjZW5lIFRoZSBzY2VuZSB0byBzd2l0Y2ggdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUcmFuc2l0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMudHJhbnNpdGlvbkR1cmF0aW9uPTEwMDBdIFRyYW5zaXRpb24gZHVyYXRpb24sIGluXG4gKiAgICAgbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRyYW5zaXRpb25VcGRhdGU9ZGVmYXVsdFRyYW5zaXRpb25VcGRhdGVdXG4gKiAgICAgVHJhbnNpdGlvbiB1cGRhdGUgZnVuY3Rpb24sIHdpdGggc2lnbmF0dXJlIGBmKHQsIG5ld1NjZW5lLCBvbGRTY2VuZSlgLlxuICogICAgIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGVhY2ggZnJhbWUgd2l0aCBgdGAgaW5jcmVhc2luZyBmcm9tIDAgdG8gMS5cbiAqICAgICBBbiBpbml0aWFsIGNhbGwgd2l0aCBgdD0wYCBhbmQgYSBmaW5hbCBjYWxsIHdpdGggYHQ9MWAgYXJlIGd1YXJhbnRlZWQuXG4gKiAgICAgVGhlIGRlZmF1bHQgZnVuY3Rpb24gc2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbmV3IHNjZW5lIHRvIGB0YC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzIG9yIGlzXG4gKiAgICAgaW50ZXJydXB0ZWQuIElmIHRoZSBuZXcgc2NlbmUgaXMgZXF1YWwgdG8gdGhlIG9sZCBvbmUsIG5vIHRyYW5zaXRpb25cbiAqICAgICB0YWtlcyBwbGFjZSwgYnV0IHRoaXMgZnVuY3Rpb24gaXMgc3RpbGwgY2FsbGVkLlxuICovXG5WaWV3ZXIucHJvdG90eXBlLnN3aXRjaFNjZW5lID0gZnVuY3Rpb24gKG5ld1NjZW5lLCBvcHRzLCBkb25lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgZG9uZSA9IGRvbmUgfHwgbm9vcDtcblxuICB2YXIgc3RhZ2UgPSB0aGlzLl9zdGFnZTtcblxuICB2YXIgb2xkU2NlbmUgPSB0aGlzLl9jdXJyZW50U2NlbmU7XG5cbiAgLy8gRG8gbm90aGluZyBpZiB0aGUgdGFyZ2V0IHNjZW5lIGlzIHRoZSBjdXJyZW50IG9uZS5cbiAgaWYgKG9sZFNjZW5lID09PSBuZXdTY2VuZSkge1xuICAgIGRvbmUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fc2NlbmVzLmluZGV4T2YobmV3U2NlbmUpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBzY2VuZSBpbiB2aWV3ZXInKTtcbiAgfVxuXG4gIC8vIENhbmNlbCBhbiBhbHJlYWR5IG9uZ29pbmcgdHJhbnNpdGlvbi4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHN0YWdlIGNvbnRhaW5zXG4gIC8vIGxheWVycyBmcm9tIGV4YWN0bHkgb25lIHNjZW5lIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBiZWdpbnMuXG4gIGlmICh0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4pIHtcbiAgICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4oKTtcbiAgICB0aGlzLl9jYW5jZWxDdXJyZW50VHdlZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIG9sZFNjZW5lTGF5ZXJzID0gb2xkU2NlbmUgPyBvbGRTY2VuZS5saXN0TGF5ZXJzKCkgOiBbXTtcbiAgdmFyIG5ld1NjZW5lTGF5ZXJzID0gbmV3U2NlbmUubGlzdExheWVycygpO1xuICB2YXIgc3RhZ2VMYXllcnMgPSBzdGFnZS5saXN0TGF5ZXJzKCk7XG5cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgc3RhZ2UgY29udGFpbnMgZXhhY3RseSBhcyBtYW55IGxheWVycyBhcyB0aGUgY3VycmVudCBzY2VuZSxcbiAgLy8gYW5kIHRoYXQgdGhlIHRvcCBsYXllciBpcyB0aGUgcmlnaHQgb25lLiBJZiB0aGlzIHRlc3QgZmFpbHMsIGVpdGhlciB0aGVyZVxuICAvLyBpcyBhIGJ1ZyBvciB0aGUgdXNlciB0cmllZCB0byBtb2RpZnkgdGhlIHN0YWdlIGNvbmN1cnJlbnRseS5cbiAgaWYgKG9sZFNjZW5lICYmICgoc3RhZ2VMYXllcnMubGVuZ3RoICE9PSBvbGRTY2VuZUxheWVycy5sZW5ndGgpIHx8XG4gICAgKHN0YWdlTGF5ZXJzLmxlbmd0aCA+IDEgJiYgc3RhZ2VMYXllcnNbMF0gIT0gb2xkU2NlbmVMYXllcnNbMF0pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RhZ2Ugbm90IGluIHN5bmMgd2l0aCB2aWV3ZXInKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgdHJhbnNpdGlvbiBwYXJhbWV0ZXJzLlxuICB2YXIgZHVyYXRpb24gPSBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiAhPSBudWxsID9cbiAgICBvcHRzLnRyYW5zaXRpb25EdXJhdGlvbiA6IGRlZmF1bHRTd2l0Y2hEdXJhdGlvbjtcbiAgdmFyIHVwZGF0ZSA9IG9wdHMudHJhbnNpdGlvblVwZGF0ZSAhPSBudWxsID9cbiAgICBvcHRzLnRyYW5zaXRpb25VcGRhdGUgOiBkZWZhdWx0VHJhbnNpdGlvblVwZGF0ZTtcblxuICAvLyBBZGQgbmV3IHNjZW5lIGxheWVycyBpbnRvIHRoZSBzdGFnZSBiZWZvcmUgc3RhcnRpbmcgdGhlIHRyYW5zaXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2NlbmVMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9hZGRMYXllclRvU3RhZ2UobmV3U2NlbmVMYXllcnNbaV0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBmcmFtZS5cbiAgZnVuY3Rpb24gdHdlZW5VcGRhdGUodmFsKSB7XG4gICAgdXBkYXRlKHZhbCwgbmV3U2NlbmUsIG9sZFNjZW5lKTtcbiAgfVxuXG4gIC8vIE9uY2UgdGhlIHRyYW5zaXRpb24gaXMgY29tcGxldGUsIHJlbW92ZSBvbGQgc2NlbmUgbGF5ZXJzIGZyb20gdGhlIHN0YWdlIGFuZFxuICAvLyByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVycy4gSWYgdGhlIG9sZCBzY2VuZSB3YXMgZGVzdHJveWVkIGR1cmluZyB0aGVcbiAgLy8gdHJhbnNpdGlvbiwgdGhpcyBoYXMgYWxyZWFkeSBiZWVuIHRha2VuIGNhcmUgb2YuIE90aGVyd2lzZSwgd2Ugc3RpbGwgbmVlZFxuICAvLyB0byBnZXQgYSBmcmVzaCBjb3B5IG9mIHRoZSBzY2VuZSdzIGxheWVycywgc2luY2UgdGhleSBtaWdodCBoYXZlIGNoYW5nZWRcbiAgLy8gZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuICBmdW5jdGlvbiB0d2VlbkRvbmUoKSB7XG4gICAgaWYgKHNlbGYuX3JlcGxhY2VkU2NlbmUpIHtcbiAgICAgIHNlbGYuX3JlbW92ZVNjZW5lRXZlbnRMaXN0ZW5lcnMoc2VsZi5fcmVwbGFjZWRTY2VuZSk7XG4gICAgICBvbGRTY2VuZUxheWVycyA9IHNlbGYuX3JlcGxhY2VkU2NlbmUubGlzdExheWVycygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRTY2VuZUxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLl9yZW1vdmVMYXllckZyb21TdGFnZShvbGRTY2VuZUxheWVyc1tpXSk7XG4gICAgICB9XG4gICAgICBzZWxmLl9yZXBsYWNlZFNjZW5lID0gbnVsbDtcbiAgICB9XG4gICAgc2VsZi5fY2FuY2VsQ3VycmVudFR3ZWVuID0gbnVsbDtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvLyBTdG9yZSB0aGUgY2FuY2VsYWJsZSBmb3IgdGhlIHRyYW5zaXRpb24uXG4gIHRoaXMuX2NhbmNlbEN1cnJlbnRUd2VlbiA9IHR3ZWVuKGR1cmF0aW9uLCB0d2VlblVwZGF0ZSwgdHdlZW5Eb25lKTtcblxuICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgYW5kIHJlcGxhY2VkIHNjZW5lLlxuICB0aGlzLl9jdXJyZW50U2NlbmUgPSBuZXdTY2VuZTtcbiAgdGhpcy5fcmVwbGFjZWRTY2VuZSA9IG9sZFNjZW5lO1xuXG4gIC8vIEVtaXQgc2NlbmUgYW5kIHZpZXcgY2hhbmdlIGV2ZW50cy5cbiAgdGhpcy5lbWl0KCdzY2VuZUNoYW5nZScpO1xuICB0aGlzLmVtaXQoJ3ZpZXdDaGFuZ2UnKTtcblxuICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBuZXcgc2NlbmUuXG4gIC8vIE5vdGUgdGhhdCBldmVudCBsaXN0ZW5lcnMgY2FuIG9ubHkgYmUgcmVtb3ZlZCBmcm9tIHRoZSBvbGQgc2NlbmUgb25jZSB0aGVcbiAgLy8gdHJhbnNpdGlvbiBpcyBjb21wbGV0ZSwgc2luY2UgbGF5ZXJzIG1pZ2h0IGdldCBhZGRlZCBvciByZW1vdmVkIGluIHRoZVxuICAvLyBpbnRlcmltLlxuICB0aGlzLl9hZGRTY2VuZUV2ZW50TGlzdGVuZXJzKG5ld1NjZW5lKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3ZXI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTdGF0aWNBc3NldCA9IHJlcXVpcmUoJy4vU3RhdGljJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgRHluYW1pY0Fzc2V0XG4gKiBAaW1wbGVtZW50cyBBc3NldFxuICogQGV4dGVuZHMgU3RhdGljQXNzZXRcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBbiB7QGxpbmsgQXNzZXR9IHdob3NlIHBpeGVsIGNvbnRlbnRzIG1heSBjaGFuZ2UuXG4gKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEltYWdlQml0bWFwfSBlbGVtZW50IFRoZVxuICogICAgIHVuZGVybHlpbmcgcGl4ZWwgc291cmNlLlxuICogQHRocm93cyBJZiB0aGUgcGl4ZWwgc291cmNlIGlzIHVuc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBEeW5hbWljQXNzZXQoZWxlbWVudCkge1xuICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICB0aGlzLl90aW1lc3RhbXAgPSAwO1xufVxuXG5pbmhlcml0cyhEeW5hbWljQXNzZXQsIFN0YXRpY0Fzc2V0KTtcbmV2ZW50RW1pdHRlcihEeW5hbWljQXNzZXQpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkR5bmFtaWNBc3NldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5EeW5hbWljQXNzZXQucHJvdG90eXBlLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGltZXN0YW1wO1xufTtcblxuRHluYW1pY0Fzc2V0LnByb3RvdHlwZS5pc0R5bmFtaWMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIE1hcmtzIHRoZSBhc3NldCBkaXJ0eSwgc2lnbmFsaW5nIHRoYXQgdGhlIGNvbnRlbnRzIG9mIHRoZSB1bmRlcmx5aW5nIHBpeGVsXG4gKiBzb3VyY2UgaGF2ZSBjaGFuZ2VkLlxuICpcbiAqIEB0aHJvd3MgSWYgdGhlIGFzc2V0IGlzIG5vdCBkeW5hbWljLlxuICovXG5EeW5hbWljQXNzZXQucHJvdG90eXBlLm1hcmtEaXJ0eSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90aW1lc3RhbXArKztcbiAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRHluYW1pY0Fzc2V0O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vdXRpbC9nbG9iYWwnKTtcbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgcHJvcGVydHlNYXAgPSB7XG4gIEhUTUxJbWFnZUVsZW1lbnQ6IFsnbmF0dXJhbFdpZHRoJywgJ25hdHVyYWxIZWlnaHQnXSxcbiAgSFRNTENhbnZhc0VsZW1lbnQ6IFsnd2lkdGgnLCAnaGVpZ2h0J10sXG4gIEltYWdlQml0bWFwOiBbJ3dpZHRoJywgJ2hlaWdodCddXG59O1xuXG4vKipcbiAqIEBjbGFzcyBTdGF0aWNBc3NldFxuICogQGltcGxlbWVudHMgQXNzZXRcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBbiB7QGxpbmsgQXNzZXR9IHdob3NlIHBpeGVsIGNvbnRlbnRzIG5ldmVyIGNoYW5nZS5cbiAqXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SW1hZ2VCaXRtYXB9IGVsZW1lbnQgVGhlXG4gKiAgICAgdW5kZXJseWluZyBwaXhlbCBzb3VyY2UuXG4gKiBAdGhyb3dzIElmIHRoZSBwaXhlbCBzb3VyY2UgaXMgdW5zdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIFN0YXRpY0Fzc2V0KGVsZW1lbnQpIHtcbiAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xuICBmb3IgKHZhciB0eXBlIGluIHByb3BlcnR5TWFwKSB7XG4gICAgaWYgKGdsb2JhbFt0eXBlXSAmJiBlbGVtZW50IGluc3RhbmNlb2YgZ2xvYmFsW3R5cGVdKSB7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fd2lkdGhQcm9wID0gcHJvcGVydHlNYXBbdHlwZV1bMF07XG4gICAgICB0aGlzLl9oZWlnaHRQcm9wID0gcHJvcGVydHlNYXBbdHlwZV1bMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBpeGVsIHNvdXJjZScpO1xuICB9XG5cbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG59XG5cbmV2ZW50RW1pdHRlcihTdGF0aWNBc3NldCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuU3RhdGljQXNzZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuU3RhdGljQXNzZXQucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG59O1xuXG5TdGF0aWNBc3NldC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsZW1lbnRbdGhpcy5fd2lkdGhQcm9wXTtcbn07XG5cblN0YXRpY0Fzc2V0LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsZW1lbnRbdGhpcy5faGVpZ2h0UHJvcF07XG59O1xuXG5TdGF0aWNBc3NldC5wcm90b3R5cGUudGltZXN0YW1wID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxuU3RhdGljQXNzZXQucHJvdG90eXBlLmlzRHluYW1pYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRpY0Fzc2V0O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL3V0aWwvZGVmYXVsdHMnKTtcblxudmFyIGRlZmF1bHRTcGVlZCA9IDAuMTtcbnZhciBkZWZhdWx0QWNjZWwgPSAwLjAxO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHlhd1NwZWVkOiBkZWZhdWx0U3BlZWQsXG4gIHBpdGNoU3BlZWQ6IGRlZmF1bHRTcGVlZCxcbiAgZm92U3BlZWQ6IGRlZmF1bHRTcGVlZCxcbiAgeWF3QWNjZWw6IGRlZmF1bHRBY2NlbCxcbiAgcGl0Y2hBY2NlbDogZGVmYXVsdEFjY2VsLFxuICBmb3ZBY2NlbDogZGVmYXVsdEFjY2VsLFxuICB0YXJnZXRQaXRjaDogMCxcbiAgdGFyZ2V0Rm92OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMueWF3U3BlZWQ9MC4xXSBZYXcgbWF4aW11bSBzcGVlZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnBpdGNoU3BlZWQ9MC4xXSBQaXRjaCBtYXhpbXVtIHNwZWVkXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdHMuZm92U3BlZWQ9MC4xXSBGb3YgbWF4aW11bSBzcGVlZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLnlhd0FjY2VsPTAuMDFdIFlhdyBhY2NlbGVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5waXRjaEFjY2VsPTAuMDFdIFBpdGNoIGFjY2VsZXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLmZvdkFjY2VsPTAuMDFdIEZvdiBhY2NlbGVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy50YXJnZXRQaXRjaD0wXSBWYWx1ZSB0aGF0IHBpdGNoIGNvbnZlcmdlcyB0by4gYG51bGxgIG1lYW5zIHRoYXQgdGhlIHBpdGNoIHdpbGwgbm90IGNoYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy50YXJnZXRGb3Y9bnVsbF0gVmFsdWUgdGhhdCBmb3YgY29udmVyZ2VzIHRvLiBgbnVsbGAgbWVhbnMgdGhhdCB0aGUgZm92IHdpbGwgbm90IGNoYW5nZS5cbiAqIEByZXR1cm5zIE1vdmVtZW50IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgVmlld2VyI3NldElkbGVNb3ZlbWVudH0gb3Ige0BsaW5rIFNjZW5lI3N0YXJ0TW92ZW1lbnR9XG4qL1xuZnVuY3Rpb24gYXV0b3JvdGF0ZShvcHRzKSB7XG5cbiAgb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRpb25zKTtcblxuICB2YXIgeWF3U3BlZWQgPSBvcHRzLnlhd1NwZWVkO1xuICB2YXIgcGl0Y2hTcGVlZCA9IG9wdHMucGl0Y2hTcGVlZDtcbiAgdmFyIGZvdlNwZWVkID0gb3B0cy5mb3ZTcGVlZDtcbiAgdmFyIHlhd0FjY2VsID0gb3B0cy55YXdBY2NlbDtcbiAgdmFyIHBpdGNoQWNjZWwgPSBvcHRzLnBpdGNoQWNjZWw7XG4gIHZhciBmb3ZBY2NlbCA9IG9wdHMuZm92QWNjZWw7XG4gIHZhciB0YXJnZXRQaXRjaCA9IG9wdHMudGFyZ2V0UGl0Y2g7XG4gIHZhciB0YXJnZXRGb3YgPSBvcHRzLnRhcmdldEZvdjtcblxuICByZXR1cm4gZnVuY3Rpb24gc3RhcnQoKSB7XG5cbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHZhciBsYXN0WWF3U3BlZWQgPSAwO1xuICAgIHZhciBsYXN0UGl0Y2hTcGVlZCA9IDA7XG4gICAgdmFyIGxhc3RGb3ZTcGVlZCA9IDA7XG5cbiAgICB2YXIgY3VycmVudFlhd1NwZWVkID0gMDtcbiAgICB2YXIgY3VycmVudFBpdGNoU3BlZWQgPSAwO1xuICAgIHZhciBjdXJyZW50Rm92U3BlZWQgPSAwO1xuXG4gICAgdmFyIHRpbWVEZWx0YTtcbiAgICB2YXIgeWF3RGVsdGE7XG4gICAgdmFyIHBpdGNoRGVsdGE7XG4gICAgdmFyIGZvdkRlbHRhO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHN0ZXAocGFyYW1zLCBjdXJyZW50VGltZSkge1xuXG4gICAgICB0aW1lRGVsdGEgPSAoY3VycmVudFRpbWUgLSBsYXN0VGltZSkgLyAxMDAwO1xuICAgICAgY3VycmVudFlhd1NwZWVkID0gTWF0aC5taW4obGFzdFlhd1NwZWVkICsgdGltZURlbHRhICogeWF3QWNjZWwsIHlhd1NwZWVkKTtcbiAgICAgIHlhd0RlbHRhID0gY3VycmVudFlhd1NwZWVkICogdGltZURlbHRhO1xuICAgICAgcGFyYW1zLnlhdyA9IHBhcmFtcy55YXcgKyB5YXdEZWx0YTtcblxuICAgICAgaWYgKHRhcmdldFBpdGNoICE9IG51bGwgJiYgcGFyYW1zLnBpdGNoICE9PSB0YXJnZXRQaXRjaCkge1xuICAgICAgICB2YXIgcGl0Y2hUaHJlc2ggPSAwLjUgKiBsYXN0UGl0Y2hTcGVlZCAqIGxhc3RQaXRjaFNwZWVkIC8gcGl0Y2hBY2NlbDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRhcmdldFBpdGNoIC0gcGFyYW1zLnBpdGNoKSA+IHBpdGNoVGhyZXNoKSB7XG4gICAgICAgICAgLy8gQWNjZWxlcmF0aW9uIHBoYXNlXG4gICAgICAgICAgY3VycmVudFBpdGNoU3BlZWQgPSBNYXRoLm1pbihsYXN0UGl0Y2hTcGVlZCArIHRpbWVEZWx0YSAqIHBpdGNoQWNjZWwsIHBpdGNoU3BlZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERlY2VsZXJhdGlvbiBwaGFzZVxuICAgICAgICAgIGN1cnJlbnRQaXRjaFNwZWVkID0gTWF0aC5tYXgobGFzdFBpdGNoU3BlZWQgLSB0aW1lRGVsdGEgKiBwaXRjaEFjY2VsLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdXJyZW50UGl0Y2hTcGVlZCBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgKD49IDApXG4gICAgICAgIHBpdGNoRGVsdGEgPSBjdXJyZW50UGl0Y2hTcGVlZCAqIHRpbWVEZWx0YTtcbiAgICAgICAgaWYgKHRhcmdldFBpdGNoIDwgcGFyYW1zLnBpdGNoKSB7XG4gICAgICAgICAgcGFyYW1zLnBpdGNoID0gTWF0aC5tYXgodGFyZ2V0UGl0Y2gsIHBhcmFtcy5waXRjaCAtIHBpdGNoRGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRQaXRjaCA+IHBhcmFtcy5waXRjaCkge1xuICAgICAgICAgIHBhcmFtcy5waXRjaCA9IE1hdGgubWluKHRhcmdldFBpdGNoLCBwYXJhbXMucGl0Y2ggKyBwaXRjaERlbHRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0Rm92ICE9IG51bGwgJiYgcGFyYW1zLmZvdiAhPT0gdGFyZ2V0UGl0Y2gpIHtcbiAgICAgICAgdmFyIGZvdlRocmVzaCA9IDAuNSAqIGxhc3RGb3ZTcGVlZCAqIGxhc3RGb3ZTcGVlZCAvIGZvdkFjY2VsO1xuICAgICAgICBpZiAoTWF0aC5hYnModGFyZ2V0Rm92IC0gcGFyYW1zLmZvdikgPiBmb3ZUaHJlc2gpIHtcbiAgICAgICAgICAvLyBBY2NlbGVyYXRpb24gcGhhc2VcbiAgICAgICAgICBjdXJyZW50Rm92U3BlZWQgPSBNYXRoLm1pbihsYXN0Rm92U3BlZWQgKyB0aW1lRGVsdGEgKiBmb3ZBY2NlbCwgZm92U3BlZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERlY2VsZXJhdGlvbiBwaGFzZVxuICAgICAgICAgIGN1cnJlbnRGb3ZTcGVlZCA9IE1hdGgubWF4KGxhc3RGb3ZTcGVlZCAtIHRpbWVEZWx0YSAqIGZvdkFjY2VsLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdXJyZW50Rm92U3BlZWQgaXMgdGhlIGFic29sdXRlIHZhbHVlICg+PSAwKVxuICAgICAgICBmb3ZEZWx0YSA9IGN1cnJlbnRGb3ZTcGVlZCAqIHRpbWVEZWx0YTtcbiAgICAgICAgaWYgKHRhcmdldEZvdiA8IHBhcmFtcy5mb3YpIHtcbiAgICAgICAgICBwYXJhbXMuZm92ID0gTWF0aC5tYXgodGFyZ2V0Rm92LCBwYXJhbXMuZm92IC0gZm92RGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRGb3YgPiBwYXJhbXMuZm92KSB7XG4gICAgICAgICAgcGFyYW1zLmZvdiA9IE1hdGgubWluKHRhcmdldEZvdiwgcGFyYW1zLmZvdiArIGZvdkRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgbGFzdFlhd1NwZWVkID0gY3VycmVudFlhd1NwZWVkO1xuICAgICAgbGFzdFBpdGNoU3BlZWQgPSBjdXJyZW50UGl0Y2hTcGVlZDtcbiAgICAgIGxhc3RGb3ZTcGVlZCA9IGN1cnJlbnRGb3ZTcGVlZDtcblxuICAgICAgcmV0dXJuIHBhcmFtcztcblxuICAgIH07XG5cbiAgfTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGF1dG9yb3RhdGU7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcblxuLy8gQW4gTHJ1TWFwIGhvbGRzIHVwIHRvIGEgbWF4aW11bSBudW1iZXIgb2Yga2V5LXZhbHVlIHBhaXJzLCBvcmRlcmVkIGJ5IHRoZWlyXG4vLyB0aW1lIG9mIGluc2VydGlvbi4gV2hlbiB0aGUgYWRkaXRpb24gb2YgYSBrZXktdmFsdWUgcGFpciB3b3VsZCBjYXVzZSB0aGVcbi8vIGNhcGFjaXR5IHRvIGJlIGV4Y2VlZGVkLCB0aGUgb2xkZXN0IGtleS12YWx1ZSBwYWlyIGluIHRoZSBzZXQgaXMgZXZpY3RlZC5cbi8vIEFzIGEgc3BlY2lhbCBjYXNlLCBhbiBMcnVNYXAgd2l0aCB6ZXJvIGNhcGFjaXR5IGFsd2F5cyByZWplY3RzIHRoZSBpbnNlcnRpb25cbi8vIG9mIGEga2V5LXZhbHVlIHBhaXIuXG4vL1xuLy8gS2V5cyBtdXN0IGltcGxlbWVudCBoYXNoKCkgYW5kIGVxdWFscygpLiBOb3RlIHRoYXQgdGhlIGltcGxlbWVudGF0aW9uIGRvZXNuJ3Rcbi8vIGN1cnJlbnRseSB1c2UgaGFzaCgpLCBidXQgYSBmdXR1cmUgdmVyc2lvbiBtaWdodC5cbmZ1bmN0aW9uIExydU1hcChjYXBhY2l0eSkge1xuICBpZiAoIWlzRmluaXRlKGNhcGFjaXR5KSB8fCBNYXRoLmZsb29yKGNhcGFjaXR5KSAhPT0gY2FwYWNpdHkgfHwgY2FwYWNpdHkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMcnVNYXA6IGludmFsaWQgY2FwYWNpdHknKTtcbiAgfVxuICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuXG4gIC8vIEtleXMgYW5kIHZhbHVlcyBhcmUgc3RvcmVkIGluIGNpcmN1bGFyIGFycmF5cyBvcmRlcmVkIGJ5IGRlY3JlYXNpbmcgYWdlLlxuICAvLyBTdGFydCBpcyB0aGUgaW5kZXggb2YgdGhlIG9sZGVzdCBrZXkvdmFsdWUgYW5kIHNpemUgaXMgdGhlIG51bWJlciBvZiB2YWxpZFxuICAvLyBrZXkvdmFsdWVzOyB0aGUgcmVnaW9uIGNvbnRhaW5pbmcgdmFsaWQga2V5cy92YWx1ZXMgbWF5IHdyYXAgYXJvdW5kLlxuICB0aGlzLl9rZXlzID0gbmV3IEFycmF5KHRoaXMuX2NhcGFjaXR5KTtcbiAgdGhpcy5fdmFsdWVzID0gbmV3IEFycmF5KHRoaXMuX2NhcGFjaXR5KTtcbiAgdGhpcy5fc3RhcnQgPSAwO1xuICB0aGlzLl9zaXplID0gMDtcbn1cblxuTHJ1TWFwLnByb3RvdHlwZS5faW5kZXggPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiBtb2QodGhpcy5fc3RhcnQgKyBpLCB0aGlzLl9jYXBhY2l0eSk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHRvIHRoZSBzcGVjaWZpZWQga2V5LCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbkxydU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2l6ZTsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nS2V5ID0gdGhpcy5fa2V5c1t0aGlzLl9pbmRleChpKV07XG4gICAgaWYgKGtleS5lcXVhbHMoZXhpc3RpbmdLZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW3RoaXMuX2luZGV4KGkpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBBc3NvY2lhdGVzIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgcG9zc2libHkgcmVwbGFjaW5nIHRoZVxuLy8gY3VycmVudGx5IGFzc29jaWF0ZWQgdmFsdWUuIFRoZSBrZXktdmFsdWUgcGFpciBiZWNvbWVzIHRoZSBuZXdlc3QuIElmIHRoZSBtYXBcbi8vIGlzIGF0IGNhcGFjaXR5LCB0aGUgb2xkZXN0IGtleS12YWx1ZSBwYWlyIGlzIHJlbW92ZWQuIFJldHVybnMgdGhlIHJlbW92ZWRcbi8vIGtleSwgb3IgbnVsbCBvdGhlcndpc2UuIElmIHRoZSBjYXBhY2l0eSBpcyB6ZXJvLCBkb2VzIG5vdGhpbmcgYW5kIHJldHVybnNcbi8vIHRoZSBrZXkuXG5McnVNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgaWYgKHRoaXMuX2NhcGFjaXR5ID09PSAwKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICB0aGlzLmRlbChrZXkpO1xuICB2YXIgZXZpY3RlZEtleSA9XG4gICAgICB0aGlzLl9zaXplID09PSB0aGlzLl9jYXBhY2l0eSA/IHRoaXMuX2tleXNbdGhpcy5faW5kZXgoMCldIDogbnVsbDtcbiAgdGhpcy5fa2V5c1t0aGlzLl9pbmRleCh0aGlzLl9zaXplKV0gPSBrZXk7XG4gIHRoaXMuX3ZhbHVlc1t0aGlzLl9pbmRleCh0aGlzLl9zaXplKV0gPSB2YWx1ZTtcbiAgaWYgKHRoaXMuX3NpemUgPCB0aGlzLl9jYXBhY2l0eSkge1xuICAgIHRoaXMuX3NpemUrKztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zdGFydCA9IHRoaXMuX2luZGV4KDEpO1xuICB9XG4gIHJldHVybiBldmljdGVkS2V5O1xufTtcblxuLy8gUmVtb3ZlcyB0aGUga2V5LXZhbHVlIHBhaXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LlxuLy8gUmV0dXJucyB0aGUgcmVtb3ZlZCB2YWx1ZSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG5McnVNYXAucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGtleSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgIGlmIChrZXkuZXF1YWxzKHRoaXMuX2tleXNbdGhpcy5faW5kZXgoaSldKSkge1xuICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB0aGlzLl92YWx1ZXNbdGhpcy5faW5kZXgoaSldO1xuICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCB0aGlzLl9zaXplIC0gMTsgaisrKSB7XG4gICAgICAgIHRoaXMuX2tleXNbdGhpcy5faW5kZXgoaildID0gdGhpcy5fa2V5c1t0aGlzLl9pbmRleChqICsgMSldO1xuICAgICAgICB0aGlzLl92YWx1ZXNbdGhpcy5faW5kZXgoaildID0gdGhpcy5fdmFsdWVzW3RoaXMuX2luZGV4KGogKyAxKV07XG4gICAgICB9XG4gICAgICB0aGlzLl9zaXplLS07XG4gICAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZXR1cm5zIHdoZXRoZXIgdGhlcmUgaXMgYSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuXG5McnVNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgIGlmIChrZXkuZXF1YWxzKHRoaXMuX2tleXNbdGhpcy5faW5kZXgoaSldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBrZXktdmFsdWUgcGFpcnMgaW4gdGhlIG1hcC5cbkxydU1hcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cbi8vIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBwYWlycyBmcm9tIHRoZSBtYXAuXG5McnVNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcbiAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gIHRoaXMuX3N0YXJ0ID0gMDtcbiAgdGhpcy5fc2l6ZSA9IDA7XG59O1xuXG4vLyBDYWxscyBmbihrZXksIHZhbHVlKSBmb3IgZWFjaCBpdGVtIGluIHRoZSBtYXAsIGluIGFuIHVuc3BlY2lmaWVkIG9yZGVyLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpbWVzIGZuIHdhcyBjYWxsZWQuXG4vLyBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIHRoZSBtYXAgaXMgbXV0YXRlZCBkdXJpbmcgaXRlcmF0aW9uLlxuTHJ1TWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICBmbih0aGlzLl9rZXlzW3RoaXMuX2luZGV4KGkpXSwgdGhpcy5fdmFsdWVzW3RoaXMuX2luZGV4KGkpXSk7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExydU1hcDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG5cbi8vIEFuIExydVNldCBob2xkcyB1cCB0byBhIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzLCBvcmRlcmVkIGJ5IHRoZWlyIHRpbWUgb2Zcbi8vIGluc2VydGlvbi4gV2hlbiB0aGUgYWRkaXRpb24gb2YgYW4gZWxlbWVudCB3b3VsZCBjYXVzZSB0aGUgY2FwYWNpdHkgdG8gYmVcbi8vIGV4Y2VlZGVkLCB0aGUgb2xkZXN0IGVsZW1lbnQgaW4gdGhlIHNldCBpcyBldmljdGVkLiBBcyBhIHNwZWNpYWwgY2FzZSwgYW5cbi8vIExydVNldCB3aXRoIHplcm8gY2FwYWNpdHkgYWx3YXlzIHJlamVjdHMgdGhlIGluc2VydGlvbiBvZiBhbiBlbGVtZW50LlxuLy9cbi8vIEVsZW1lbnRzIG11c3QgaW1wbGVtZW50IGhhc2goKSBhbmQgZXF1YWxzKCkuIE5vdGUgdGhhdCB0aGUgaW1wbGVtZW50YXRpb25cbi8vIGRvZXNuJ3QgY3VycmVudGx5IHVzZSBoYXNoKCksIGJ1dCBhIGZ1dHVyZSB2ZXJzaW9uIG1pZ2h0LlxuZnVuY3Rpb24gTHJ1U2V0KGNhcGFjaXR5KSB7XG4gIGlmICghaXNGaW5pdGUoY2FwYWNpdHkpIHx8IE1hdGguZmxvb3IoY2FwYWNpdHkpICE9PSBjYXBhY2l0eSB8fCBjYXBhY2l0eSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xydVNldDogaW52YWxpZCBjYXBhY2l0eScpO1xuICB9XG4gIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG5cbiAgLy8gRWxlbWVudHMgYXJlIHN0b3JlZCBpbiBhIGNpcmN1bGFyIGFycmF5IG9yZGVyZWQgYnkgZGVjcmVhc2luZyBhZ2UuXG4gIC8vIFN0YXJ0IGlzIHRoZSBpbmRleCBvZiB0aGUgb2xkZXN0IGVsZW1lbnQgYW5kIHNpemUgaXMgdGhlIG51bWJlciBvZiB2YWxpZFxuICAvLyBlbGVtZW50czsgdGhlIHJlZ2lvbiBjb250YWluaW5nIHZhbGlkIGVsZW1lbnRzIG1heSB3cmFwIGFyb3VuZC5cbiAgdGhpcy5fZWxlbWVudHMgPSBuZXcgQXJyYXkodGhpcy5fY2FwYWNpdHkpO1xuICB0aGlzLl9zdGFydCA9IDA7XG4gIHRoaXMuX3NpemUgPSAwO1xufVxuXG5McnVTZXQucHJvdG90eXBlLl9pbmRleCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIG1vZCh0aGlzLl9zdGFydCArIGksIHRoaXMuX2NhcGFjaXR5KTtcbn07XG5cbi8vIEFkZHMgYW4gZWxlbWVudCBpbnRvIHRoZSBzZXQsIHBvc3NpYmx5IHJlcGxhY2luZyBhbiBlcXVhbCBlbGVtZW50IGFscmVhZHkgaW5cbi8vIHRoZSBzZXQuIFRoZSBlbGVtZW50IGJlY29tZXMgdGhlIG5ld2VzdC4gSWYgdGhlIHNldCBpcyBhdCBjYXBhY2l0eSwgdGhlXG4vLyBvbGRlc3QgZWxlbWVudCBpcyByZW1vdmVkLiBSZXR1cm5zIHRoZSByZW1vdmVkIGVsZW1lbnQgaWYgaXQgZG9lcyBub3QgZXF1YWxcbi8vIHRoZSBpbnNlcnRlZCBlbGVtZW50LCBvciBudWxsIG90aGVyd2lzZS4gSWYgdGhlIGNhcGFjaXR5IGlzIHplcm8sIGRvZXNcbi8vIG5vdGhpbmcgYW5kIHJldHVybnMgdGhlIGVsZW1lbnQuXG5McnVTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKHRoaXMuX2NhcGFjaXR5ID09PSAwKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gIHZhciBldmljdGVkRWxlbWVudCA9XG4gICAgICB0aGlzLl9zaXplID09PSB0aGlzLl9jYXBhY2l0eSA/IHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KDApXSA6IG51bGw7XG4gIHRoaXMuX2VsZW1lbnRzW3RoaXMuX2luZGV4KHRoaXMuX3NpemUpXSA9IGVsZW1lbnQ7XG4gIGlmICh0aGlzLl9zaXplIDwgdGhpcy5fY2FwYWNpdHkpIHtcbiAgICB0aGlzLl9zaXplKys7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9pbmRleCgxKTtcbiAgfVxuICByZXR1cm4gZXZpY3RlZEVsZW1lbnQ7XG59O1xuXG4vLyBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgc2V0LlxuLy8gUmV0dXJucyB0aGUgcmVtb3ZlZCBlbGVtZW50LCBvciBudWxsIGlmIHRoZSBlbGVtZW50IHdhcyBub3QgZm91bmQuXG5McnVTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICB2YXIgZXhpc3RpbmdFbGVtZW50ID0gdGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgoaSldO1xuICAgIGlmIChlbGVtZW50LmVxdWFscyhleGlzdGluZ0VsZW1lbnQpKSB7XG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA8IHRoaXMuX3NpemUgLSAxOyBqKyspIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgoaildID0gdGhpcy5fZWxlbWVudHNbdGhpcy5faW5kZXgoaiArIDEpXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgIHJldHVybiBleGlzdGluZ0VsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gUmV0dXJucyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhlIHNldC5cbkxydVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NpemU7IGkrKykge1xuICAgIGlmIChlbGVtZW50LmVxdWFscyh0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleChpKV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBzZXQuXG5McnVTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG4vLyBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBzZXQuXG5McnVTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2VsZW1lbnRzLmxlbmd0aCA9IDA7XG4gIHRoaXMuX3N0YXJ0ID0gMDtcbiAgdGhpcy5fc2l6ZSA9IDA7XG59O1xuXG4vLyBDYWxscyBmbihlbGVtZW50KSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQsIGluIGFuIHVuc3BlY2lmaWVkIG9yZGVyLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpbWVzIGZuIHdhcyBjYWxsZWQuXG4vLyBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIHRoZSBzZXQgaXMgbXV0YXRlZCBkdXJpbmcgaXRlcmF0aW9uLlxuTHJ1U2V0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICBmbih0aGlzLl9lbGVtZW50c1t0aGlzLl9pbmRleChpKV0pO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMcnVTZXQ7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb2QgPSByZXF1aXJlKCcuLi91dGlsL21vZCcpO1xuXG52YXIgZGVmYXVsdENhcGFjaXR5ID0gNjQ7XG5cbi8vIEEgbWFwIGRhdGEgc3RydWN0dXJlIGZvciBrZXlzIGltcGxlbWVudGluZyBoYXNoKCkgYW5kIGVxdWFscygpIGFuZCBhcmJpdHJhcnlcbi8vIHZhbHVlcy4gVGhlIGNhcGFjaXR5LCBpZiBnaXZlbiwgaXMganVzdCBhIGhpbnQ7IHRoZSBtYXAgaXMgYWxsb3dlZCB0byBleGNlZWRcbi8vIGl0LCBidXQgcGVyZm9ybWFuY2UgbWF5IHN1ZmZlci5cbmZ1bmN0aW9uIE1hcChjYXBhY2l0eSkge1xuICBpZiAoY2FwYWNpdHkgIT0gbnVsbCAmJlxuICAgICAgKCFpc0Zpbml0ZShjYXBhY2l0eSkgfHwgTWF0aC5mbG9vcihjYXBhY2l0eSkgIT09IGNhcGFjaXR5IHx8IGNhcGFjaXR5IDwgMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hcDogaW52YWxpZCBjYXBhY2l0eScpO1xuICB9XG4gIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHkgfHwgZGVmYXVsdENhcGFjaXR5O1xuXG4gIHRoaXMuX2tleUJ1Y2tldHMgPSBbXTtcbiAgdGhpcy5fdmFsQnVja2V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NhcGFjaXR5OyBpKyspIHtcbiAgICB0aGlzLl9rZXlCdWNrZXRzLnB1c2goW10pO1xuICAgIHRoaXMuX3ZhbEJ1Y2tldHMucHVzaChbXSk7XG4gIH1cbiAgdGhpcy5fc2l6ZSA9IDA7XG59XG5cbi8vIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG5NYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgaCA9IG1vZChrZXkuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBrZXlCdWNrZXQgPSB0aGlzLl9rZXlCdWNrZXRzW2hdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJ1Y2tldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0tleSA9IGtleUJ1Y2tldFtpXTtcbiAgICBpZiAoa2V5LmVxdWFscyhleGlzdGluZ0tleSkpIHtcbiAgICAgIHZhciB2YWxCdWNrZXQgPSB0aGlzLl92YWxCdWNrZXRzW2hdO1xuICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB2YWxCdWNrZXRbaV07XG4gICAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBBc3NvY2lhdGVzIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgcG9zc2libHkgcmVwbGFjaW5nIHRoZVxuLy8gY3VycmVudGx5IGFzc29jaWF0ZWQgdmFsdWUuXG4vLyBSZXR1cm5zIHRoZSByZXBsYWNlZCB2YWx1ZSwgb3IgbnVsbCBpZiBubyB2YWx1ZSB3YXMgcmVwbGFjZWQuXG5NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gIHZhciBoID0gbW9kKGtleS5oYXNoKCksIHRoaXMuX2NhcGFjaXR5KTtcbiAgdmFyIGtleUJ1Y2tldCA9IHRoaXMuX2tleUJ1Y2tldHNbaF07XG4gIHZhciB2YWxCdWNrZXQgPSB0aGlzLl92YWxCdWNrZXRzW2hdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJ1Y2tldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0tleSA9IGtleUJ1Y2tldFtpXTtcbiAgICBpZiAoa2V5LmVxdWFscyhleGlzdGluZ0tleSkpIHtcbiAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gdmFsQnVja2V0W2ldO1xuICAgICAga2V5QnVja2V0W2ldID0ga2V5O1xuICAgICAgdmFsQnVja2V0W2ldID0gdmFsO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nVmFsdWU7XG4gICAgfVxuICB9XG4gIGtleUJ1Y2tldC5wdXNoKGtleSk7XG4gIHZhbEJ1Y2tldC5wdXNoKHZhbCk7XG4gIHRoaXMuX3NpemUrKztcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZW1vdmVzIHRoZSBrZXktdmFsdWUgcGFpciBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuXG4vLyBSZXR1cm5zIHRoZSByZW1vdmVkIHZhbHVlLCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbk1hcC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBoID0gbW9kKGtleS5oYXNoKCksIHRoaXMuX2NhcGFjaXR5KTtcbiAgdmFyIGtleUJ1Y2tldCA9IHRoaXMuX2tleUJ1Y2tldHNbaF07XG4gIHZhciB2YWxCdWNrZXQgPSB0aGlzLl92YWxCdWNrZXRzW2hdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJ1Y2tldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0tleSA9IGtleUJ1Y2tldFtpXTtcbiAgICBpZiAoa2V5LmVxdWFscyhleGlzdGluZ0tleSkpIHtcbiAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gdmFsQnVja2V0W2ldO1xuICAgICAgLy8gU3BsaWNlIG1hbnVhbGx5IHRvIGF2b2lkIEFycmF5I3NwbGljZSByZXR1cm4gdmFsdWUgYWxsb2NhdGlvbi5cbiAgICAgIGZvciAodmFyIGogPSBpOyBqIDwga2V5QnVja2V0Lmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICBrZXlCdWNrZXRbal0gPSBrZXlCdWNrZXRbaisxXTtcbiAgICAgICAgdmFsQnVja2V0W2pdID0gdmFsQnVja2V0W2orMV07XG4gICAgICB9XG4gICAgICBrZXlCdWNrZXQubGVuZ3RoID0ga2V5QnVja2V0Lmxlbmd0aCAtIDE7XG4gICAgICB2YWxCdWNrZXQubGVuZ3RoID0gdmFsQnVja2V0Lmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLl9zaXplLS07XG4gICAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBSZXR1cm5zIHdoZXRoZXIgdGhlcmUgaXMgYSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuXG5NYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgaCA9IG1vZChrZXkuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBrZXlCdWNrZXQgPSB0aGlzLl9rZXlCdWNrZXRzW2hdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJ1Y2tldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0tleSA9IGtleUJ1Y2tldFtpXTtcbiAgICBpZiAoa2V5LmVxdWFscyhleGlzdGluZ0tleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5LXZhbHVlIHBhaXJzIGluIHRoZSBtYXAuXG5NYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG4vLyBSZW1vdmVzIGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSB0aGUgbWFwLlxuTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NhcGFjaXR5OyBpKyspIHtcbiAgICB0aGlzLl9rZXlCdWNrZXRzW2ldLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fdmFsQnVja2V0c1tpXS5sZW5ndGggPSAwO1xuICB9XG4gIHRoaXMuX3NpemUgPSAwO1xufTtcblxuLy8gQ2FsbHMgZm4oa2V5LCB2YWx1ZSkgZm9yIGVhY2gga2V5LXZhbHVlIHBhaXIgaW4gdGhlIG1hcCwgaW4gYW4gdW5zcGVjaWZpZWRcbi8vIG9yZGVyLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGltZXMgZm4gd2FzIGNhbGxlZC5cbi8vIFRoZSByZXN1bHQgaXMgdW5zcGVjaWZpZWQgaWYgdGhlIG1hcCBpcyBtdXRhdGVkIGR1cmluZyBpdGVyYXRpb24uXG5NYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmbikge1xuICB2YXIgY291bnQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NhcGFjaXR5OyBpKyspIHtcbiAgICB2YXIga2V5QnVja2V0ID0gdGhpcy5fa2V5QnVja2V0c1tpXTtcbiAgICB2YXIgdmFsQnVja2V0ID0gdGhpcy5fdmFsQnVja2V0c1tpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleUJ1Y2tldC5sZW5ndGg7IGorKykge1xuICAgICAgZm4oa2V5QnVja2V0W2pdLCB2YWxCdWNrZXRbal0pO1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb2QgPSByZXF1aXJlKCcuLi91dGlsL21vZCcpO1xuXG52YXIgZGVmYXVsdENhcGFjaXR5ID0gNjQ7XG5cbi8vIEEgc2V0IGRhdGEgc3RydWN0dXJlIGZvciBlbGVtZW50cyBpbXBsZW1lbnRpbmcgaGFzaCgpIGFuZCBlcXVhbHMoKS5cbi8vIFRoZSBjYXBhY2l0eSwgaWYgZ2l2ZW4sIGlzIGp1c3QgYSBoaW50OyB0aGUgc2V0IGlzIGFsbG93ZWQgdG8gZXhjZWVkIGl0LCBidXRcbi8vIHBlcmZvcm1hbmNlIG1heSBzdWZmZXIuXG5mdW5jdGlvbiBTZXQoY2FwYWNpdHkpIHtcbiAgaWYgKGNhcGFjaXR5ICE9IG51bGwgJiZcbiAgICAgICghaXNGaW5pdGUoY2FwYWNpdHkpIHx8IE1hdGguZmxvb3IoY2FwYWNpdHkpICE9PSBjYXBhY2l0eSB8fCBjYXBhY2l0eSA8IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZXQ6IGludmFsaWQgY2FwYWNpdHknKTtcbiAgfVxuICB0aGlzLl9jYXBhY2l0eSA9IHRoaXMuX2NhcGFjaXR5IHx8IGRlZmF1bHRDYXBhY2l0eTtcblxuICB0aGlzLl9idWNrZXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2FwYWNpdHk7IGkrKykge1xuICAgIHRoaXMuX2J1Y2tldHMucHVzaChbXSk7XG4gIH1cbiAgdGhpcy5fc2l6ZSA9IDA7XG59XG5cbi8vIEFkZHMgYW4gZWxlbWVudCwgcmVwbGFjaW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQuXG4vLyBSZXR1cm5zIHRoZSByZXBsYWNlZCBlbGVtZW50LCBvciBudWxsIGlmIG5vIGVsZW1lbnQgd2FzIHJlcGxhY2VkLlxuU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBoID0gbW9kKGVsZW1lbnQuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBidWNrZXQgPSB0aGlzLl9idWNrZXRzW2hdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0VsZW1lbnQgPSBidWNrZXRbaV07XG4gICAgaWYgKGVsZW1lbnQuZXF1YWxzKGV4aXN0aW5nRWxlbWVudCkpIHtcbiAgICAgIGJ1Y2tldFtpXSA9IGVsZW1lbnQ7XG4gICAgICByZXR1cm4gZXhpc3RpbmdFbGVtZW50O1xuICAgIH1cbiAgfVxuICBidWNrZXQucHVzaChlbGVtZW50KTtcbiAgdGhpcy5fc2l6ZSsrO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIFJlbW92ZXMgYW4gZWxlbWVudC5cbi8vIFJldHVybnMgdGhlIHJlbW92ZWQgZWxlbWVudCwgb3IgbnVsbCBpZiB0aGUgZWxlbWVudCB3YXMgbm90IGZvdW5kLlxuU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBoID0gbW9kKGVsZW1lbnQuaGFzaCgpLCB0aGlzLl9jYXBhY2l0eSk7XG4gIHZhciBidWNrZXQgPSB0aGlzLl9idWNrZXRzW2hdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBleGlzdGluZ0VsZW1lbnQgPSBidWNrZXRbaV07XG4gICAgaWYgKGVsZW1lbnQuZXF1YWxzKGV4aXN0aW5nRWxlbWVudCkpIHtcbiAgICAgIC8vIFNwbGljZSBtYW51YWxseSB0byBhdm9pZCBBcnJheSNzcGxpY2UgcmV0dXJuIHZhbHVlIGFsbG9jYXRpb24uXG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGJ1Y2tldC5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgYnVja2V0W2pdID0gYnVja2V0W2orMV07XG4gICAgICB9XG4gICAgICBidWNrZXQubGVuZ3RoID0gYnVja2V0Lmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLl9zaXplLS07XG4gICAgICByZXR1cm4gZXhpc3RpbmdFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIFJldHVybnMgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoZSBzZXQuXG5TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGggPSBtb2QoZWxlbWVudC5oYXNoKCksIHRoaXMuX2NhcGFjaXR5KTtcbiAgdmFyIGJ1Y2tldCA9IHRoaXMuX2J1Y2tldHNbaF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV4aXN0aW5nRWxlbWVudCA9IGJ1Y2tldFtpXTtcbiAgICBpZiAoZWxlbWVudC5lcXVhbHMoZXhpc3RpbmdFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2V0LlxuU2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zaXplO1xufTtcblxuLy8gUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgc2V0LlxuU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NhcGFjaXR5OyBpKyspIHtcbiAgICB0aGlzLl9idWNrZXRzW2ldLmxlbmd0aCA9IDA7XG4gIH1cbiAgdGhpcy5fc2l6ZSA9IDA7XG59O1xuXG4vLyBDYWxscyBmbihlbGVtZW50KSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQsIGluIGFuIHVuc3BlY2lmaWVkIG9yZGVyLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpbWVzIGZuIHdhcyBjYWxsZWQuXG4vLyBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIHRoZSBzZXQgaXMgbXV0YXRlZCBkdXJpbmcgaXRlcmF0aW9uLlxuU2V0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYXBhY2l0eTsgaSsrKSB7XG4gICAgdmFyIGJ1Y2tldCA9IHRoaXMuX2J1Y2tldHNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBidWNrZXQubGVuZ3RoOyBqKyspIHtcbiAgICAgIGZuKGJ1Y2tldFtqXSk7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFdvcmtRdWV1ZSA9IHJlcXVpcmUoJy4vV29ya1F1ZXVlJyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcblxuXG5mdW5jdGlvbiBXb3JrUG9vbChvcHRzKSB7XG4gIHRoaXMuX2NvbmN1cnJlbmN5ID0gb3B0cyAmJiBvcHRzLmNvbmN1cnJlbmN5IHx8IDE7XG4gIHRoaXMuX3BhdXNlZCA9IG9wdHMgJiYgISFvcHRzLnBhdXNlZCB8fCBmYWxzZTtcblxuICB0aGlzLl9wb29sID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29uY3VycmVuY3k7IGkrKykge1xuICAgIHRoaXMuX3Bvb2wucHVzaChuZXcgV29ya1F1ZXVlKG9wdHMpKTtcbiAgfVxuXG4gIHRoaXMuX25leHQgPSAwO1xufVxuXG5cbldvcmtQb29sLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxlbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9vbC5sZW5ndGg7IGkrKykge1xuICAgIGxlbiArPSB0aGlzLl9wb29sW2ldLmxlbmd0aCgpO1xuICB9XG4gIHJldHVybiBsZW47XG59O1xuXG5cbldvcmtQb29sLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZm4sIGNiKSB7XG4gIHZhciBpID0gdGhpcy5fbmV4dDtcbiAgdmFyIGNhbmNlbCA9IHRoaXMuX3Bvb2xbaV0ucHVzaChmbiwgY2IpO1xuICB0aGlzLl9uZXh0ID0gbW9kKHRoaXMuX25leHQgKyAxLCB0aGlzLl9jb25jdXJyZW5jeSk7XG4gIHJldHVybiBjYW5jZWw7XG59O1xuXG5cbldvcmtQb29sLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICB0aGlzLl9wb29sW2ldLnBhdXNlKCk7XG4gICAgfVxuICB9XG59O1xuXG5cbldvcmtQb29sLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgdGhpcy5fcG9vbFtpXS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrUG9vbDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vdyA9IHJlcXVpcmUoJy4uL3V0aWwvbm93Jyk7XG5cblxuZnVuY3Rpb24gV29ya1Rhc2soZm4sIGNiKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmNmbiA9IG51bGw7XG59XG5cblxuZnVuY3Rpb24gV29ya1F1ZXVlKG9wdHMpIHtcbiAgdGhpcy5fcXVldWUgPSBbXTtcbiAgdGhpcy5fZGVsYXkgPSBvcHRzICYmIG9wdHMuZGVsYXkgfHwgMDtcbiAgdGhpcy5fcGF1c2VkID0gb3B0cyAmJiAhIW9wdHMucGF1c2VkIHx8IGZhbHNlO1xuICB0aGlzLl9jdXJyZW50VGFzayA9IG51bGw7XG4gIHRoaXMuX2xhc3RGaW5pc2hlZCA9IG51bGw7XG59XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aDtcbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZm4sIGNiKSB7XG5cbiAgdmFyIHRhc2sgPSBuZXcgV29ya1Rhc2soZm4sIGNiKTtcblxuICB2YXIgY2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcywgdGFzayk7XG5cbiAgLy8gUHVzaCB0aGUgdGFzayBpbnRvIHRoZSBxdWV1ZS5cbiAgdGhpcy5fcXVldWUucHVzaCh0YXNrKTtcblxuICAvLyBSdW4gdGhlIHRhc2sgaWYgaWRsZS5cbiAgdGhpcy5fbmV4dCgpO1xuXG4gIHJldHVybiBjYW5jZWw7XG5cbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH1cbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX25leHQoKTtcbiAgfVxufTtcblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKHRhc2spIHtcblxuICAvLyBDb25zaXN0ZW5jeSBjaGVjay5cbiAgaWYgKHRoaXMuX2N1cnJlbnRUYXNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrUXVldWU6IGNhbGxlZCBzdGFydCB3aGlsZSBydW5uaW5nIHRhc2snKTtcbiAgfVxuXG4gIC8vIE1hcmsgcXVldWUgYXMgYnVzeSwgc28gdGhhdCBjb25jdXJyZW50IHRhc2tzIHdhaXQuXG4gIHRoaXMuX2N1cnJlbnRUYXNrID0gdGFzaztcblxuICAvLyBFeGVjdXRlIHRoZSB0YXNrLlxuICB2YXIgZmluaXNoID0gdGhpcy5fZmluaXNoLmJpbmQodGhpcywgdGFzayk7XG4gIHRhc2suY2ZuID0gdGFzay5mbihmaW5pc2gpO1xuXG4gIC8vIERldGVjdCB3aGVuIGEgbm9uLWNhbmNlbGxhYmxlIGZ1bmN0aW9uIGhhcyBiZWVuIHF1ZXVlZC5cbiAgaWYgKHR5cGVvZiB0YXNrLmNmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignV29ya1F1ZXVlOiBmdW5jdGlvbiBpcyBub3QgY2FuY2VsbGFibGUnKTtcbiAgfVxuXG59O1xuXG5cbldvcmtRdWV1ZS5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uKHRhc2spIHtcblxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2suXG4gIGlmICh0aGlzLl9jdXJyZW50VGFzayAhPT0gdGFzaykge1xuICAgIHRocm93IG5ldyBFcnJvcignV29ya1F1ZXVlOiBjYWxsZWQgZmluaXNoIG9uIHdyb25nIHRhc2snKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIHRhc2sgY2FsbGJhY2sgb24gdGhlIHJldHVybiB2YWx1ZXMuXG4gIHRhc2suY2IuYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgLy8gTWFyayBhcyBub3QgYnVzeSBhbmQgcmVjb3JkIHRhc2sgZmluaXNoIHRpbWUsIHRoZW4gYWR2YW5jZSB0byBuZXh0IHRhc2suXG4gIHRoaXMuX2N1cnJlbnRUYXNrID0gbnVsbDtcbiAgdGhpcy5fbGFzdEZpbmlzaGVkID0gbm93KCk7XG4gIHRoaXMuX25leHQoKTtcblxufTtcblxuXG5Xb3JrUXVldWUucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbih0YXNrKSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGlmICh0aGlzLl9jdXJyZW50VGFzayA9PT0gdGFzaykge1xuXG4gICAgLy8gQ2FuY2VsIHJ1bm5pbmcgdGFzay4gQmVjYXVzZSBjYW5jZWwgcGFzc2VzIGNvbnRyb2wgdG8gdGhlIF9maW5pc2hcbiAgICAvLyBjYWxsYmFjayB3ZSBwYXNzZWQgaW50byBmbiwgdGhlIGNsZWFudXAgbG9naWMgd2lsbCBiZSBoYW5kbGVkIHRoZXJlLlxuICAgIHRhc2suY2ZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gIH0gZWxzZSB7XG5cbiAgICAvLyBSZW1vdmUgdGFzayBmcm9tIHF1ZXVlLlxuICAgIHZhciBwb3MgPSB0aGlzLl9xdWV1ZS5pbmRleE9mKHRhc2spO1xuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKHBvcywgMSk7XG4gICAgICB0YXNrLmNiLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cblxuICB9XG5cbn07XG5cblxuV29ya1F1ZXVlLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAvLyBEbyBub3Qgc3RhcnQgdGFza3Mgd2hpbGUgcGF1c2VkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgLy8gTm8gdGFza3MgdG8gcnVuLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLl9jdXJyZW50VGFzaykge1xuICAgIC8vIFdpbGwgYmUgY2FsbGVkIGFnYWluIHdoZW4gdGhlIGN1cnJlbnQgdGFzayBmaW5pc2hlcy5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fbGFzdEZpbmlzaGVkICE9IG51bGwpIHtcbiAgICB2YXIgZWxhcHNlZCA9IG5vdygpIC0gdGhpcy5fbGFzdEZpbmlzaGVkO1xuICAgIHZhciByZW1haW5pbmcgPSB0aGlzLl9kZWxheSAtIGVsYXBzZWQ7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIC8vIFRvbyBzb29uLiBSdW4gYWdhaW4gYWZ0ZXIgdGhlIGludGVyLXRhc2sgZGVsYXkuXG4gICAgICBzZXRUaW1lb3V0KHRoaXMuX25leHQuYmluZCh0aGlzKSwgcmVtYWluaW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBSdW4gdGhlIG5leHQgdGFzay5cbiAgdmFyIHRhc2sgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICB0aGlzLl9zdGFydCh0YXNrKTtcblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtRdWV1ZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHZlYzQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWM0O1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGNvbG9yIHRyYW5zZm9ybWF0aW9uIHtAbGluayBFZmZlY3RzfS5cbiAqXG4gKiBSZWZlcmVuY2VzOlxuICpcbiAqICAgLSBbQ29sb3JNYXRyaXggR3VpZGVdKGh0dHA6Ly9kb2NzLnJhaW5tZXRlci5uZXQvdGlwcy9jb2xvcm1hdHJpeC1ndWlkZSlcbiAqICAgLSBbTWF0cml4IE9wZXJhdGlvbnMgZm9yIEltYWdlIFByb2Nlc3NpbmddKGh0dHA6Ly93d3cuZ3JhZmljYW9ic2N1cmEuY29tL21hdHJpeC9pbmRleC5odG1sKVxuICogICAtIFtXZWJHTEltYWdlRmlsdGVyXShodHRwczovL2dpdGh1Yi5jb20vcGhvYm9zbGFiL1dlYkdMSW1hZ2VGaWx0ZXIpXG4gKiAgIC0gW2dsZnguanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzKVxuICpcbiAqIEBuYW1lc3BhY2UgY29sb3JFZmZlY3RzXG4gKi9cblxuLyoqXG4gKiBBIHZlY3RvciBhbmQgbWF0cml4IGNvcnJlc3BvbmRpbmcgdG8gYW4gaWRlbnRpdHkgdHJhbnNmb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBPYmplY3QgdG8gc3RvcmUgcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzR9IHJlc3VsdC5jb2xvck9mZnNldCBBcnJheSB3aXRoIHplcm9lcy5cbiAqIEBwYXJhbSB7bWF0NH0gcmVzdWx0LmNvbG9yTWF0cml4IElkZW50aXR5IG1hdHJpeC5cbiAqXG4gKiBAbWVtYmVyb2YgY29sb3JFZmZlY3RzXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHJlc3VsdEFyZykge1xuICB2YXIgcmVzdWx0ID0gcmVzdWx0QXJnIHx8IHt9O1xuICByZXN1bHQuY29sb3JPZmZzZXQgPSByZXN1bHQuY29sb3JPZmZzZXQgfHwgdmVjNC5jcmVhdGUoKTtcbiAgcmVzdWx0LmNvbG9yTWF0cml4ID0gcmVzdWx0LmNvbG9yTWF0cml4IHx8IG1hdDQuY3JlYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwbHkgY29sb3IgZWZmZWN0cyB0byBhIHNpbmdsZSBwaXhlbFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gcGl4ZWwgVmFsdWVzIGluIHJhbmdlIFswLDFdXG4gKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge3ZlYzR9IGVmZmVjdC5jb2xvck9mZnNldFxuICogQHBhcmFtIHttYXQ0fSBlZmZlY3QuY29sb3JNYXRyaXhcbiAqIEBwYXJhbSB7dmVjNH0gcmVzdWx0IE9iamVjdCB0byBzdG9yZSByZXN1bHRcbiAqXG4gKiBAbWVtYmVyb2YgY29sb3JFZmZlY3RzXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VG9QaXhlbChwaXhlbCwgZWZmZWN0LCByZXN1bHQpIHtcbiAgdmVjNFRyYW5zZm9ybU1hdDRUcmFuc3Bvc2VkKHJlc3VsdCwgcGl4ZWwsIGVmZmVjdC5jb2xvck1hdHJpeCk7XG4gIHZlYzQuYWRkKHJlc3VsdCwgcmVzdWx0LCBlZmZlY3QuY29sb3JPZmZzZXQpO1xufVxuXG4vLyBPZGRseSwgdGhlIGNvbG9yVHJhbnNmb3JtIG1hdHJpeCBuZWVkcyB0byBiZSB0cmFuc3Bvc2VkIHRvIGJlIHVzZWQgd2l0aFxuLy8gdmVjNC50cmFuc2Zvcm1NYXQ0LiBJdCBpcyBzdHJhbmdlIHRoYXQgdHJhbnNmb3JtTWF0NCBkb3NuJ3Qgd29yayB0aGUgc2FtZVxuLy8gd2F5IGFzIG11bHRpcGx5aW5nIG9uIHRoZSBzaGFkZXIuXG4vLyBUT0RPOiBpbnZlc3RpZ2F0ZSB0aGlzIGZ1cnRoZXJcbmZ1bmN0aW9uIHZlYzRUcmFuc2Zvcm1NYXQ0VHJhbnNwb3NlZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMV0gKiB5ICsgbVsyXSAqIHogKyBtWzNdICogdztcbiAgb3V0WzFdID0gbVs0XSAqIHggKyBtWzVdICogeSArIG1bNl0gKiB6ICsgbVs3XSAqIHc7XG4gIG91dFsyXSA9IG1bOF0gKiB4ICsgbVs5XSAqIHkgKyBtWzEwXSAqIHogKyBtWzExXSAqIHc7XG4gIG91dFszXSA9IG1bMTJdICogeCArIG1bMTNdICogeSArIG1bMTRdICogeiArIG1bMTVdICogdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBcHBseSBjb2xvciBlZmZlY3RzIHRvIGFuIEltYWdlRGF0YVxuICpcbiAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBpbWFnZURhdGEgVGhpcyBvYmplY3Qgd2lsbCBiZSBtdXRhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge3ZlYzR9IGVmZmVjdC5jb2xvck9mZnNldFxuICogQHBhcmFtIHttYXQ0fSBlZmZlY3QuY29sb3JNYXRyaXhcbiAqXG4gKiBAbWVtYmVyb2YgY29sb3JFZmZlY3RzXG4gKi9cbnZhciB0bXBQaXhlbCA9IHZlYzQuY3JlYXRlKCk7XG5mdW5jdGlvbiBhcHBseVRvSW1hZ2VEYXRhKGltYWdlRGF0YSwgZWZmZWN0KSB7XG4gIHZhciB3aWR0aCA9IGltYWdlRGF0YS53aWR0aDtcbiAgdmFyIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG4gIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHdpZHRoICogaGVpZ2h0OyBpKyspIHtcbiAgICB2ZWM0LnNldCh0bXBQaXhlbCwgZGF0YVtpKjQrMF0vMjU1LCBkYXRhW2kqNCsxXS8yNTUsIGRhdGFbaSo0KzJdLzI1NSwgZGF0YVtpKjQrM10vMjU1KTtcbiAgICBhcHBseVRvUGl4ZWwodG1wUGl4ZWwsIGVmZmVjdCwgdG1wUGl4ZWwpO1xuICAgIGRhdGFbaSo0KzBdID0gdG1wUGl4ZWxbMF0qMjU1O1xuICAgIGRhdGFbaSo0KzFdID0gdG1wUGl4ZWxbMV0qMjU1O1xuICAgIGRhdGFbaSo0KzJdID0gdG1wUGl4ZWxbMl0qMjU1O1xuICAgIGRhdGFbaSo0KzNdID0gdG1wUGl4ZWxbM10qMjU1O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpZGVudGl0eTogaWRlbnRpdHksXG4gIGFwcGx5VG9QaXhlbDogYXBwbHlUb1BpeGVsLFxuICBhcHBseVRvSW1hZ2VEYXRhOiBhcHBseVRvSW1hZ2VEYXRhXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgbm93ID0gcmVxdWlyZSgnLi4vdXRpbC9ub3cnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIEBjbGFzcyBDb250cm9sQ29tcG9zZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBDb21iaW5lcyBjaGFuZ2VzIGluIHBhcmFtZXRlcnMgdHJpZ2dlcmVkIGJ5IG11bHRpcGxlIHtAbGluayBDb250cm9sTWV0aG9kfVxuICogaW5zdGFuY2VzLlxuICpcbiAqIEBsaXN0ZW5zIENvbnRyb2xNZXRob2QjcGFyYW1ldGVyRHluYW1pY3NcbiAqL1xuZnVuY3Rpb24gQ29udHJvbENvbXBvc2VyKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdGhpcy5fbWV0aG9kcyA9IFtdO1xuXG4gIHRoaXMuX3BhcmFtZXRlcnMgPSBbICd4JyAsJ3knLCAnYXhpc1NjYWxlZFgnLCAnYXhpc1NjYWxlZFknLCAnem9vbScsICd5YXcnLCAncGl0Y2gnLCAncm9sbCcgXTtcblxuICB0aGlzLl9ub3cgPSBvcHRzLm5vd0ZvclRlc3RpbmcgfHwgbm93O1xuXG4gIHRoaXMuX2NvbXBvc2VkT2Zmc2V0cyA9IHsgfTtcblxuICB0aGlzLl9jb21wb3NlUmV0dXJuID0geyBvZmZzZXRzOiB0aGlzLl9jb21wb3NlZE9mZnNldHMsIGNoYW5naW5nOiBudWxsIH07XG59XG5cbmV2ZW50RW1pdHRlcihDb250cm9sQ29tcG9zZXIpO1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaWYgKHRoaXMuaGFzKGluc3RhbmNlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkeW5hbWljcyA9IHt9O1xuICB0aGlzLl9wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG4gICAgZHluYW1pY3NbcGFyYW1ldGVyXSA9IHtcbiAgICAgIGR5bmFtaWNzOiBuZXcgRHluYW1pY3MoKSxcbiAgICAgIHRpbWU6IG51bGxcbiAgICB9O1xuICB9KTtcblxuICB2YXIgcGFyYW1ldGVyRHluYW1pY3NIYW5kbGVyID0gdGhpcy5fdXBkYXRlRHluYW1pY3MuYmluZCh0aGlzLCBkeW5hbWljcyk7XG5cbiAgdmFyIG1ldGhvZCA9IHtcbiAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgZHluYW1pY3M6IGR5bmFtaWNzLFxuICAgIHBhcmFtZXRlckR5bmFtaWNzSGFuZGxlcjogcGFyYW1ldGVyRHluYW1pY3NIYW5kbGVyXG4gIH07XG5cbiAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcigncGFyYW1ldGVyRHluYW1pY3MnLCBwYXJhbWV0ZXJEeW5hbWljc0hhbmRsZXIpO1xuXG4gIHRoaXMuX21ldGhvZHMucHVzaChtZXRob2QpO1xufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2luZGV4T2ZJbnN0YW5jZShpbnN0YW5jZSk7XG4gIGlmIChpbmRleCA+PSAwKSB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICBtZXRob2QuaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFyYW1ldGVyRHluYW1pY3MnLCBtZXRob2QucGFyYW1ldGVyRHluYW1pY3NIYW5kbGVyKTtcbiAgfVxufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIHJldHVybiB0aGlzLl9pbmRleE9mSW5zdGFuY2UoaW5zdGFuY2UpID49IDA7XG59O1xuXG5cbkNvbnRyb2xDb21wb3Nlci5wcm90b3R5cGUuX2luZGV4T2ZJbnN0YW5jZSA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLl9tZXRob2RzW2ldLmluc3RhbmNlID09PSBpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbnN0YW5jZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdGFuY2VzLnB1c2godGhpcy5fbWV0aG9kc1tpXS5pbnN0YW5jZSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlcztcbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5fdXBkYXRlRHluYW1pY3MgPSBmdW5jdGlvbihzdG9yZWREeW5hbWljcywgcGFyYW1ldGVyLCBkeW5hbWljcykge1xuICB2YXIgcGFyYW1ldGVyRHluYW1pY3MgPSBzdG9yZWREeW5hbWljc1twYXJhbWV0ZXJdO1xuXG4gIGlmICghcGFyYW1ldGVyRHluYW1pY3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbnRyb2wgcGFyYW1ldGVyIFwiICsgcGFyYW1ldGVyKTtcbiAgfVxuXG4gIHZhciBuZXdUaW1lID0gdGhpcy5fbm93KCk7XG4gIHBhcmFtZXRlckR5bmFtaWNzLmR5bmFtaWNzLnVwZGF0ZShkeW5hbWljcywgKG5ld1RpbWUgLSBwYXJhbWV0ZXJEeW5hbWljcy50aW1lKS8xMDAwKTtcbiAgcGFyYW1ldGVyRHluYW1pY3MudGltZSA9IG5ld1RpbWU7XG5cbiAgdGhpcy5lbWl0KCdjaGFuZ2UnKTtcbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5fcmVzZXRDb21wb3NlZE9mZnNldHMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fY29tcG9zZWRPZmZzZXRzW3RoaXMuX3BhcmFtZXRlcnNbaV1dID0gMDtcbiAgfVxufTtcblxuXG5Db250cm9sQ29tcG9zZXIucHJvdG90eXBlLm9mZnNldHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhcmFtZXRlcjtcbiAgdmFyIGNoYW5naW5nID0gZmFsc2U7XG5cbiAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5fbm93KCk7XG5cbiAgdGhpcy5fcmVzZXRDb21wb3NlZE9mZnNldHMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWV0aG9kRHluYW1pY3MgPSB0aGlzLl9tZXRob2RzW2ldLmR5bmFtaWNzO1xuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCB0aGlzLl9wYXJhbWV0ZXJzLmxlbmd0aDsgcCsrKSB7XG4gICAgICBwYXJhbWV0ZXIgPSB0aGlzLl9wYXJhbWV0ZXJzW3BdO1xuICAgICAgdmFyIHBhcmFtZXRlckR5bmFtaWNzID0gbWV0aG9kRHluYW1pY3NbcGFyYW1ldGVyXTtcbiAgICAgIHZhciBkeW5hbWljcyA9IHBhcmFtZXRlckR5bmFtaWNzLmR5bmFtaWNzO1xuXG5cbiAgICAgIC8vIEFkZCBvZmZzZXQgdG8gY29tcG9zZWQgb2Zmc2V0XG4gICAgICBpZiAoZHluYW1pY3Mub2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zZWRPZmZzZXRzW3BhcmFtZXRlcl0gKz0gZHluYW1pY3Mub2Zmc2V0O1xuICAgICAgICAvLyBSZXNldCBvZmZzZXRcbiAgICAgICAgZHluYW1pY3Mub2Zmc2V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIG9mZnNldCBmcm9tIHZlbG9jaXR5IGFuZCBhZGQgaXRcbiAgICAgIHZhciBlbGFwc2VkID0gKGN1cnJlbnRUaW1lIC0gcGFyYW1ldGVyRHluYW1pY3MudGltZSkvMTAwMDtcbiAgICAgIHZhciBvZmZzZXRGcm9tVmVsb2NpdHkgPSBkeW5hbWljcy5vZmZzZXRGcm9tVmVsb2NpdHkoZWxhcHNlZCk7XG5cbiAgICAgIGlmKG9mZnNldEZyb21WZWxvY2l0eSkge1xuICAgICAgICB0aGlzLl9jb21wb3NlZE9mZnNldHNbcGFyYW1ldGVyXSArPSBvZmZzZXRGcm9tVmVsb2NpdHk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB2ZWxvY2l0eSBvbiBkeW5hbWljc1xuICAgICAgdmFyIGN1cnJlbnRWZWxvY2l0eSA9IGR5bmFtaWNzLnZlbG9jaXR5QWZ0ZXIoZWxhcHNlZCk7XG4gICAgICBkeW5hbWljcy52ZWxvY2l0eSA9IGN1cnJlbnRWZWxvY2l0eTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgc3RpbGwgYSB2ZWxvY2l0eSwgc2V0IGNoYW5naW5nXG4gICAgICBpZihjdXJyZW50VmVsb2NpdHkpIHtcbiAgICAgICAgY2hhbmdpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwYXJhbWV0ZXJEeW5hbWljcy50aW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY29tcG9zZVJldHVybi5jaGFuZ2luZyA9IGNoYW5naW5nO1xuICByZXR1cm4gdGhpcy5fY29tcG9zZVJldHVybjtcbn07XG5cblxuQ29udHJvbENvbXBvc2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbnN0YW5jZXMgPSB0aGlzLmxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJlbW92ZShpbnN0YW5jZXNbaV0pO1xuICB9XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2xDb21wb3NlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vdXRpbC9kZWZhdWx0cycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBkZWZhdWx0T3B0cyA9IHtcbiAgYWN0aXZlOiAnbW92ZScsXG4gIGluYWN0aXZlOiAnZGVmYXVsdCcsXG4gIGRpc2FibGVkOiAnZGVmYXVsdCdcbn07XG5cbi8qKlxuICogQGNsYXNzIENvbnRyb2xDdXJzb3JcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBTZXRzIHRoZSBDU1MgY3Vyc29yIG9uIGEgRE9NIGVsZW1lbnQgYWNjb3JkaW5nIHRvIHRoZSBzdGF0ZSBvZiBhXG4gKiB7QGxpbmsgQ29udHJvbE1ldGhvZH0uXG4gKlxuICogQHBhcmFtIHtDb250cm9sc30gY29udHJvbHMgQ29udHJvbHMgaW5zdGFuY2UgY29udGFpbmluZyB0aGUgY29udHJvbCBtZXRob2QuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIGNvbnRyb2wgbWV0aG9kLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IERPTSBlbGVtZW50IHdoZXJlIHRoZSBjdXJzb3Igc2hvdWxkIGJlIHNldC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBjb250cm9sIGN1cnNvcnMuIEVhY2ggZmllbGQgbXVzdCBiZSBhIHZhbGlkIHZhbHVlXG4gKiAgICAgZm9yIHRoZSBgY3Vyc29yYCBDU1MgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYWN0aXZlPSdtb3ZlJ10gQ3Vyc29yIHRvIHNldCB3aGVuIHRoZSBjb250cm9sIG1ldGhvZFxuICogICAgIGlzIGVuYWJsZWQgYW5kIGFjdGl2ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pbmFjdGl2ZT0nZGVmYXVsdCddIEN1cnNvciB0byBzZXQgd2hlbiB0aGUgY29udHJvbFxuICogICAgIG1ldGhvZCBpcyBlbmFibGVkIGFuZCBpbmFjdGl2ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5kaXNhYmxlZD0nZGVmYXVsdCddIEN1cnNvciB0byBzZXQgd2hlbiB0aGUgY29udHJvbFxuICogICAgIG1ldGhvZCBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gQ29udHJvbEN1cnNvcihjb250cm9scywgaWQsIGVsZW1lbnQsIG9wdHMpIHtcbiAgb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRzKTtcblxuICAvLyBUT0RPOiBUaGlzIGNsYXNzIG1heSBtaXNiZWhhdmUgaWYgdGhlIGNvbnRyb2wgbWV0aG9kIGlzIHVucmVnaXN0ZXJlZCBhbmQgYVxuICAvLyBkaWZmZXJlbnQgY29udHJvbCBtZXRob2QgaXMgcmVnaXN0ZXJlZCB1bmRlciB0aGUgc2FtZSBpZC5cblxuICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcbiAgdGhpcy5faWQgPSBpZDtcblxuICB0aGlzLl9hdHRhY2hlZCA9IGZhbHNlO1xuXG4gIHRoaXMuX3NldEFjdGl2ZUN1cnNvciA9IHRoaXMuX3NldEN1cnNvci5iaW5kKHRoaXMsIG9wdHMuYWN0aXZlKTtcbiAgdGhpcy5fc2V0SW5hY3RpdmVDdXJzb3IgPSB0aGlzLl9zZXRDdXJzb3IuYmluZCh0aGlzLCBvcHRzLmluYWN0aXZlKTtcbiAgdGhpcy5fc2V0RGlzYWJsZWRDdXJzb3IgPSB0aGlzLl9zZXRDdXJzb3IuYmluZCh0aGlzLCBvcHRzLmRpc2FibGVkKTtcbiAgdGhpcy5fc2V0T3JpZ2luYWxDdXJzb3IgPSB0aGlzLl9zZXRDdXJzb3IuYmluZCh0aGlzLCB0aGlzLl9lbGVtZW50LnN0eWxlLmN1cnNvcik7XG5cbiAgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIgPSB0aGlzLl91cGRhdGVBdHRhY2htZW50LmJpbmQodGhpcyk7XG5cbiAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignbWV0aG9kRW5hYmxlZCcsIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnRIYW5kbGVyKTtcbiAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignbWV0aG9kRGlzYWJsZWQnLCB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG4gIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2VuYWJsZWQnLCB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG4gIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc2FibGVkJywgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuXG4gIHRoaXMuX3VwZGF0ZUF0dGFjaG1lbnQoKTtcbn1cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5Db250cm9sQ3Vyc29yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RldGFjaEZyb21Db250cm9sTWV0aG9kKHRoaXMuX2NvbnRyb2xzLm1ldGhvZCh0aGlzLl9pZCkpO1xuICB0aGlzLl9zZXRPcmlnaW5hbEN1cnNvcigpO1xuXG4gIHRoaXMuX2NvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21ldGhvZEVuYWJsZWQnLFxuICAgICAgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXRob2REaXNhYmxlZCcsXG4gICAgICB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG4gIHRoaXMuX2NvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuYWJsZWQnLFxuICAgICAgdGhpcy5fdXBkYXRlQXR0YWNobWVudEhhbmRsZXIpO1xuICB0aGlzLl9jb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNhYmxlZCcsXG4gICAgICB0aGlzLl91cGRhdGVBdHRhY2htZW50SGFuZGxlcik7XG5cbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuQ29udHJvbEN1cnNvci5wcm90b3R5cGUuX3VwZGF0ZUF0dGFjaG1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRyb2xzID0gdGhpcy5fY29udHJvbHM7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuICBpZiAoY29udHJvbHMuZW5hYmxlZCgpICYmIGNvbnRyb2xzLm1ldGhvZChpZCkuZW5hYmxlZCkge1xuICAgIHRoaXMuX2F0dGFjaFRvQ29udHJvbE1ldGhvZChjb250cm9scy5tZXRob2QoaWQpKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kZXRhY2hGcm9tQ29udHJvbE1ldGhvZChjb250cm9scy5tZXRob2QoaWQpKTtcbiAgfVxufTtcblxuQ29udHJvbEN1cnNvci5wcm90b3R5cGUuX2F0dGFjaFRvQ29udHJvbE1ldGhvZCA9IGZ1bmN0aW9uKGNvbnRyb2xNZXRob2QpIHtcbiAgaWYgKCF0aGlzLl9hdHRhY2hlZCkge1xuICAgIGNvbnRyb2xNZXRob2QuaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZlJywgdGhpcy5fc2V0QWN0aXZlQ3Vyc29yKTtcbiAgICBjb250cm9sTWV0aG9kLmluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2luYWN0aXZlJywgdGhpcy5fc2V0SW5hY3RpdmVDdXJzb3IpO1xuXG4gICAgaWYgKGNvbnRyb2xNZXRob2QuYWN0aXZlKSB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVDdXJzb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0SW5hY3RpdmVDdXJzb3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hdHRhY2hlZCA9IHRydWU7XG4gIH1cbn07XG5cbkNvbnRyb2xDdXJzb3IucHJvdG90eXBlLl9kZXRhY2hGcm9tQ29udHJvbE1ldGhvZCA9IGZ1bmN0aW9uKGNvbnRyb2xNZXRob2QpIHtcbiAgaWYgKHRoaXMuX2F0dGFjaGVkKSB7XG4gICAgY29udHJvbE1ldGhvZC5pbnN0YW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdhY3RpdmUnLCB0aGlzLl9zZXRBY3RpdmVDdXJzb3IpO1xuICAgIGNvbnRyb2xNZXRob2QuaW5zdGFuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5hY3RpdmUnLCB0aGlzLl9zZXRJbmFjdGl2ZUN1cnNvcik7XG5cbiAgICB0aGlzLl9zZXREaXNhYmxlZEN1cnNvcigpO1xuXG4gICAgdGhpcy5fYXR0YWNoZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuQ29udHJvbEN1cnNvci5wcm90b3R5cGUuX3NldEN1cnNvciA9IGZ1bmN0aW9uKGN1cnNvcikge1xuICB0aGlzLl9lbGVtZW50LnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb250cm9sQ3Vyc29yO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgQ29tcG9zZXIgPSByZXF1aXJlKCcuL0NvbXBvc2VyJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIGRlYnVnID0gdHlwZW9mIE1BUlpJUEFOT0RFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBNQVJaSVBBTk9ERUJVRy5jb250cm9scztcblxuLyoqXG4gKiBAY2xhc3MgQ29udHJvbHNcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBTZXQgb2YgY29udHJvbHMgd2hpY2ggYWZmZWN0IGEgdmlldyAoZS5nLiBrZXlib2FyZCwgdG91Y2gpXG4gKlxuICoge0BsaW5rIENvbnRyb2xNZXRob2R9IGluc3RhbmNlcyBjYW4gYmUgcmVnaXN0ZXJlZCBvbiB0aGlzIGNsYXNzLiBUaGUgbWV0aG9kc1xuICogYXJlIHRoZW4gY29tYmluZWQgdG8gY2FsY3VsYXRlIHRoZSBmaW5hbCBwYXJhbWV0ZXJzIHRvIGNoYW5nZSB0aGUge0BsaW5rIFZpZXd9LlxuICpcbiAqIENvbnRyb2xzIGlzIGF0dGFjaGVkIHRvIGEge0BsaW5rIFJlbmRlckxvb3B9LiBDdXJyZW50bHkgaXQgYWZmZWN0cyB0aGVcbiAqIHtAbGluayB2aWV3fSBvZiBhbGwge0BsaW5rIExheWVyfSBvbiB0aGUge0BsaW5rIFN0YWdlfSBvZiB0aGVcbiAqIHtAbGluayBSZW5kZXJMb29wfSBpdCBpcyBhdHRhY2hlZCB0by4gQSBtb3JlIGZsZXhpYmxlIEFQSSBtYXkgYmUgcHJvdmlkZWRcbiAqIGluIHRoZSBmdXR1cmUuXG4gKlxuICogVGhlIENvbnRyb2xNZXRob2QgaW5zdGFuY2VzIGFyZSByZWdpc3RlcmVkIHdpdGggYW4gaWQgYW5kIG1heSBiZSBlbmFibGVkLFxuICogZGlzYWJsZWQgYW5kIHVucmVnaXN0ZXJlZCB1c2luZyB0aGF0IGlkLiBUaGUgd2hvbGUgQ29udHJvbCBjYW4gYWxzbyBiZVxuICogZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIENvbnRyb2xzKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdGhpcy5fbWV0aG9kcyA9IHt9O1xuICB0aGlzLl9tZXRob2RHcm91cHMgPSB7fTtcbiAgdGhpcy5fY29tcG9zZXIgPSBuZXcgQ29tcG9zZXIoKTtcblxuICAvLyBXaGV0aGVyIHRoZSBjb250cm9scyBhcmUgZW5hYmxlZC5cbiAgdGhpcy5fZW5hYmxlZCA9IChvcHRzICYmIG9wdHMuZW5hYmxlZCkgPyAhIW9wdHMuZW5hYmxlZCA6IHRydWU7XG5cbiAgLy8gSG93IG1hbnkgY29udHJvbCBtZXRob2RzIGFyZSBlbmFibGVkIGFuZCBpbiB0aGUgYWN0aXZlIHN0YXRlLlxuICB0aGlzLl9hY3RpdmVDb3VudCA9IDA7XG5cbiAgdGhpcy51cGRhdGVkVmlld3NfID0gW107XG5cbiAgdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wID0gbnVsbDtcbn1cblxuZXZlbnRFbWl0dGVyKENvbnRyb2xzKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5Db250cm9scy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRldGFjaCgpO1xuICB0aGlzLl9jb21wb3Nlci5kZXN0cm95KCk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtDb250cm9sTWV0aG9kW119IExpc3Qgb2YgcmVnaXN0ZXJlZCBAe2xpbmsgQ29udHJvbE1ldGhvZCBpbnN0YW5jZXN9XG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5tZXRob2RzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWV0aG9kcykge1xuICAgIG9ialtpZF0gPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0NvbnRyb2xNZXRob2R9XG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbihpZCkge1xuICByZXR1cm4gdGhpcy5fbWV0aG9kc1tpZF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtDb250cm9sTWV0aG9kfSBpbnN0YW5jZVxuICogQHBhcmFtIHtCb29sZWFufSBbZW5hYmxlPWZhbHNlXVxuICovXG5Db250cm9scy5wcm90b3R5cGUucmVnaXN0ZXJNZXRob2QgPSBmdW5jdGlvbihpZCwgaW5zdGFuY2UsIGVuYWJsZSkge1xuICBpZiAodGhpcy5fbWV0aG9kc1tpZF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyb2wgbWV0aG9kIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGlkICcgKyBpZCk7XG4gIH1cblxuICB0aGlzLl9tZXRob2RzW2lkXSA9IHtcbiAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBhY3RpdmVIYW5kbGVyOiB0aGlzLl9oYW5kbGVBY3RpdmUuYmluZCh0aGlzLCBpZCksXG4gICAgaW5hY3RpdmVIYW5kbGVyOiB0aGlzLl9oYW5kbGVJbmFjdGl2ZS5iaW5kKHRoaXMsIGlkKVxuICB9O1xuXG4gIGlmKGVuYWJsZSkge1xuICAgIHRoaXMuZW5hYmxlTWV0aG9kKGlkLCBpbnN0YW5jZSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLnVucmVnaXN0ZXJNZXRob2QgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250cm9sIG1ldGhvZCByZWdpc3RlcmVkIHdpdGggaWQgJyArIGlkKTtcbiAgfVxuICBpZiAobWV0aG9kLmVuYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVNZXRob2QoaWQpO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9tZXRob2RzW2lkXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5lbmFibGVNZXRob2QgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbWV0aG9kID0gdGhpcy5fbWV0aG9kc1tpZF07XG4gIGlmICghbWV0aG9kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250cm9sIG1ldGhvZCByZWdpc3RlcmVkIHdpdGggaWQgJyArIGlkKTtcbiAgfVxuICBpZiAobWV0aG9kLmVuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWV0aG9kLmVuYWJsZWQgPSB0cnVlO1xuICBpZiAobWV0aG9kLmFjdGl2ZSkge1xuICAgIHRoaXMuX2luY3JlbWVudEFjdGl2ZUNvdW50KCk7XG4gIH1cbiAgdGhpcy5fbGlzdGVuKGlkKTtcbiAgdGhpcy5fdXBkYXRlQ29tcG9zZXIoKTtcbiAgdGhpcy5lbWl0KCdtZXRob2RFbmFibGVkJywgaWQpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICovXG5Db250cm9scy5wcm90b3R5cGUuZGlzYWJsZU1ldGhvZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRyb2wgbWV0aG9kIHJlZ2lzdGVyZWQgd2l0aCBpZCAnICsgaWQpO1xuICB9XG4gIGlmICghbWV0aG9kLmVuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWV0aG9kLmVuYWJsZWQgPSBmYWxzZTtcbiAgaWYgKG1ldGhvZC5hY3RpdmUpIHtcbiAgICB0aGlzLl9kZWNyZW1lbnRBY3RpdmVDb3VudCgpO1xuICB9XG4gIHRoaXMuX3VubGlzdGVuKGlkKTtcbiAgdGhpcy5fdXBkYXRlQ29tcG9zZXIoKTtcbiAgdGhpcy5lbWl0KCdtZXRob2REaXNhYmxlZCcsIGlkKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBtZXRob2QgZ3JvdXAsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1vcmUgY29udmVuaWVudGx5IGVuYWJsZSBvclxuICogZGlzYWJsZSBzZXZlcmFsIGNvbnRyb2wgbWV0aG9kcyBhdCBvbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBJZFxuICogQHBhcmFtIHtTdHJpbmdbXX0gbWV0aG9kSWRzXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5hZGRNZXRob2RHcm91cCA9IGZ1bmN0aW9uKGdyb3VwSWQsIG1ldGhvZElkcykge1xuICB0aGlzLl9tZXRob2RHcm91cHNbZ3JvdXBJZF0gPSBtZXRob2RJZHM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWRcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLnJlbW92ZU1ldGhvZEdyb3VwID0gZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIHRoaXMuX21ldGhvZEdyb3Vwc1tpZF07XG59XG5cbi8qKlxuICogQHJldHVybiB7Q29udHJvbE1ldGhvZEdyb3VwW119IExpc3Qgb2YgY29udHJvbCBtZXRob2QgZ3JvdXBzXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5tZXRob2RHcm91cHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBmb3IgKHZhciBpZCBpbiB0aGlzLl9tZXRob2RHcm91cHMpIHtcbiAgICBvYmpbaWRdID0gdGhpcy5fbWV0aG9kR3JvdXBzW2lkXTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYWxsIHRoZSBjb250cm9sIG1ldGhvZHMgaW4gdGhlIGdyb3VwXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBJZFxuICovXG5Db250cm9scy5wcm90b3R5cGUuZW5hYmxlTWV0aG9kR3JvdXAgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX21ldGhvZEdyb3Vwc1tpZF0uZm9yRWFjaChmdW5jdGlvbihtZXRob2RJZCkge1xuICAgIHNlbGYuZW5hYmxlTWV0aG9kKG1ldGhvZElkKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRGlzYWJsZXMgYWxsIHRoZSBjb250cm9sIG1ldGhvZHMgaW4gdGhlIGdyb3VwXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBJZFxuICovXG5Db250cm9scy5wcm90b3R5cGUuZGlzYWJsZU1ldGhvZEdyb3VwID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl9tZXRob2RHcm91cHNbaWRdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kSWQpIHtcbiAgICBzZWxmLmRpc2FibGVNZXRob2QobWV0aG9kSWQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgdGhlIGNvbnRyb2xzXG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gIGlmICh0aGlzLl9hY3RpdmVDb3VudCA+IDApIHtcbiAgICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICB9XG4gIHRoaXMuZW1pdCgnZW5hYmxlZCcpO1xuICB0aGlzLl91cGRhdGVDb21wb3NlcigpO1xufTtcblxuXG4vKipcbiAqIERpc2FibGVzIHRoZSBjb250cm9sc1xuICovXG5Db250cm9scy5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICBpZiAodGhpcy5fYWN0aXZlQ291bnQgPiAwKSB7XG4gICAgdGhpcy5lbWl0KCdpbmFjdGl2ZScpO1xuICB9XG4gIHRoaXMuZW1pdCgnZGlzYWJsZWQnKTtcbiAgdGhpcy5fdXBkYXRlQ29tcG9zZXIoKTtcbn07XG5cblxuXG4vKipcbiAqIEF0dGFjaGVzIHRoZSBjb250cm9scyB0byBhIHtAbGluayBSZW5kZXJMb29wfS4gVGhlIFJlbmRlckxvb3Agd2lsbCBiZSB3b2tlblxuICogdXAgd2hlbiB0aGUgY29udHJvbHMgYXJlIGFjdGl2YXRlZFxuICpcbiAqIEBwYXJhbSB7UmVuZGVyTG9vcH1cbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKHJlbmRlckxvb3ApIHtcbiAgaWYgKHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcCkge1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gIH1cblxuICB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3AgPSByZW5kZXJMb29wO1xuICB0aGlzLl9iZWZvcmVSZW5kZXJIYW5kbGVyID0gdGhpcy5fdXBkYXRlVmlld3NXaXRoQ29udHJvbHMuYmluZCh0aGlzKTtcbiAgdGhpcy5fY2hhbmdlSGFuZGxlciA9IHJlbmRlckxvb3AucmVuZGVyT25OZXh0RnJhbWUuYmluZChyZW5kZXJMb29wKTtcblxuICB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3AuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlUmVuZGVyJywgdGhpcy5fYmVmb3JlUmVuZGVySGFuZGxlcik7XG4gIHRoaXMuX2NvbXBvc2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2NoYW5nZUhhbmRsZXIpO1xufTtcblxuLyoqXG4gKiBEZXRhY2hlcyB0aGUgY29udHJvbHNcbiAqL1xuQ29udHJvbHMucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2F0dGFjaGVkUmVuZGVyTG9vcC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVSZW5kZXInLCB0aGlzLl9iZWZvcmVSZW5kZXJIYW5kbGVyKTtcbiAgdGhpcy5fY29tcG9zZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fY2hhbmdlSGFuZGxlcik7XG5cbiAgdGhpcy5fYmVmb3JlUmVuZGVySGFuZGxlciA9IG51bGw7XG4gIHRoaXMuX2NoYW5nZUhhbmRsZXIgPSBudWxsO1xuICB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3AgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Jvb2xlYW59XG4gKi9cbkNvbnRyb2xzLnByb3RvdHlwZS5hdHRhY2hlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXR0YWNoZWRSZW5kZXJMb29wICE9IG51bGw7XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5fbGlzdGVuID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIG1ldGhvZCBpZCcpO1xuICB9XG4gIG1ldGhvZC5pbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKCdhY3RpdmUnLCBtZXRob2QuYWN0aXZlSGFuZGxlcik7XG4gIG1ldGhvZC5pbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKCdpbmFjdGl2ZScsIG1ldGhvZC5pbmFjdGl2ZUhhbmRsZXIpO1xufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX3VubGlzdGVuID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFkIG1ldGhvZCBpZCcpO1xuICB9XG4gIG1ldGhvZC5pbnN0YW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdhY3RpdmUnLCBtZXRob2QuYWN0aXZlSGFuZGxlcik7XG4gIG1ldGhvZC5pbnN0YW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdpbmFjdGl2ZScsIG1ldGhvZC5pbmFjdGl2ZUhhbmRsZXIpO1xufTtcblxuXG5Db250cm9scy5wcm90b3R5cGUuX2hhbmRsZUFjdGl2ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBtZXRob2QgaWQnKTtcbiAgfVxuICBpZiAoIW1ldGhvZC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IHJlY2VpdmUgZXZlbnQgZnJvbSBkaXNhYmxlZCBjb250cm9sIG1ldGhvZCcpO1xuICB9XG4gIGlmICghbWV0aG9kLmFjdGl2ZSkge1xuICAgIG1ldGhvZC5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2luY3JlbWVudEFjdGl2ZUNvdW50KCk7XG4gIH1cbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl9oYW5kbGVJbmFjdGl2ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXRob2QgPSB0aGlzLl9tZXRob2RzW2lkXTtcbiAgaWYgKCFtZXRob2QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBtZXRob2QgaWQnKTtcbiAgfVxuICBpZiAoIW1ldGhvZC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IHJlY2VpdmUgZXZlbnQgZnJvbSBkaXNhYmxlZCBjb250cm9sIG1ldGhvZCcpO1xuICB9XG4gIGlmIChtZXRob2QuYWN0aXZlKSB7XG4gICAgbWV0aG9kLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2RlY3JlbWVudEFjdGl2ZUNvdW50KCk7XG4gIH1cbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl9pbmNyZW1lbnRBY3RpdmVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9hY3RpdmVDb3VudCsrO1xuICBpZiAoZGVidWcpIHtcbiAgICB0aGlzLl9jaGVja0FjdGl2ZUNvdW50KCk7XG4gIH1cbiAgaWYgKHRoaXMuX2VuYWJsZWQgJiYgdGhpcy5fYWN0aXZlQ291bnQgPT09IDEpIHtcbiAgICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5fZGVjcmVtZW50QWN0aXZlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYWN0aXZlQ291bnQtLTtcbiAgaWYgKGRlYnVnKSB7XG4gICAgdGhpcy5fY2hlY2tBY3RpdmVDb3VudCgpO1xuICB9XG4gIGlmICh0aGlzLl9lbmFibGVkICYmIHRoaXMuX2FjdGl2ZUNvdW50ID09PSAwKSB7XG4gICAgdGhpcy5lbWl0KCdpbmFjdGl2ZScpO1xuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5fY2hlY2tBY3RpdmVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY291bnQgPSAwO1xuICBmb3IgKHZhciBpZCBpbiB0aGlzLl9tZXRob2RzKSB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICAgIGlmIChtZXRob2QuZW5hYmxlZCAmJiBtZXRob2QuYWN0aXZlKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuICBpZiAoY291bnQgIT0gdGhpcy5fYWN0aXZlQ291bnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBjb250cm9sIHN0YXRlJyk7XG4gIH1cbn07XG5cblxuQ29udHJvbHMucHJvdG90eXBlLl91cGRhdGVDb21wb3NlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29tcG9zZXIgPSB0aGlzLl9jb21wb3NlcjtcblxuICBmb3IgKHZhciBpZCBpbiB0aGlzLl9tZXRob2RzKSB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMuX21ldGhvZHNbaWRdO1xuICAgIHZhciBlbmFibGVkID0gdGhpcy5fZW5hYmxlZCAmJiBtZXRob2QuZW5hYmxlZDtcblxuICAgIGlmIChlbmFibGVkICYmICFjb21wb3Nlci5oYXMobWV0aG9kLmluc3RhbmNlKSkge1xuICAgICAgY29tcG9zZXIuYWRkKG1ldGhvZC5pbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICghZW5hYmxlZCAmJiBjb21wb3Nlci5oYXMobWV0aG9kLmluc3RhbmNlKSkge1xuICAgICAgY29tcG9zZXIucmVtb3ZlKG1ldGhvZC5pbnN0YW5jZSk7XG4gICAgfVxuICB9XG59O1xuXG5cbkNvbnRyb2xzLnByb3RvdHlwZS5fdXBkYXRlVmlld3NXaXRoQ29udHJvbHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRyb2xEYXRhID0gdGhpcy5fY29tcG9zZXIub2Zmc2V0cygpO1xuICBpZiAoY29udHJvbERhdGEuY2hhbmdpbmcpIHtcbiAgICB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3AucmVuZGVyT25OZXh0RnJhbWUoKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBlYWNoIHZpZXcgYXQgbW9zdCBvbmNlLCBldmVuIHdoZW4gc2hhcmVkIGJ5IG11bHRpcGxlIGxheWVycy5cbiAgLy8gVGhlIG51bWJlciBvZiB2aWV3cyBpcyBleHBlY3RlZCB0byBiZSBzbWFsbCwgc28gdXNlIGFuIGFycmF5IHRvIGtlZXAgdHJhY2suXG4gIHRoaXMudXBkYXRlZFZpZXdzXy5sZW5ndGggPSAwO1xuXG4gIHZhciBsYXllcnMgPSB0aGlzLl9hdHRhY2hlZFJlbmRlckxvb3Auc3RhZ2UoKS5saXN0TGF5ZXJzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZpZXcgPSBsYXllcnNbaV0udmlldygpO1xuICAgIGlmICh0aGlzLnVwZGF0ZWRWaWV3c18uaW5kZXhPZih2aWV3KSA8IDApIHtcbiAgICAgIGxheWVyc1tpXS52aWV3KCkudXBkYXRlV2l0aENvbnRyb2xQYXJhbWV0ZXJzKGNvbnRyb2xEYXRhLm9mZnNldHMpO1xuICAgICAgdGhpcy51cGRhdGVkVmlld3NfLnB1c2godmlldyk7XG4gICAgfVxuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbHM7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBIYW1tZXJHZXN0dXJlcyA9IHJlcXVpcmUoJy4vSGFtbWVyR2VzdHVyZXMnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBtYXhGcmljdGlvbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm1heEZyaWN0aW9uO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZnJpY3Rpb246IDYsXG4gIG1heEZyaWN0aW9uVGltZTogMC4zLFxuICBoYW1tZXJFdmVudDogJ3Bhbidcbn07XG5cbnZhciBkZWJ1ZyA9IHR5cGVvZiBNQVJaSVBBTk9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgTUFSWklQQU5PREVCVUcuY29udHJvbHM7XG5cbi8qKlxuICogQGNsYXNzIERyYWdDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ29udHJvbHMgdGhlIHZpZXcgYnkgY2xpY2tpbmcvdGFwcGluZyBhbmQgZHJhZ2dpbmcuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbGlzdGVuIGZvciBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9pbnRlclR5cGUgV2hpY2ggSGFtbWVyLmpzIHBvaW50ZXIgdHlwZSB0byB1c2UgKGUuZy5cbiAqIGBtb3VzZWAgb3IgYHRvdWNoYCkuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZnJpY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLm1heEZyaWN0aW9uVGltZVxuICogQHBhcmFtIHsncGFuJ3wncGluY2gnfSBvcHRzLmhhbW1lckV2ZW50XG4gKi9cbmZ1bmN0aW9uIERyYWdDb250cm9sTWV0aG9kKGVsZW1lbnQsIHBvaW50ZXJUeXBlLCBvcHRzKSB7XG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHRoaXMuX29wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG5cbiAgdGhpcy5fc3RhcnRFdmVudCA9IG51bGw7XG4gIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5fZHluYW1pY3MgPSB7XG4gICAgeDogbmV3IER5bmFtaWNzKCksXG4gICAgeTogbmV3IER5bmFtaWNzKClcbiAgfTtcblxuICB0aGlzLl9oYW1tZXIgPSBIYW1tZXJHZXN0dXJlcy5nZXQoZWxlbWVudCwgcG9pbnRlclR5cGUpO1xuXG4gIHRoaXMuX2hhbW1lci5vbihcImhhbW1lci5pbnB1dFwiLCB0aGlzLl9oYW5kbGVIYW1tZXJFdmVudC5iaW5kKHRoaXMpKTtcblxuICBpZiAodGhpcy5fb3B0cy5oYW1tZXJFdmVudCAhPSAncGFuJyAmJiB0aGlzLl9vcHRzLmhhbW1lckV2ZW50ICE9ICdwaW5jaCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3B0cy5oYW1tZXJFdmVudCArICcgaXMgbm90IGEgaGFtbWVyRXZlbnQgbWFuYWdlZCBpbiBEcmFnQ29udHJvbE1ldGhvZCcpO1xuICB9XG5cbiAgdGhpcy5faGFtbWVyLm9uKHRoaXMuX29wdHMuaGFtbWVyRXZlbnQgKyAnc3RhcnQnLCB0aGlzLl9oYW5kbGVTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKHRoaXMuX29wdHMuaGFtbWVyRXZlbnQgKyAnbW92ZScsIHRoaXMuX2hhbmRsZU1vdmUuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbih0aGlzLl9vcHRzLmhhbW1lckV2ZW50ICsgJ2VuZCcsIHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKHRoaXMuX29wdHMuaGFtbWVyRXZlbnQgKyAnY2FuY2VsJywgdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcykpO1xufVxuXG5ldmVudEVtaXR0ZXIoRHJhZ0NvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2hhbW1lci5yZWxlYXNlKCk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlSGFtbWVyRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gIGlmIChlLmlzRmlyc3QpIHtcbiAgICBpZiAoZGVidWcgJiYgdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdDb250cm9sTWV0aG9kIGFjdGl2ZSBkZXRlY3RlZCB3aGVuIGFscmVhZHkgYWN0aXZlJyk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxuICBpZiAoZS5pc0ZpbmFsKSB7XG4gICAgaWYgKGRlYnVnICYmICF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ0NvbnRyb2xNZXRob2QgaW5hY3RpdmUgZGV0ZWN0ZWQgd2hlbiBhbHJlYWR5IGluYWN0aXZlJyk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxufTtcblxuRHJhZ0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVTdGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCB0aGlzIGV2ZW50IGZyb20gZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzLCBjYXVzaW5nXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igb24gQ2hyb21lLlxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdGhpcy5fc3RhcnRFdmVudCA9IGU7XG59O1xuXG5cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCB0aGlzIGV2ZW50IGZyb20gZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzLCBjYXVzaW5nXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igb24gQ2hyb21lLlxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgaWYgKHRoaXMuX3N0YXJ0RXZlbnQpIHtcbiAgICB0aGlzLl91cGRhdGVEeW5hbWljc01vdmUoZSk7XG4gICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICdheGlzU2NhbGVkWCcsIHRoaXMuX2R5bmFtaWNzLngpO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnYXhpc1NjYWxlZFknLCB0aGlzLl9keW5hbWljcy55KTtcbiAgfVxufTtcblxuXG5EcmFnQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUVuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCB0aGlzIGV2ZW50IGZyb20gZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzLCBjYXVzaW5nXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3Igb24gQ2hyb21lLlxuICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgaWYgKHRoaXMuX3N0YXJ0RXZlbnQpIHtcbiAgICB0aGlzLl91cGRhdGVEeW5hbWljc1JlbGVhc2UoZSk7XG4gICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICdheGlzU2NhbGVkWCcsIHRoaXMuX2R5bmFtaWNzLngpO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnYXhpc1NjYWxlZFknLCB0aGlzLl9keW5hbWljcy55KTtcbiAgfVxuXG4gIHRoaXMuX3N0YXJ0RXZlbnQgPSBmYWxzZTtcbiAgdGhpcy5fbGFzdEV2ZW50ID0gZmFsc2U7XG59O1xuXG5cbkRyYWdDb250cm9sTWV0aG9kLnByb3RvdHlwZS5fdXBkYXRlRHluYW1pY3NNb3ZlID0gZnVuY3Rpb24oZSkge1xuICB2YXIgeCA9IGUuZGVsdGFYO1xuICB2YXIgeSA9IGUuZGVsdGFZO1xuXG4gIC8vIFdoZW4gYSBzZWNvbmQgZmluZ2VyIHRvdWNoZXMgdGhlIHNjcmVlbiwgcGFuc3RhcnQgc29tZXRpbWVzIGhhcyBhIGxhcmdlXG4gIC8vIG9mZnNldCBhdCBzdGFydDsgc3VidHJhY3QgdGhhdCBvZmZzZXQgdG8gcHJldmVudCBhIHN1ZGRlbiBqdW1wLlxuICB2YXIgZXZlbnRUb1N1YnRyYWN0ID0gdGhpcy5fbGFzdEV2ZW50IHx8IHRoaXMuX3N0YXJ0RXZlbnQ7XG5cbiAgaWYgKGV2ZW50VG9TdWJ0cmFjdCkge1xuICAgIHggLT0gZXZlbnRUb1N1YnRyYWN0LmRlbHRhWDtcbiAgICB5IC09IGV2ZW50VG9TdWJ0cmFjdC5kZWx0YVk7XG4gIH1cblxuICB2YXIgZWxlbWVudFJlY3QgPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgd2lkdGggPSBlbGVtZW50UmVjdC5yaWdodCAtIGVsZW1lbnRSZWN0LmxlZnQ7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50UmVjdC5ib3R0b20gLSBlbGVtZW50UmVjdC50b3A7XG5cbiAgeCAvPSB3aWR0aDtcbiAgeSAvPSBoZWlnaHQ7XG5cbiAgdGhpcy5fZHluYW1pY3MueC5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy55LnJlc2V0KCk7XG4gIHRoaXMuX2R5bmFtaWNzLngub2Zmc2V0ID0gLXg7XG4gIHRoaXMuX2R5bmFtaWNzLnkub2Zmc2V0ID0gLXk7XG5cbiAgdGhpcy5fbGFzdEV2ZW50ID0gZTtcbn07XG5cblxudmFyIHRtcFJlbGVhc2VGcmljdGlvbiA9IFsgbnVsbCwgbnVsbCBdO1xuRHJhZ0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl91cGRhdGVEeW5hbWljc1JlbGVhc2UgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBlbGVtZW50UmVjdCA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB3aWR0aCA9IGVsZW1lbnRSZWN0LnJpZ2h0IC0gZWxlbWVudFJlY3QubGVmdDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnRSZWN0LmJvdHRvbSAtIGVsZW1lbnRSZWN0LnRvcDtcblxuICB2YXIgeCA9IDEwMDAgKiBlLnZlbG9jaXR5WCAvIHdpZHRoO1xuICB2YXIgeSA9IDEwMDAgKiBlLnZlbG9jaXR5WSAvIGhlaWdodDtcblxuICB0aGlzLl9keW5hbWljcy54LnJlc2V0KCk7XG4gIHRoaXMuX2R5bmFtaWNzLnkucmVzZXQoKTtcbiAgdGhpcy5fZHluYW1pY3MueC52ZWxvY2l0eSA9IHg7XG4gIHRoaXMuX2R5bmFtaWNzLnkudmVsb2NpdHkgPSB5O1xuXG4gIG1heEZyaWN0aW9uKHRoaXMuX29wdHMuZnJpY3Rpb24sIHRoaXMuX2R5bmFtaWNzLngudmVsb2NpdHksIHRoaXMuX2R5bmFtaWNzLnkudmVsb2NpdHksIHRoaXMuX29wdHMubWF4RnJpY3Rpb25UaW1lLCB0bXBSZWxlYXNlRnJpY3Rpb24pO1xuICB0aGlzLl9keW5hbWljcy54LmZyaWN0aW9uID0gdG1wUmVsZWFzZUZyaWN0aW9uWzBdO1xuICB0aGlzLl9keW5hbWljcy55LmZyaWN0aW9uID0gdG1wUmVsZWFzZUZyaWN0aW9uWzFdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWdDb250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzcyBEeW5hbWljc1xuICogQGNsYXNzZGVzY1xuICpcbiAqIFJlcHJlc2VudHMgaG93IGEgY29udHJvbCBwYXJhbWV0ZXIgY2hhbmdlcy4gVXNlZCBpbiB0aGUgZXZlbnRzIGVtaXR0ZWQgYnlcbiAqIHtAbGluayBDb250cm9sTWV0aG9kfS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0IFBhcmFtZXRlciBjaGFuZ2VkIGJ5IGEgZml4ZWQgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2ZWxvY2l0eSBQYXJhbWV0ZXIgaXMgY2hhbmdpbmcgYXQgdGhpcyB2ZWxvY2l0eVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZyaWN0aW9uIFRoZSB2ZWxvY2l0eSB3aWxsIGRlY3JlYXNlIGF0IHRoaXMgcmF0ZVxuICovXG5mdW5jdGlvbiBEeW5hbWljcygpIHtcbiAgdGhpcy52ZWxvY2l0eSA9IG51bGw7XG4gIHRoaXMuZnJpY3Rpb24gPSBudWxsO1xuICB0aGlzLm9mZnNldCA9IG51bGw7XG59XG5cbkR5bmFtaWNzLmVxdWFscyA9IGZ1bmN0aW9uKGQxLCBkMikge1xuICByZXR1cm4gZDEudmVsb2NpdHkgPT09IGQyLnZlbG9jaXR5ICYmIGQxLmZyaWN0aW9uID09PSBkMi5mcmljdGlvbiAmJiBkMS5vZmZzZXQgPT09IGQyLm9mZnNldDtcbn07XG5cbkR5bmFtaWNzLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICByZXR1cm4gRHluYW1pY3MuZXF1YWxzKHRoaXMsIG90aGVyKTtcbn07XG5cbkR5bmFtaWNzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvdGhlciwgZWxhcHNlZCkge1xuICBpZiAob3RoZXIub2Zmc2V0KSB7XG4gICAgLy8gSWYgb3RoZXIgaGFzIGFuIG9mZnNldCwgbWFrZSB0aGlzLm9mZnNldCBhIG51bWJlciBpbnN0ZWFkIG9mIG51bGxcbiAgICB0aGlzLm9mZnNldCA9IHRoaXMub2Zmc2V0IHx8IDA7XG4gICAgdGhpcy5vZmZzZXQgKz0gb3RoZXIub2Zmc2V0O1xuICB9XG5cbiAgdmFyIG9mZnNldEZyb21WZWxvY2l0eSA9IHRoaXMub2Zmc2V0RnJvbVZlbG9jaXR5KGVsYXBzZWQpO1xuICBpZiAob2Zmc2V0RnJvbVZlbG9jaXR5KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gb2Zmc2V0IHRvIGFkZCBmcm9tIHRoZSB2ZWxvY2l0eSwgbWFrZSB0aGlzIG9mZnNldCBhIG51bWJlciBpbnN0ZWFkIG9mIG51bGxcbiAgICB0aGlzLm9mZnNldCA9IHRoaXMub2Zmc2V0IHx8IDA7XG4gICAgdGhpcy5vZmZzZXQgKz0gb2Zmc2V0RnJvbVZlbG9jaXR5O1xuICB9XG5cbiAgdGhpcy52ZWxvY2l0eSA9IG90aGVyLnZlbG9jaXR5O1xuICB0aGlzLmZyaWN0aW9uID0gb3RoZXIuZnJpY3Rpb247XG59O1xuXG5EeW5hbWljcy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy52ZWxvY2l0eSA9IG51bGw7XG4gIHRoaXMuZnJpY3Rpb24gPSBudWxsO1xuICB0aGlzLm9mZnNldCA9IG51bGw7XG59O1xuXG5cbkR5bmFtaWNzLnByb3RvdHlwZS52ZWxvY2l0eUFmdGVyID0gZnVuY3Rpb24oZWxhcHNlZCkge1xuICBpZiAoIXRoaXMudmVsb2NpdHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5mcmljdGlvbikge1xuICAgIHJldHVybiBkZWNyZWFzZUFicyh0aGlzLnZlbG9jaXR5LCB0aGlzLmZyaWN0aW9uICplbGFwc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcy52ZWxvY2l0eTtcbn07XG5cbkR5bmFtaWNzLnByb3RvdHlwZS5vZmZzZXRGcm9tVmVsb2NpdHkgPSBmdW5jdGlvbihlbGFwc2VkKSB7XG4gIGVsYXBzZWQgPSBNYXRoLm1pbihlbGFwc2VkLCB0aGlzLm51bGxWZWxvY2l0eVRpbWUoKSk7XG5cbiAgdmFyIHZlbG9jaXR5RW5kID0gdGhpcy52ZWxvY2l0eUFmdGVyKGVsYXBzZWQpO1xuICB2YXIgYXZlcmFnZVZlbG9jaXR5ID0gKHRoaXMudmVsb2NpdHkgKyB2ZWxvY2l0eUVuZCkgLyAyO1xuXG4gIHJldHVybiBhdmVyYWdlVmVsb2NpdHkgKiBlbGFwc2VkO1xufTtcblxuXG5EeW5hbWljcy5wcm90b3R5cGUubnVsbFZlbG9jaXR5VGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy52ZWxvY2l0eSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRoaXMudmVsb2NpdHkgJiYgIXRoaXMuZnJpY3Rpb24pIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbiAgcmV0dXJuIE1hdGguYWJzKHRoaXMudmVsb2NpdHkgLyB0aGlzLmZyaWN0aW9uKTtcbn07XG5cbmZ1bmN0aW9uIGRlY3JlYXNlQWJzKG51bSwgZGVjKSB7XG4gIGlmIChudW0gPCAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKDAsIG51bSArIGRlYyk7XG4gIH1cbiAgaWYgKG51bSA+IDApIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbnVtIC0gZGVjKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEeW5hbWljcztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIER5bmFtaWNzID0gcmVxdWlyZSgnLi9EeW5hbWljcycpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbi8qKlxuICogQGNsYXNzIEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBTZXRzIHRoZSB2ZWxvY2l0eSBhbmQgZnJpY3Rpb24gb2YgYSBzaW5nbGUgcGFyYW1ldGVyIGJ5IHByZXNzaW5nIGFuZFxuICogdW5wcmVzc2luZyBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHdoaWNoIGFjdGl2YXRlcyB0aGUgbWV0aG9kIHdoZW4gcHJlc3NlZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlciBUaGUgcGFyYW1ldGVyIHRvIGJlIGNvbnRyb2xsZWQgKGUuZy4gYHhgLCBgeWAgb3IgYHpvb21gKVxuICogQHBhcmFtIHtudW1iZXJ9IHZlbG9jaXR5IFZlbG9jaXR5IGF0IHdoaWNoIHRoZSBwYXJhbWV0ZXIgY2hhbmdlcy4gVXNlIGFcbiAqIG5lZ2F0aXZlIG51bWJlciBmb3Igb3Bwb3NpdGUgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJpY3Rpb24gRnJpY3Rpb24gYXQgd2hpY2ggdGhlIHBhcmFtZXRlciBzdG9wc1xuKi9cbmZ1bmN0aW9uIEVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QoZWxlbWVudCwgcGFyYW1ldGVyLCB2ZWxvY2l0eSwgZnJpY3Rpb24pIHtcbiAgaWYoIWVsZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50UHJlc3NDb250cm9sTWV0aG9kOiBlbGVtZW50IG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICBpZighcGFyYW1ldGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogcGFyYW1ldGVyIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICBpZighdmVsb2NpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50UHJlc3NDb250cm9sTWV0aG9kOiB2ZWxvY2l0eSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIWZyaWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogZnJpY3Rpb24gbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG5cbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgdGhpcy5fcHJlc3NIYW5kbGVyID0gdGhpcy5faGFuZGxlUHJlc3MuYmluZCh0aGlzKTtcbiAgdGhpcy5fcmVsZWFzZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVSZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9wcmVzc0hhbmRsZXIpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fcHJlc3NIYW5kbGVyKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9yZWxlYXNlSGFuZGxlcik7XG5cbiAgdGhpcy5fcGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICB0aGlzLl92ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICB0aGlzLl9mcmljdGlvbiA9IGZyaWN0aW9uO1xuICB0aGlzLl9keW5hbWljcyA9IG5ldyBEeW5hbWljcygpO1xuXG4gIHRoaXMuX3ByZXNzaW5nID0gZmFsc2U7XG59XG5ldmVudEVtaXR0ZXIoRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX3ByZXNzSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fcmVsZWFzZUhhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9wcmVzc0hhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3JlbGVhc2VIYW5kbGVyKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZVByZXNzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3ByZXNzaW5nID0gdHJ1ZTtcblxuICB0aGlzLl9keW5hbWljcy52ZWxvY2l0eSA9IHRoaXMuX3ZlbG9jaXR5O1xuICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IDA7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbiAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbn07XG5cbkVsZW1lbnRQcmVzc0NvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVSZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuX3ByZXNzaW5nKSB7XG4gICAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSB0aGlzLl9mcmljdGlvbjtcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gICAgdGhpcy5lbWl0KCdpbmFjdGl2ZScpO1xuICB9XG5cbiAgdGhpcy5fcHJlc3NpbmcgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEhhbW1lciA9IHJlcXVpcmUoJ2hhbW1lcmpzJyk7XG5cbnZhciBuZXh0SWQgPSAxO1xudmFyIGlkUHJvcGVydHkgPSAnTWFyemlwYW5vSGFtbWVyRWxlbWVudElkJztcbmZ1bmN0aW9uIGdldEtleUZvckVsZW1lbnRBbmRUeXBlKGVsZW1lbnQsIHR5cGUpIHtcbiAgaWYgKCFlbGVtZW50W2lkUHJvcGVydHldKSB7XG4gICAgZWxlbWVudFtpZFByb3BlcnR5XSA9IG5leHRJZCsrO1xuICB9XG4gIHJldHVybiB0eXBlICsgZWxlbWVudFtpZFByb3BlcnR5XTtcbn1cblxuXG4vKipcbiAqIEBjbGFzcyBIYW1tZXJHZXN0dXJlc1xuICogQGNsYXNzZGVzY1xuICpcbiAqIE1hbmFnZXMgSGFtbWVyLmpzIGluc3RhbmNlcy4gT25lIGluc3RhbmNlIGlzIGNyZWF0ZWQgZm9yIGVhY2ggY29tYmluYXRpb24gb2ZcbiAqIERPTSBlbGVtZW50IGFuZCBwb2ludGVyIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIEhhbW1lckdlc3R1cmVzKCkge1xuICB0aGlzLl9tYW5hZ2VycyA9IHt9O1xuICB0aGlzLl9yZWZDb3VudCA9IHt9O1xufVxuXG5cbkhhbW1lckdlc3R1cmVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG4gIHZhciBrZXkgPSBnZXRLZXlGb3JFbGVtZW50QW5kVHlwZShlbGVtZW50LCB0eXBlKTtcbiAgaWYgKCF0aGlzLl9tYW5hZ2Vyc1trZXldKSB7XG4gICAgdGhpcy5fbWFuYWdlcnNba2V5XSA9IHRoaXMuX2NyZWF0ZU1hbmFnZXIoZWxlbWVudCwgdHlwZSk7XG4gICAgdGhpcy5fcmVmQ291bnRba2V5XSA9IDA7XG4gIH1cbiAgdGhpcy5fcmVmQ291bnRba2V5XSsrO1xuICByZXR1cm4gbmV3IEhhbW1lckdlc3R1cmVzSGFuZGxlKHRoaXMsIHRoaXMuX21hbmFnZXJzW2tleV0sIGVsZW1lbnQsIHR5cGUpO1xufTtcblxuXG5IYW1tZXJHZXN0dXJlcy5wcm90b3R5cGUuX2NyZWF0ZU1hbmFnZXIgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG4gIHZhciBtYW5hZ2VyID0gbmV3IEhhbW1lci5NYW5hZ2VyKGVsZW1lbnQpO1xuXG4gIC8vIE1hbmFnZXJzIGFyZSBjcmVhdGVkIHdpdGggZGlmZmVyZW50IHBhcmFtZXRlcnMgZm9yIGRpZmZlcmVudCBwb2ludGVyXG4gIC8vIHR5cGVzLlxuICBpZiAodHlwZSA9PT0gJ21vdXNlJykge1xuICAgIG1hbmFnZXIuYWRkKG5ldyBIYW1tZXIuUGFuKHsgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTCwgdGhyZXNob2xkOiAwIH0pKTtcbiAgfVxuICBlbHNlIGlmICh0eXBlID09PSAndG91Y2gnIHx8IHR5cGUgPT09ICdwZW4nIHx8IHR5cGUgPT09ICdraW5lY3QnKSB7XG4gICAgLy8gT24gdG91Y2ggb25lIHdhbnRzIHRvIGhhdmUgYm90aCBwYW5uaW5nIGFuZCBwaW5jaGluZy4gVGhlIHBhbm5pbmdcbiAgICAvLyByZWNvZ25pemVyIG5lZWRzIGEgdGhyZXNob2xkIHRvIGFsbG93IHRoZSBwaW5jaCB0byBiZSByZWNvZ25pemVkLlxuICAgIG1hbmFnZXIuYWRkKG5ldyBIYW1tZXIuUGFuKHsgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTCwgdGhyZXNob2xkOiAyMCwgcG9pbnRlcnM6IDEgfSkpO1xuICAgIG1hbmFnZXIuYWRkKG5ldyBIYW1tZXIuUGluY2goKSk7XG4gIH1cblxuICByZXR1cm4gbWFuYWdlcjtcbn07XG5cblxuSGFtbWVyR2VzdHVyZXMucHJvdG90eXBlLl9yZWxlYXNlSGFuZGxlID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuICB2YXIga2V5ID0gZ2V0S2V5Rm9yRWxlbWVudEFuZFR5cGUoZWxlbWVudCwgdHlwZSk7XG4gIGlmICh0aGlzLl9yZWZDb3VudFtrZXldKSB7XG4gICAgdGhpcy5fcmVmQ291bnRba2V5XS0tO1xuICAgIGlmICghdGhpcy5fcmVmQ291bnRba2V5XSkge1xuICAgICAgdGhpcy5fbWFuYWdlcnNba2V5XS5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgdGhpcy5fbWFuYWdlcnNba2V5XTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9yZWZDb3VudFtrZXldO1xuICAgIH1cbiAgfVxufTtcblxuXG5mdW5jdGlvbiBIYW1tZXJHZXN0dXJlc0hhbmRsZShoYW1tZXJHZXN0dXJlcywgbWFuYWdlciwgZWxlbWVudCwgdHlwZSkge1xuICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3R5cGUgPSB0eXBlO1xuICB0aGlzLl9oYW1tZXJHZXN0dXJlcyA9IGhhbW1lckdlc3R1cmVzO1xuICB0aGlzLl9ldmVudEhhbmRsZXJzID0gW107XG59XG5cblxuSGFtbWVyR2VzdHVyZXNIYW5kbGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgdmFyIGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodHlwZSA9PT0gZS5wb2ludGVyVHlwZSkge1xuICAgICAgaGFuZGxlcihlKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5fZXZlbnRIYW5kbGVycy5wdXNoKHsgZXZlbnRzOiBldmVudHMsIGhhbmRsZXI6IGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyB9KTtcbiAgdGhpcy5fbWFuYWdlci5vbihldmVudHMsIGhhbmRsZXJGaWx0ZXJlZEV2ZW50cyk7XG59O1xuXG5cbkhhbW1lckdlc3R1cmVzSGFuZGxlLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldmVudEhhbmRsZXIgPSB0aGlzLl9ldmVudEhhbmRsZXJzW2ldO1xuICAgIHRoaXMuX21hbmFnZXIub2ZmKGV2ZW50SGFuZGxlci5ldmVudHMsIGV2ZW50SGFuZGxlci5oYW5kbGVyKTtcbiAgfVxuXG4gIHRoaXMuX2hhbW1lckdlc3R1cmVzLl9yZWxlYXNlSGFuZGxlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3R5cGUpO1xuICB0aGlzLl9tYW5hZ2VyID0gbnVsbDtcbiAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIHRoaXMuX3R5cGUgPSBudWxsO1xuICB0aGlzLl9oYW1tZXJHZXN0dXJlcyA9IG51bGw7XG59O1xuXG5cbkhhbW1lckdlc3R1cmVzSGFuZGxlLnByb3RvdHlwZS5tYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tYW5hZ2VyO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBIYW1tZXJHZXN0dXJlcygpO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgS2V5Q29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIFNldHMgdGhlIHZlbG9jaXR5IGFuZCBmcmljdGlvbiBvZiBhIHNpbmdsZSBwYXJhbWV0ZXIgYnkgcHJlc3NpbmcgYW5kXG4gKiB1bnByZXNzaW5nIGEga2V5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBrZXlDb2RlIEtleSB3aGljaCBhY3RpdmF0ZXMgdGhlIG1ldGhvZCB3aGVuIHByZXNzZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXIgVGhlIHBhcmFtZXRlciB0byBiZSBjb250cm9sbGVkIChlLmcuIGB4YCwgYHlgIG9yIGB6b29tYClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZWxvY2l0eSBWZWxvY2l0eSBhdCB3aGljaCB0aGUgcGFyYW1ldGVyIGNoYW5nZXMuIFVzZSBhXG4gKiBuZWdhdGl2ZSBudW1iZXIgZm9yIG9wcG9zaXRlIGRpcmVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZyaWN0aW9uIEZyaWN0aW9uIGF0IHdoaWNoIHRoZSBwYXJhbWV0ZXIgc3RvcHNcbiAqIEBwYXJhbSB7RWxlbWVudH0gW2VsZW1lbnQ9ZG9jdW1lbnRdIERPTSBlbGVtZW50IHdoZXJlIHRoZSBrZXkgZXZlbnRzIGFyZSBsaXN0ZW5lZCB0b1xuICovXG5mdW5jdGlvbiBLZXlDb250cm9sTWV0aG9kKGtleUNvZGUsIHBhcmFtZXRlciwgdmVsb2NpdHksIGZyaWN0aW9uLCBlbGVtZW50KSB7XG4gIGlmKCFrZXlDb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5Q29udHJvbE1ldGhvZDoga2V5Q29kZSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXBhcmFtZXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleUNvbnRyb2xNZXRob2Q6IHBhcmFtZXRlciBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgaWYoIXZlbG9jaXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5Q29udHJvbE1ldGhvZDogdmVsb2NpdHkgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGlmKCFmcmljdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIktleUNvbnRyb2xNZXRob2Q6IGZyaWN0aW9uIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBlbGVtZW50IHx8IGRvY3VtZW50O1xuXG4gIHRoaXMuX2tleUNvZGUgPSBrZXlDb2RlO1xuICB0aGlzLl9wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG4gIHRoaXMuX3ZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIHRoaXMuX2ZyaWN0aW9uID0gZnJpY3Rpb247XG4gIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlUHJlc3MuYmluZCh0aGlzKTtcbiAgdGhpcy5fa2V5dXBIYW5kbGVyID0gdGhpcy5faGFuZGxlUmVsZWFzZS5iaW5kKHRoaXMpO1xuICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKTtcblxuICB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duSGFuZGxlcik7XG4gIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9rZXl1cEhhbmRsZXIpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JsdXJIYW5kbGVyKTtcblxuICB0aGlzLl9keW5hbWljcyA9IG5ldyBEeW5hbWljcygpO1xuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufVxuZXZlbnRFbWl0dGVyKEtleUNvbnRyb2xNZXRob2QpO1xuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fa2V5ZG93bkhhbmRsZXIpO1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5dXBIYW5kbGVyKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ibHVySGFuZGxlcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVQcmVzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYoZS5rZXlDb2RlICE9PSB0aGlzLl9rZXlDb2RlKSB7IHJldHVybjsgfVxuXG4gIHRoaXMuX3ByZXNzaW5nID0gdHJ1ZTtcblxuICB0aGlzLl9keW5hbWljcy52ZWxvY2l0eSA9IHRoaXMuX3ZlbG9jaXR5O1xuICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IDA7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbiAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbn07XG5cbktleUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVSZWxlYXNlID0gZnVuY3Rpb24oZSkge1xuICBpZihlLmtleUNvZGUgIT09IHRoaXMuX2tleUNvZGUpIHsgcmV0dXJuOyB9XG5cbiAgaWYodGhpcy5fcHJlc3NpbmcpIHtcbiAgICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IHRoaXMuX2ZyaWN0aW9uO1xuICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCB0aGlzLl9wYXJhbWV0ZXIsIHRoaXMuX2R5bmFtaWNzKTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cblxuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufTtcblxuS2V5Q29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZUJsdXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSAwO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG4gIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcblxuICB0aGlzLl9wcmVzc2luZyA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlDb250cm9sTWV0aG9kO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbWluaW1hbC1ldmVudC1lbWl0dGVyJyk7XG52YXIgRHluYW1pY3MgPSByZXF1aXJlKCcuL0R5bmFtaWNzJyk7XG52YXIgSGFtbWVyR2VzdHVyZXMgPSByZXF1aXJlKCcuL0hhbW1lckdlc3R1cmVzJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3MgUGluY2hab29tQ29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIENvbnRyb2wgdGhlIHZpZXcgZm92L3pvb20gYnkgcGluY2hpbmcgd2l0aCB0d28gZmluZ2Vycy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2ludGVyVHlwZSBXaGljaCBIYW1tZXIuanMgcG9pbnRlciB0eXBlIHRvIHVzZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuZnVuY3Rpb24gUGluY2hab29tQ29udHJvbE1ldGhvZChlbGVtZW50LCBwb2ludGVyVHlwZSwgb3B0cykge1xuICB0aGlzLl9oYW1tZXIgPSBIYW1tZXJHZXN0dXJlcy5nZXQoZWxlbWVudCwgcG9pbnRlclR5cGUpO1xuXG4gIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgdGhpcy5fZHluYW1pY3MgPSBuZXcgRHluYW1pY3MoKTtcblxuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoc3RhcnQnLCB0aGlzLl9oYW5kbGVTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5faGFtbWVyLm9uKCdwaW5jaCcsIHRoaXMuX2hhbmRsZUV2ZW50LmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoZW5kJywgdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BpbmNoY2FuY2VsJywgdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcykpO1xufVxuXG5ldmVudEVtaXR0ZXIoUGluY2hab29tQ29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuUGluY2hab29tQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW1tZXIucmVsZWFzZSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblBpbmNoWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLl9oYW5kbGVTdGFydCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxufTtcblxuXG5QaW5jaFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbiAgfVxufTtcblxuXG5QaW5jaFpvb21Db250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBzY2FsZSA9IGUuc2NhbGU7XG5cbiAgaWYgKHRoaXMuX2xhc3RFdmVudCkge1xuICAgIHNjYWxlIC89IHRoaXMuX2xhc3RFdmVudC5zY2FsZTtcbiAgfVxuXG4gIHRoaXMuX2R5bmFtaWNzLm9mZnNldCA9IChzY2FsZSAtIDEpICogLTE7XG4gIHRoaXMuZW1pdCgncGFyYW1ldGVyRHluYW1pY3MnLCAnem9vbScsIHRoaXMuX2R5bmFtaWNzKTtcblxuICB0aGlzLl9sYXN0RXZlbnQgPSBlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBpbmNoWm9vbUNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBIYW1tZXJHZXN0dXJlcyA9IHJlcXVpcmUoJy4vSGFtbWVyR2VzdHVyZXMnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBtYXhGcmljdGlvbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm1heEZyaWN0aW9uO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBzcGVlZDogOCxcbiAgZnJpY3Rpb246IDYsXG4gIG1heEZyaWN0aW9uVGltZTogMC4zXG59O1xuXG5cbi8qKlxuICogQGNsYXNzIFF0dnJDb250cm9sTWV0aG9kXG4gKiBAaW1wbGVtZW50cyBDb250cm9sTWV0aG9kXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ29udHJvbHMgdGhlIHZpZXcgYnkgaG9sZGluZyB0aGUgbW91c2UgYnV0dG9uIGRvd24gYW5kIG1vdmluZyBpdC5cbiAqIEFsc28ga25vd24gYXMgXCJRVFZSXCIgY29udHJvbCBtb2RlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGxpc3RlbiBmb3IgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBvaW50ZXJUeXBlIFdoaWNoIEhhbW1lci5qcyBwb2ludGVyIHR5cGUgdG8gdXNlIChlLmcuXG4gKiBgbW91c2VgIG9yIGB0b3VjaGApLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNwZWVkXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5mcmljdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMubWF4RnJpY3Rpb25UaW1lXG4gKi9cbi8vIFRPRE86IGFsbG93IHNwZWVkIG5vdCBjaGFuZ2UgbGluZWFybHkgd2l0aCBkaXN0YW5jZSB0byBjbGljayBzcG90LlxuLy8gUXVhZHJhdGljIG9yIG90aGVyIHdvdWxkIGFsbG93IGEgbGFyZ2VyIHNwZWVkIHJhbmdlLlxuZnVuY3Rpb24gUXR2ckNvbnRyb2xNZXRob2QoZWxlbWVudCwgcG9pbnRlclR5cGUsIG9wdHMpIHtcbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgdGhpcy5fb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRpb25zKTtcblxuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblxuICB0aGlzLl9oYW1tZXIgPSBIYW1tZXJHZXN0dXJlcy5nZXQoZWxlbWVudCwgcG9pbnRlclR5cGUpO1xuXG4gIHRoaXMuX2R5bmFtaWNzID0ge1xuICAgIHg6IG5ldyBEeW5hbWljcygpLFxuICAgIHk6IG5ldyBEeW5hbWljcygpXG4gIH07XG5cbiAgdGhpcy5faGFtbWVyLm9uKCdwYW5zdGFydCcsIHRoaXMuX2hhbmRsZVN0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3Bhbm1vdmUnLCB0aGlzLl9oYW5kbGVNb3ZlLmJpbmQodGhpcykpO1xuICB0aGlzLl9oYW1tZXIub24oJ3BhbmVuZCcsIHRoaXMuX2hhbmRsZVJlbGVhc2UuYmluZCh0aGlzKSk7XG4gIHRoaXMuX2hhbW1lci5vbigncGFuY2FuY2VsJywgdGhpcy5faGFuZGxlUmVsZWFzZS5iaW5kKHRoaXMpKTtcbn1cblxuZXZlbnRFbWl0dGVyKFF0dnJDb250cm9sTWV0aG9kKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5RdHZyQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW1tZXIucmVsZWFzZSgpO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cblF0dnJDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgZXZlbnQgZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYXVzaW5nIHN0cmFuZ2UgYmVoYXZpb3Igb24gQ2hyb21lXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgfVxufTtcblxuXG5RdHZyQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuX2hhbmRsZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gIC8vIFByZXZlbnQgZXZlbnQgZHJhZ2dpbmcgb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYXVzaW5nIHN0cmFuZ2UgYmVoYXZpb3Igb24gQ2hyb21lXG4gIGUucHJldmVudERlZmF1bHQoKTtcblxuICB0aGlzLl91cGRhdGVEeW5hbWljcyhlLCBmYWxzZSk7XG59O1xuXG5cblF0dnJDb250cm9sTWV0aG9kLnByb3RvdHlwZS5faGFuZGxlUmVsZWFzZSA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gUHJldmVudCBldmVudCBkcmFnZ2luZyBvdGhlciBET00gZWxlbWVudHMgYW5kIGNhdXNpbmcgc3RyYW5nZSBiZWhhdmlvciBvbiBDaHJvbWVcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuX3VwZGF0ZUR5bmFtaWNzKGUsIHRydWUpO1xuXG4gIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2luYWN0aXZlJyk7XG4gIH1cbn07XG5cblxudmFyIHRtcFJlbGVhc2VGcmljdGlvbiA9IFsgbnVsbCwgbnVsbCBdO1xuUXR2ckNvbnRyb2xNZXRob2QucHJvdG90eXBlLl91cGRhdGVEeW5hbWljcyA9IGZ1bmN0aW9uKGUsIHJlbGVhc2UpIHtcbiAgdmFyIGVsZW1lbnRSZWN0ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHdpZHRoID0gZWxlbWVudFJlY3QucmlnaHQgLSBlbGVtZW50UmVjdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudFJlY3QudG9wO1xuICB2YXIgbWF4RGltID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG5cbiAgdmFyIHggPSBlLmRlbHRhWCAvIG1heERpbSAqIHRoaXMuX29wdHMuc3BlZWQ7XG4gIHZhciB5ID0gZS5kZWx0YVkgLyBtYXhEaW0gKiB0aGlzLl9vcHRzLnNwZWVkO1xuXG4gIHRoaXMuX2R5bmFtaWNzLngucmVzZXQoKTtcbiAgdGhpcy5fZHluYW1pY3MueS5yZXNldCgpO1xuICB0aGlzLl9keW5hbWljcy54LnZlbG9jaXR5ID0geDtcbiAgdGhpcy5fZHluYW1pY3MueS52ZWxvY2l0eSA9IHk7XG5cbiAgaWYgKHJlbGVhc2UpIHtcbiAgICBtYXhGcmljdGlvbih0aGlzLl9vcHRzLmZyaWN0aW9uLCB0aGlzLl9keW5hbWljcy54LnZlbG9jaXR5LCB0aGlzLl9keW5hbWljcy55LnZlbG9jaXR5LCB0aGlzLl9vcHRzLm1heEZyaWN0aW9uVGltZSwgdG1wUmVsZWFzZUZyaWN0aW9uKTtcbiAgICB0aGlzLl9keW5hbWljcy54LmZyaWN0aW9uID0gdG1wUmVsZWFzZUZyaWN0aW9uWzBdO1xuICAgIHRoaXMuX2R5bmFtaWNzLnkuZnJpY3Rpb24gPSB0bXBSZWxlYXNlRnJpY3Rpb25bMV07XG4gIH1cblxuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ3gnLCB0aGlzLl9keW5hbWljcy54KTtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsICd5JywgdGhpcy5fZHluYW1pY3MueSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUXR2ckNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVmYXVsdHMnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZyaWN0aW9uVGltZTogMC4yLFxuICB6b29tRGVsdGE6IDAuMDAxXG59O1xuXG4vKipcbiAqIEBjbGFzcyBTY3JvbGxab29tQ29udHJvbE1ldGhvZFxuICogQGltcGxlbWVudHMgQ29udHJvbE1ldGhvZFxuICogQGNsYXNzZGVzY1xuICpcbiAqIENvbnRyb2xzIHRoZSBmb3Yvem9vbSB0aHJvdWdoIHRoZSBtb3VzZSB3aGVlbC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsaXN0ZW4gZm9yIGV2ZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZnJpY3Rpb25UaW1lPTAuMl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy56b29tRGVsdGE9MC4wMDFdXG4gKi9cbmZ1bmN0aW9uIFNjcm9sbFpvb21Db250cm9sTWV0aG9kKGVsZW1lbnQsIG9wdHMpIHtcbiAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX29wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBkZWZhdWx0T3B0aW9ucyk7XG4gIHRoaXMuX2R5bmFtaWNzID0gbmV3IER5bmFtaWNzKCk7XG4gIHRoaXMuX2V2ZW50TGlzdCA9IFtdO1xuXG4gIHZhciBmbiA9IHRoaXMuX29wdHMuZnJpY3Rpb25UaW1lID8gdGhpcy53aXRoU21vb3RoaW5nIDogdGhpcy53aXRob3V0U21vb3RoaW5nO1xuICB0aGlzLl93aGVlbExpc3RlbmVyID0gZm4uYmluZCh0aGlzKTtcbiAgXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl93aGVlbExpc3RlbmVyKTtcbn1cblxuZXZlbnRFbWl0dGVyKFNjcm9sbFpvb21Db250cm9sTWV0aG9kKTtcblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5TY3JvbGxab29tQ29udHJvbE1ldGhvZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fd2hlZWxMaXN0ZW5lcik7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLndpdGhvdXRTbW9vdGhpbmcgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuX2R5bmFtaWNzLm9mZnNldCA9IHdoZWVsRXZlbnREZWx0YShlKSAqIHRoaXMuX29wdHMuem9vbURlbHRhO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ3pvb20nLCB0aGlzLl9keW5hbWljcyk7XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbn07XG5cblxuU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2QucHJvdG90eXBlLndpdGhTbW9vdGhpbmcgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGUudGltZVN0YW1wO1xuXG4gIC8vIFJlY29yZCBldmVudC5cbiAgdGhpcy5fZXZlbnRMaXN0LnB1c2goZSk7XG5cbiAgLy8gUmVtb3ZlIGV2ZW50cyB3aG9zZSBzbW9vdGhpbmcgaGFzIGFscmVhZHkgZXhwaXJlZC5cbiAgd2hpbGUgKHRoaXMuX2V2ZW50TGlzdFswXS50aW1lU3RhbXAgPCBjdXJyZW50VGltZSAtIHRoaXMuX29wdHMuZnJpY3Rpb25UaW1lKjEwMDApIHtcbiAgICB0aGlzLl9ldmVudExpc3Quc2hpZnQoMCk7XG4gIH1cblxuICAvLyBHZXQgdGhlIGN1cnJlbnQgdmVsb2NpdHkgZnJvbSB0aGUgcmVjb3JkZWQgZXZlbnRzLlxuICAvLyBFYWNoIHdoZWVsIG1vdmVtZW50IGNhdXNlcyBhIHZlbG9jaXR5IG9mIGNoYW5nZS9mcmljdGlvblRpbWUgZHVyaW5nIGZyaWN0aW9uVGltZS5cbiAgdmFyIHZlbG9jaXR5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgem9vbUNoYW5nZUZyb21FdmVudCA9IHdoZWVsRXZlbnREZWx0YSh0aGlzLl9ldmVudExpc3RbaV0pICogdGhpcy5fb3B0cy56b29tRGVsdGE7XG4gICAgdmVsb2NpdHkgKz0gem9vbUNoYW5nZUZyb21FdmVudCAvIHRoaXMuX29wdHMuZnJpY3Rpb25UaW1lO1xuICB9XG5cbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgdGhpcy5fZHluYW1pY3MuZnJpY3Rpb24gPSBNYXRoLmFicyh2ZWxvY2l0eSkgLyB0aGlzLl9vcHRzLmZyaWN0aW9uVGltZTtcblxuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgJ3pvb20nLCB0aGlzLl9keW5hbWljcyk7XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRoaXMuZW1pdCgnYWN0aXZlJyk7XG4gIHRoaXMuZW1pdCgnaW5hY3RpdmUnKTtcbn07XG5cblxuZnVuY3Rpb24gd2hlZWxFdmVudERlbHRhKGUpIHtcbiAgdmFyIG11bHRpcGxpZXIgPSBlLmRlbHRhTW9kZSA9PSAxID8gMjAgOiAxO1xuICByZXR1cm4gZS5kZWx0YVkgKiBtdWx0aXBsaWVyO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2Q7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBEeW5hbWljcyA9IHJlcXVpcmUoJy4vRHluYW1pY3MnKTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vKipcbiAqIEBjbGFzcyBWZWxvY2l0eUNvbnRyb2xNZXRob2RcbiAqIEBpbXBsZW1lbnRzIENvbnRyb2xNZXRob2RcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBTZXRzIHRoZSB2ZWxvY2l0eSBhbmQgZnJpY3Rpb24gb2YgYSBzaW5nbGUgcGFyYW1ldGVyLlxuICpcbiAqIFRoZSB1c2VyIHNob3VsZCBlbWl0ICdhY3RpdmUnIGFuZCAnaW5hY3RpdmUnIGV2ZW50cyBpZiByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1ldGVyIFRoZSBwYXJhbWV0ZXIgdG8gYmUgY29udHJvbGxlZCAoZS5nLiBgeGAsIGB5YCBvciBgem9vbWApXG4qL1xuZnVuY3Rpb24gVmVsb2NpdHlDb250cm9sTWV0aG9kKHBhcmFtZXRlcikge1xuICBpZighcGFyYW1ldGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHlDb250cm9sTWV0aG9kOiBwYXJhbWV0ZXIgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG5cbiAgdGhpcy5fcGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICB0aGlzLl9keW5hbWljcyA9IG5ldyBEeW5hbWljcygpO1xufVxuZXZlbnRFbWl0dGVyKFZlbG9jaXR5Q29udHJvbE1ldGhvZCk7XG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuVmVsb2NpdHlDb250cm9sTWV0aG9kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwYXJhbWV0ZXIncyB2ZWxvY2l0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZWxvY2l0eVxuICovXG5WZWxvY2l0eUNvbnRyb2xNZXRob2QucHJvdG90eXBlLnNldFZlbG9jaXR5ID0gZnVuY3Rpb24odmVsb2NpdHkpIHtcbiAgdGhpcy5fZHluYW1pY3MudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJEeW5hbWljcycsIHRoaXMuX3BhcmFtZXRlciwgdGhpcy5fZHluYW1pY3MpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhcmFtZXRlcidzIGZyaWN0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IGZyaWN0aW9uXG4gKi9cblZlbG9jaXR5Q29udHJvbE1ldGhvZC5wcm90b3R5cGUuc2V0RnJpY3Rpb24gPSBmdW5jdGlvbihmcmljdGlvbikge1xuICB0aGlzLl9keW5hbWljcy5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICB0aGlzLmVtaXQoJ3BhcmFtZXRlckR5bmFtaWNzJywgdGhpcy5fcGFyYW1ldGVyLCB0aGlzLl9keW5hbWljcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlbG9jaXR5Q29udHJvbE1ldGhvZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vdXRpbC9kZWZhdWx0cycpO1xudmFyIERyYWdDb250cm9sTWV0aG9kID0gcmVxdWlyZSgnLi9EcmFnJyk7XG52YXIgUXR2ckNvbnRyb2xNZXRob2QgPSByZXF1aXJlKCcuL1F0dnInKTtcbnZhciBTY3JvbGxab29tQ29udHJvbE1ldGhvZCA9IHJlcXVpcmUoJy4vU2Nyb2xsWm9vbScpO1xudmFyIFBpbmNoWm9vbUNvbnRyb2xNZXRob2QgPSByZXF1aXJlKCcuL1BpbmNoWm9vbScpO1xudmFyIEtleUNvbnRyb2xNZXRob2QgPSByZXF1aXJlKCcuL0tleScpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIG1vdXNlVmlld01vZGU6ICdkcmFnJyxcbiAgZHJhZ01vZGU6ICdwYW4nXG59O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGFuZCByZWdpc3RlciBzb21lIGNvbW1vbmx5IHVzZWQge0BsaW5rIENvbnRyb2xNZXRob2R9IGluc3RhbmNlcy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGluc3RhbmNlcyBhcmUgcmVnaXN0ZXJlZDpcbiAqICAgLSBtb3VzZVZpZXdEcmFnXG4gKiAgIC0gbW91c2VWaWV3UXR2clxuICogICAtIHRvdWNoVmlld1xuICogICAtIHBpbmNoXG4gKiAgIC0gYXJyb3dLZXlzXG4gKiAgIC0gcGx1c01pbnVzS2V5c1xuICogICAtIHdhc2RLZXlzXG4gKiAgIC0gcWVLZXlzXG4gKlxuICogQHBhcmFtIHtDb250cm9sc30gY29udHJvbHMgV2hlcmUgdG8gcmVnaXN0ZXIgdGhlIGluc3RhbmNlcy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGxpc3RlbiBmb3IgZXZlbnRzLlxuICogQHBhcmFtIHsnZHJhZyd8J3F0dnInfSBvcHRzLm1vdXNlVmlld01vZGVcbiAqIEBwYXJhbSB7J3Bhbid8J3BpbmNoJ30gb3B0cy5kcmFnTW9kZVxuICogQHBhcmFtIHtib29sZWFufSBvcHRzLnNjcm9sbFpvb21cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0Q29udHJvbHMoY29udHJvbHMsIGVsZW1lbnQsIG9wdHMpIHtcbiAgb3B0cyA9IGRlZmF1bHRzKG9wdHMgfHwge30sIGRlZmF1bHRPcHRpb25zKTtcblxuICB2YXIgY29udHJvbE1ldGhvZHMgPSB7XG4gICAgbW91c2VWaWV3RHJhZzogbmV3IERyYWdDb250cm9sTWV0aG9kKGVsZW1lbnQsICdtb3VzZScpLFxuICAgIG1vdXNlVmlld1F0dnI6IG5ldyBRdHZyQ29udHJvbE1ldGhvZChlbGVtZW50LCAnbW91c2UnKSxcblxuICAgIGxlZnRBcnJvd0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMzcsICd4JywgLTAuNywgMyksXG4gICAgcmlnaHRBcnJvd0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMzksICd4JywgMC43LCAzKSxcbiAgICB1cEFycm93S2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCgzOCwgJ3knLCAtMC43LCAzKSxcbiAgICBkb3duQXJyb3dLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDQwLCAneScsIDAuNywgMyksXG4gICAgcGx1c0tleTogbmV3IEtleUNvbnRyb2xNZXRob2QoMTA3LCAnem9vbScsIC0wLjcsIDMpLFxuICAgIG1pbnVzS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCgxMDksICd6b29tJywgMC43LCAzKSxcblxuICAgIHdLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDg3LCAneScsIC0wLjcsIDMpLFxuICAgIGFLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDY1LCAneCcsIC0wLjcsIDMpLFxuICAgIHNLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDgzLCAneScsIDAuNywgMyksXG4gICAgZEtleTogbmV3IEtleUNvbnRyb2xNZXRob2QoNjgsICd4JywgMC43LCAzKSxcbiAgICBxS2V5OiBuZXcgS2V5Q29udHJvbE1ldGhvZCg4MSwgJ3JvbGwnLCAwLjcsIDMpLFxuICAgIGVLZXk6IG5ldyBLZXlDb250cm9sTWV0aG9kKDY5LCAncm9sbCcsIC0wLjcsIDMpXG4gIH07XG5cbiAgdmFyIGVuYWJsZWRDb250cm9scyA9IFsnc2Nyb2xsWm9vbScsICd0b3VjaFZpZXcnLCAncGluY2gnIF07XG5cbiAgaWYgKG9wdHMuc2Nyb2xsWm9vbSAhPT0gZmFsc2UpIHtcbiAgICBjb250cm9sTWV0aG9kcy5zY3JvbGxab29tID0gbmV3IFNjcm9sbFpvb21Db250cm9sTWV0aG9kKGVsZW1lbnQpOyAvL3sgZnJpY3Rpb25UaW1lOiAwIH1cbiAgfVxuXG4gIHZhciBjb250cm9sTWV0aG9kR3JvdXBzID0ge1xuICAgIGFycm93S2V5czogWyAnbGVmdEFycm93S2V5JywgJ3JpZ2h0QXJyb3dLZXknLCAndXBBcnJvd0tleScsICdkb3duQXJyb3dLZXknIF0sXG4gICAgcGx1c01pbnVzS2V5czogWyAncGx1c0tleScsICdtaW51c0tleScgXSxcbiAgICB3YXNkS2V5czogWyAnd0tleScsICdhS2V5JywgJ3NLZXknLCAnZEtleScgXSxcbiAgICBxZUtleXM6IFsgJ3FLZXknLCAnZUtleScgXVxuICB9O1xuXG5cbiAgc3dpdGNoIChvcHRzLmRyYWdNb2RlKSB7XG4gICAgY2FzZSAncGluY2gnOlxuICAgICAgIGNvbnRyb2xNZXRob2RzLnBpbmNoID0gbmV3IERyYWdDb250cm9sTWV0aG9kKGVsZW1lbnQsICd0b3VjaCcsIHsgaGFtbWVyRXZlbnQ6ICdwaW5jaCcgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwYW4nOlxuICAgICAgY29udHJvbE1ldGhvZHMudG91Y2hWaWV3ID0gbmV3IERyYWdDb250cm9sTWV0aG9kKGVsZW1lbnQsICd0b3VjaCcpO1xuICAgICAgY29udHJvbE1ldGhvZHMucGluY2ggPSBuZXcgUGluY2hab29tQ29udHJvbE1ldGhvZChlbGVtZW50LCAndG91Y2gnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRyYWcgbW9kZTogXCIgKyBvcHRzLmRyYWdNb2RlKTtcbiAgfVxuXG4gIHN3aXRjaCAob3B0cy5tb3VzZVZpZXdNb2RlKSB7XG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICBlbmFibGVkQ29udHJvbHMucHVzaCgnbW91c2VWaWV3RHJhZycpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncXR2cic6XG4gICAgICBlbmFibGVkQ29udHJvbHMucHVzaCgnbW91c2VWaWV3UXR2cicpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW91c2UgdmlldyBtb2RlOiBcIiArIG9wdHMubW91c2VWaWV3TW9kZSk7XG4gIH1cblxuICBmb3IgKHZhciBpZCBpbiBjb250cm9sTWV0aG9kcykge1xuICAgIHZhciBtZXRob2QgPSBjb250cm9sTWV0aG9kc1tpZF07XG4gICAgY29udHJvbHMucmVnaXN0ZXJNZXRob2QoaWQsIG1ldGhvZCk7XG4gICAgaWYgKGVuYWJsZWRDb250cm9scy5pbmRleE9mKGlkKSA+PSAwKSB7XG4gICAgICBjb250cm9scy5lbmFibGVNZXRob2QoaWQpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwSWQgaW4gY29udHJvbE1ldGhvZEdyb3Vwcykge1xuICAgIHZhciBtZXRob2RHcm91cCA9IGNvbnRyb2xNZXRob2RHcm91cHNbZ3JvdXBJZF07XG4gICAgY29udHJvbHMuYWRkTWV0aG9kR3JvdXAoZ3JvdXBJZCwgbWV0aG9kR3JvdXApO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xNZXRob2RzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyRGVmYXVsdENvbnRyb2xzO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtYXhGcmljdGlvbihmcmljdGlvbiwgdmVsb2NpdHlYLCB2ZWxvY2l0eVksIG1heEZyaWN0aW9uVGltZSwgcmVzdWx0KSB7XG4gIHZhciB2ZWxvY2l0eSA9IE1hdGguc3FydChNYXRoLnBvdyh2ZWxvY2l0eVgsMikgKyBNYXRoLnBvdyh2ZWxvY2l0eVksMikpO1xuICBmcmljdGlvbiA9IE1hdGgubWF4KGZyaWN0aW9uLCB2ZWxvY2l0eS9tYXhGcmljdGlvblRpbWUpO1xuICBjaGFuZ2VWZWN0b3JOb3JtKHZlbG9jaXR5WCwgdmVsb2NpdHlZLCBmcmljdGlvbiwgcmVzdWx0KTtcbiAgcmVzdWx0WzBdID0gTWF0aC5hYnMocmVzdWx0WzBdKTtcbiAgcmVzdWx0WzFdID0gTWF0aC5hYnMocmVzdWx0WzFdKTtcbn1cblxuZnVuY3Rpb24gY2hhbmdlVmVjdG9yTm9ybSh4LCB5LCBuLCByZXN1bHQpIHtcbiAgdmFyIHRoZXRhID0gTWF0aC5hdGFuKHkveCk7XG4gIHJlc3VsdFswXSA9IG4gKiBNYXRoLmNvcyh0aGV0YSk7XG4gIHJlc3VsdFsxXSA9IG4gKiBNYXRoLnNpbih0aGV0YSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXhGcmljdGlvbjogbWF4RnJpY3Rpb24sXG4gIGNoYW5nZVZlY3Rvck5vcm06IGNoYW5nZVZlY3Rvck5vcm1cbn07IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4uL3V0aWwvaGFzaCcpO1xudmFyIFRpbGVTZWFyY2hlciA9IHJlcXVpcmUoJy4uL1RpbGVTZWFyY2hlcicpO1xudmFyIExydU1hcCA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL0xydU1hcCcpO1xudmFyIExldmVsID0gcmVxdWlyZSgnLi9MZXZlbCcpO1xudmFyIG1ha2VMZXZlbExpc3QgPSByZXF1aXJlKCcuL2NvbW1vbicpLm1ha2VMZXZlbExpc3Q7XG52YXIgbWFrZVNlbGVjdGFibGVMZXZlbExpc3QgPSByZXF1aXJlKCcuL2NvbW1vbicpLm1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0O1xudmFyIGNsYW1wID0gcmVxdWlyZSgnLi4vdXRpbC9jbGFtcCcpO1xudmFyIGNtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY21wJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvdHlwZScpO1xudmFyIHZlYzMgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWMzO1xudmFyIHZlYzQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWM0O1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xuXG52YXIgbmVpZ2hib3JzQ2FjaGVTaXplID0gNjQ7XG5cbi8vIEluaXRpYWxzIGZvciBjdWJlIGZhY2VzLlxudmFyIGZhY2VMaXN0ID0gJ2Z1ZGxyYic7XG5cbi8vIFJvdGF0aW9uIG9mIGVhY2ggZmFjZSwgcmVsYXRpdmUgdG8gdGhlIGZyb250IGZhY2UuXG52YXIgZmFjZVJvdGF0aW9uID0ge1xuICBmOiB7IHg6IDAsIHk6IDAgfSxcbiAgYjogeyB4OiAwLCB5OiBNYXRoLlBJIH0sXG4gIGw6IHsgeDogMCwgeTogTWF0aC5QSS8yIH0sXG4gIHI6IHsgeDogMCwgeTogLU1hdGguUEkvMiB9LFxuICB1OiB7IHg6IE1hdGguUEkvMiwgeTogMCB9LFxuICBkOiB7IHg6IC1NYXRoLlBJLzIsIHk6IDAgfVxufTtcblxuLy8gWmVybyB2ZWN0b3IuXG52YXIgb3JpZ2luID0gdmVjMy5jcmVhdGUoKTtcblxuLy8gUm90YXRlIGEgdmVjdG9yIGluIFpYWSBvcmRlci5cbmZ1bmN0aW9uIHJvdGF0ZVZlY3Rvcih2ZWMsIHosIHgsIHkpIHtcbiAgaWYgKHopIHtcbiAgICB2ZWMzLnJvdGF0ZVoodmVjLCB2ZWMsIG9yaWdpbiwgeik7XG4gIH1cbiAgaWYgKHgpIHtcbiAgICB2ZWMzLnJvdGF0ZVgodmVjLCB2ZWMsIG9yaWdpbiwgeCk7XG4gIH1cbiAgaWYgKHkpIHtcbiAgICB2ZWMzLnJvdGF0ZVkodmVjLCB2ZWMsIG9yaWdpbiwgeSk7XG4gIH1cbn1cblxuLy8gTm9ybWFsaXplZCB2ZWN0b3JzIHBvaW50aW5nIHRvIHRoZSBjZW50ZXIgb2YgZWFjaCBmYWNlLlxudmFyIGZhY2VWZWN0b3JzID0ge307XG5mb3IgKHZhciBpID0gMDsgaSA8IGZhY2VMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gIHZhciBmYWNlID0gZmFjZUxpc3RbaV07XG4gIHZhciByb3RhdGlvbiA9IGZhY2VSb3RhdGlvbltmYWNlXTtcbiAgdmFyIHYgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgIDAsIC0xKTtcbiAgcm90YXRlVmVjdG9yKHYsIDAsIHJvdGF0aW9uLngsIHJvdGF0aW9uLnkpO1xuICBmYWNlVmVjdG9yc1tmYWNlXSA9IHY7XG59XG5cbi8vIE1hcCBlYWNoIGZhY2UgdG8gaXRzIGFkamFjZW50IGZhY2VzLlxuLy8gVGhlIG9yZGVyIGlzIGFzIHN1Z2dlc3RlZCBieSB0aGUgZnJvbnQgZmFjZS5cbnZhciBhZGphY2VudEZhY2UgPSB7XG4gIGY6IFsgJ2wnLCAncicsICd1JywgJ2QnIF0sXG4gIGI6IFsgJ3InLCAnbCcsICd1JywgJ2QnIF0sXG4gIGw6IFsgJ2InLCAnZicsICd1JywgJ2QnIF0sXG4gIHI6IFsgJ2YnLCAnYicsICd1JywgJ2QnIF0sXG4gIHU6IFsgJ2wnLCAncicsICdiJywgJ2YnIF0sXG4gIGQ6IFsgJ2wnLCAncicsICdmJywgJ2InIF1cbn07XG5cbi8vIE9mZnNldHMgdG8gYXBwbHkgdG8gdGhlICh4LHkpIGNvb3JkaW5hdGVzIG9mIGEgdGlsZSB0byBnZXQgaXRzIG5laWdoYm9ycy5cbnZhciBuZWlnaGJvck9mZnNldHMgPSBbXG4gIFsgIDAsICAxIF0sIC8vIHRvcFxuICBbICAxLCAgMCBdLCAvLyByaWdodFxuICBbICAwLCAtMSBdLCAvLyBib3R0b21cbiAgWyAtMSwgIDAgXSAgLy8gbGVmdFxuXTtcblxuXG4vKipcbiAqIEBjbGFzcyBDdWJlVGlsZVxuICogQGltcGxlbWVudHMgVGlsZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEgdGlsZSBpbiBhIEB7Q3ViZUdlb21ldHJ5fS5cbiAqL1xuZnVuY3Rpb24gQ3ViZVRpbGUoZmFjZSwgeCwgeSwgeiwgZ2VvbWV0cnkpIHtcbiAgdGhpcy5mYWNlID0gZmFjZTtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy56ID0gejtcbiAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgdGhpcy5fbGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbel07XG59XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnJvdFggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhY2VSb3RhdGlvblt0aGlzLmZhY2VdLng7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5yb3RZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWNlUm90YXRpb25bdGhpcy5mYWNlXS55O1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuY2VudGVyWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMueCArIDAuNSkgLyB0aGlzLl9sZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKSAtIDAuNTtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDAuNSAtICh0aGlzLnkgKyAwLjUpIC8gdGhpcy5fbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xufTtcblxuXG5DdWJlVGlsZS5wcm90b3R5cGUuc2NhbGVYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAxIC8gdGhpcy5fbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDEgLyB0aGlzLl9sZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS52ZXJ0aWNlcyA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IFt2ZWMzLmNyZWF0ZSgpLCB2ZWMzLmNyZWF0ZSgpLCB2ZWMzLmNyZWF0ZSgpLCB2ZWMzLmNyZWF0ZSgpXTtcbiAgfVxuXG4gIHZhciByb3QgPSBmYWNlUm90YXRpb25bdGhpcy5mYWNlXTtcblxuICBmdW5jdGlvbiBtYWtlVmVydGV4KHZlYywgeCwgeSkge1xuICAgIHZlYzMuc2V0KHZlYywgeCwgeSwgLTAuNSk7XG4gICAgcm90YXRlVmVjdG9yKHZlYywgMCwgcm90LngsIHJvdC55KTtcbiAgfVxuXG4gIHZhciBsZWZ0ID0gdGhpcy5jZW50ZXJYKCkgLSB0aGlzLnNjYWxlWCgpIC8gMjtcbiAgdmFyIHJpZ2h0ID0gdGhpcy5jZW50ZXJYKCkgKyB0aGlzLnNjYWxlWCgpIC8gMjtcbiAgdmFyIGJvdHRvbSA9IHRoaXMuY2VudGVyWSgpIC0gdGhpcy5zY2FsZVkoKSAvIDI7XG4gIHZhciB0b3AgPSB0aGlzLmNlbnRlclkoKSArIHRoaXMuc2NhbGVZKCkgLyAyO1xuXG4gIG1ha2VWZXJ0ZXgocmVzdWx0WzBdLCBsZWZ0LCB0b3ApO1xuICBtYWtlVmVydGV4KHJlc3VsdFsxXSwgcmlnaHQsIHRvcCk7XG4gIG1ha2VWZXJ0ZXgocmVzdWx0WzJdLCByaWdodCwgYm90dG9tKTtcbiAgbWFrZVZlcnRleChyZXN1bHRbM10sIGxlZnQsIGJvdHRvbSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLnogPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmYWNlID0gdGhpcy5mYWNlO1xuICB2YXIgeiA9IHRoaXMuejtcbiAgdmFyIHggPSB0aGlzLng7XG4gIHZhciB5ID0gdGhpcy55O1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICB2YXIgbGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbel07XG4gIHZhciBwYXJlbnRMZXZlbCA9IGdlb21ldHJ5LmxldmVsTGlzdFt6LTFdO1xuXG4gIHZhciB0aWxlWCA9IE1hdGguZmxvb3IoeCAvIGxldmVsLm51bUhvcml6b250YWxUaWxlcygpICogcGFyZW50TGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkpO1xuICB2YXIgdGlsZVkgPSBNYXRoLmZsb29yKHkgLyBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgKiBwYXJlbnRMZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkpO1xuICB2YXIgdGlsZVogPSB6LTE7XG5cbiAgcmV0dXJuIG5ldyBDdWJlVGlsZShmYWNlLCB0aWxlWCwgdGlsZVksIHRpbGVaLCBnZW9tZXRyeSk7XG5cbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24ocmVzdWx0KSB7XG5cbiAgaWYgKHRoaXMueiA9PT0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0Lmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmYWNlID0gdGhpcy5mYWNlO1xuICB2YXIgeiA9IHRoaXMuejtcbiAgdmFyIHggPSB0aGlzLng7XG4gIHZhciB5ID0gdGhpcy55O1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICB2YXIgbGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbel07XG4gIHZhciBjaGlsZExldmVsID0gZ2VvbWV0cnkubGV2ZWxMaXN0W3orMV07XG5cbiAgdmFyIG5Ib3JpeiA9IGNoaWxkTGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLyBsZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKTtcbiAgdmFyIG5WZXJ0ID0gY2hpbGRMZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLyBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCk7XG5cbiAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gIGZvciAodmFyIGggPSAwOyBoIDwgbkhvcml6OyBoKyspIHtcbiAgICBmb3IgKHZhciB2ID0gMDsgdiA8IG5WZXJ0OyB2KyspIHtcbiAgICAgIHZhciB0aWxlWCA9IG5Ib3JpeiAqIHggKyBoO1xuICAgICAgdmFyIHRpbGVZID0gblZlcnQgKiB5ICsgdjtcbiAgICAgIHZhciB0aWxlWiA9IHorMTtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBDdWJlVGlsZShmYWNlLCB0aWxlWCwgdGlsZVksIHRpbGVaLCBnZW9tZXRyeSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuQ3ViZVRpbGUucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICB2YXIgY2FjaGUgPSBnZW9tZXRyeS5fbmVpZ2hib3JzQ2FjaGU7XG5cbiAgLy8gU2F0aXNmeSBmcm9tIGNhY2hlIHdoZW4gYXZhaWxhYmxlLlxuICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KHRoaXMpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuXG4gIHZhciB2ZWMgPSBnZW9tZXRyeS5fdmVjO1xuXG4gIHZhciBmYWNlID0gdGhpcy5mYWNlO1xuICB2YXIgeCA9IHRoaXMueDtcbiAgdmFyIHkgPSB0aGlzLnk7XG4gIHZhciB6ID0gdGhpcy56O1xuICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbDtcblxuICB2YXIgbnVtWCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpO1xuICB2YXIgbnVtWSA9IGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvck9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeE9mZnNldCA9IG5laWdoYm9yT2Zmc2V0c1tpXVswXTtcbiAgICB2YXIgeU9mZnNldCA9IG5laWdoYm9yT2Zmc2V0c1tpXVsxXTtcblxuICAgIHZhciBuZXdYID0geCArIHhPZmZzZXQ7XG4gICAgdmFyIG5ld1kgPSB5ICsgeU9mZnNldDtcbiAgICB2YXIgbmV3WiA9IHo7XG4gICAgdmFyIG5ld0ZhY2UgPSBmYWNlO1xuXG4gICAgaWYgKG5ld1ggPCAwIHx8IG5ld1ggPj0gbnVtWCB8fCBuZXdZIDwgMCB8fCBuZXdZID49IG51bVkpIHtcblxuICAgICAgLy8gSWYgdGhlIG5laWdoYm9yaW5nIHRpbGUgYmVsb25ncyB0byBhIGRpZmZlcmVudCBmYWNlLCBjYWxjdWxhdGUgYVxuICAgICAgLy8gdmVjdG9yIHBvaW50aW5nIHRvIHRoZSBlZGdlIGJldHdlZW4gdGhlIHR3byBmYWNlcyBhdCB0aGUgcG9pbnQgdGhlXG4gICAgICAvLyB0aWxlIGFuZCBpdHMgbmVpZ2hib3IgbWVldCwgYW5kIGNvbnZlcnQgaXQgaW50byB0aWxlIGNvb3JkaW5hdGVzIGZvclxuICAgICAgLy8gdGhlIG5laWdoYm9yaW5nIGZhY2UuXG5cbiAgICAgIHZhciB4Q29vcmQgPSB0aGlzLmNlbnRlclgoKTtcbiAgICAgIHZhciB5Q29vcmQgPSB0aGlzLmNlbnRlclkoKTtcblxuICAgICAgLy8gRmlyc3QsIGNhbGN1bGF0ZSB0aGUgdmVjdG9yIGFzIGlmIHRoZSBpbml0aWFsIHRpbGUgYmVsb25ncyB0byB0aGVcbiAgICAgIC8vIGZyb250IGZhY2UsIHNvIHRoYXQgdGhlIHRpbGUgeCx5IGNvb3JkaW5hdGVzIG1hcCBkaXJlY3RseSBpbnRvIHRoZVxuICAgICAgLy8geCx5IGF4ZXMuXG5cbiAgICAgIGlmIChuZXdYIDwgMCkge1xuICAgICAgICB2ZWMzLnNldCh2ZWMsIC0wLjUsIHlDb29yZCwgLTAuNSk7XG4gICAgICAgIG5ld0ZhY2UgPSBhZGphY2VudEZhY2VbZmFjZV1bMF07XG4gICAgICB9IGVsc2UgaWYgKG5ld1ggPj0gbnVtWCkge1xuICAgICAgICB2ZWMzLnNldCh2ZWMsIDAuNSwgeUNvb3JkLCAtMC41KTtcbiAgICAgICAgbmV3RmFjZSA9IGFkamFjZW50RmFjZVtmYWNlXVsxXTtcbiAgICAgIH0gZWxzZSBpZiAobmV3WSA8IDApIHtcbiAgICAgICAgdmVjMy5zZXQodmVjLCB4Q29vcmQsIDAuNSwgLTAuNSk7XG4gICAgICAgIG5ld0ZhY2UgPSBhZGphY2VudEZhY2VbZmFjZV1bMl07XG4gICAgICB9IGVsc2UgaWYgKG5ld1kgPj0gbnVtWSkge1xuICAgICAgICB2ZWMzLnNldCh2ZWMsIHhDb29yZCwgLTAuNSwgLTAuNSk7XG4gICAgICAgIG5ld0ZhY2UgPSBhZGphY2VudEZhY2VbZmFjZV1bM107XG4gICAgICB9XG5cbiAgICAgIHZhciByb3Q7XG5cbiAgICAgIC8vIFRoZW4sIHJvdGF0ZSB0aGUgdmVjdG9yIGludG8gdGhlIGFjdHVhbCBmYWNlIHRoZSBpbml0aWFsIHRpbGVcbiAgICAgIC8vIGJlbG9uZ3MgdG8uXG5cbiAgICAgIHJvdCA9IGZhY2VSb3RhdGlvbltmYWNlXTtcbiAgICAgIHJvdGF0ZVZlY3Rvcih2ZWMsIDAsIHJvdC54LCByb3QueSk7XG5cbiAgICAgIC8vIEZpbmFsbHksIHJvdGF0ZSB0aGUgdmVjdG9yIGZyb20gdGhlIG5laWdoYm9yaW5nIGZhY2UgaW50byB0aGUgZnJvbnRcbiAgICAgIC8vIGZhY2UuIEFnYWluLCB0aGlzIGlzIHNvIHRoYXQgdGhlIG5laWdoYm9yaW5nIHRpbGUgeCx5IGNvb3JkaW5hdGVzXG4gICAgICAvLyBtYXAgZGlyZWN0bHkgaW50byB0aGUgeCx5IGF4ZXMuXG5cbiAgICAgIHJvdCA9IGZhY2VSb3RhdGlvbltuZXdGYWNlXTtcbiAgICAgIHJvdGF0ZVZlY3Rvcih2ZWMsIDAsIC1yb3QueCwgLXJvdC55KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuZWlnaGJvcmluZyB0aWxlIGNvb3JkaW5hdGVzLlxuXG4gICAgICBuZXdYID0gY2xhbXAoTWF0aC5mbG9vcigoMC41ICsgdmVjWzBdKSAqIG51bVgpLCAwLCBudW1YIC0gMSk7XG4gICAgICBuZXdZID0gY2xhbXAoTWF0aC5mbG9vcigoMC41IC0gdmVjWzFdKSAqIG51bVkpLCAwLCBudW1ZIC0gMSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2gobmV3IEN1YmVUaWxlKG5ld0ZhY2UsIG5ld1gsIG5ld1ksIG5ld1osIGdlb21ldHJ5KSk7XG4gIH1cblxuICAvLyBTdG9yZSBpbnRvIGNhY2hlIHRvIHNhdGlzZnkgZnV0dXJlIHJlcXVlc3RzLlxuICBjYWNoZS5zZXQodGhpcywgcmVzdWx0KTtcblxuICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBoYXNoKGZhY2VMaXN0LmluZGV4T2YodGhpcy5mYWNlKSwgdGhpcy56LCB0aGlzLnksIHRoaXMueCk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiAodGhpcy5fZ2VvbWV0cnkgPT09IHRoYXQuX2dlb21ldHJ5ICYmXG4gICAgICB0aGlzLmZhY2UgPT09IHRoYXQuZmFjZSAmJlxuICAgICAgdGhpcy56ID09PSB0aGF0LnogJiZcbiAgICAgIHRoaXMueSA9PT0gdGhhdC55ICYmXG4gICAgICB0aGlzLnggPT09IHRoYXQueCk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiAoY21wKHRoaXMueiwgdGhhdC56KSB8fFxuICBjbXAoZmFjZUxpc3QuaW5kZXhPZih0aGlzLmZhY2UpLCBmYWNlTGlzdC5pbmRleE9mKHRoYXQuZmFjZSkpIHx8XG4gIGNtcCh0aGlzLnksIHRoYXQueSkgfHwgY21wKHRoaXMueCwgdGhhdC54KSk7XG59O1xuXG5cbkN1YmVUaWxlLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdDdWJlVGlsZSgnICsgdGlsZS5mYWNlICsgJywgJyArIHRpbGUueCArICcsICcgKyB0aWxlLnkgKyAnLCAnICsgdGlsZS56ICsgJyknO1xufTtcblxuXG5mdW5jdGlvbiBDdWJlTGV2ZWwobGV2ZWxQcm9wZXJ0aWVzKSB7XG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmNhbGwodGhpcywgbGV2ZWxQcm9wZXJ0aWVzKTtcblxuICB0aGlzLl9zaXplID0gbGV2ZWxQcm9wZXJ0aWVzLnNpemU7XG4gIHRoaXMuX3RpbGVTaXplID0gbGV2ZWxQcm9wZXJ0aWVzLnRpbGVTaXplO1xuXG4gIGlmICh0aGlzLl9zaXplICUgdGhpcy5fdGlsZVNpemUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIHNpemUgaXMgbm90IG11bHRpcGxlIG9mIHRpbGUgc2l6ZTogJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpemUgKyAnICcgKyB0aGlzLl90aWxlU2l6ZSk7XG4gIH1cbn1cblxuaW5oZXJpdHMoQ3ViZUxldmVsLCBMZXZlbCk7XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemU7XG59O1xuXG5cbkN1YmVMZXZlbC5wcm90b3R5cGUudGlsZVdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aWxlU2l6ZTtcbn07XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS50aWxlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90aWxlU2l6ZTtcbn07XG5cblxuQ3ViZUxldmVsLnByb3RvdHlwZS5fdmFsaWRhdGVXaXRoUGFyZW50TGV2ZWwgPSBmdW5jdGlvbihwYXJlbnRMZXZlbCkge1xuXG4gIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLnRpbGVXaWR0aCgpO1xuICB2YXIgdGlsZUhlaWdodCA9IHRoaXMudGlsZUhlaWdodCgpO1xuICB2YXIgbnVtSG9yaXpvbnRhbCA9IHRoaXMubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBudW1WZXJ0aWNhbCA9IHRoaXMubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIHZhciBwYXJlbnRXaWR0aCA9IHBhcmVudExldmVsLndpZHRoKCk7XG4gIHZhciBwYXJlbnRIZWlnaHQgPSBwYXJlbnRMZXZlbC5oZWlnaHQoKTtcbiAgdmFyIHBhcmVudFRpbGVXaWR0aCA9IHBhcmVudExldmVsLnRpbGVXaWR0aCgpO1xuICB2YXIgcGFyZW50VGlsZUhlaWdodCA9IHBhcmVudExldmVsLnRpbGVIZWlnaHQoKTtcbiAgdmFyIHBhcmVudE51bUhvcml6b250YWwgPSBwYXJlbnRMZXZlbC5udW1Ib3Jpem9udGFsVGlsZXMoKTtcbiAgdmFyIHBhcmVudE51bVZlcnRpY2FsID0gcGFyZW50TGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIGlmICh3aWR0aCAlIHBhcmVudFdpZHRoICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbCB3aWR0aCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICsgJyB2cy4gJyArIHBhcmVudFdpZHRoKTtcbiAgfVxuXG4gIGlmIChoZWlnaHQgJSBwYXJlbnRIZWlnaHQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGhlaWdodCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCArICcgdnMuICcgKyBwYXJlbnRIZWlnaHQpO1xuICB9XG5cbiAgaWYgKG51bUhvcml6b250YWwgJSBwYXJlbnROdW1Ib3Jpem9udGFsICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgaG9yaXpvbnRhbCB0aWxlcyBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICBudW1Ib3Jpem9udGFsICsgXCIgKFwiICsgd2lkdGggKyAnLycgKyB0aWxlV2lkdGggKyAnKScgKyBcIiB2cy4gXCIgK1xuICAgICAgcGFyZW50TnVtSG9yaXpvbnRhbCArIFwiIChcIiArIHBhcmVudFdpZHRoICsgJy8nICsgcGFyZW50VGlsZVdpZHRoICsgJyknKTtcbiAgfVxuXG4gIGlmIChudW1WZXJ0aWNhbCAlIHBhcmVudE51bVZlcnRpY2FsICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgdmVydGljYWwgdGlsZXMgbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgbnVtVmVydGljYWwgKyBcIiAoXCIgKyBoZWlnaHQgKyAnLycgKyB0aWxlSGVpZ2h0ICsgJyknICsgXCIgdnMuIFwiICtcbiAgICAgIHBhcmVudE51bVZlcnRpY2FsICsgXCIgKFwiICsgcGFyZW50SGVpZ2h0ICsgJy8nICsgcGFyZW50VGlsZUhlaWdodCArICcpJyk7XG4gIH1cblxufTtcblxuXG4vKipcbiAqIEBjbGFzcyBDdWJlR2VvbWV0cnlcbiAqIEBpbXBsZW1lbnRzIEdlb21ldHJ5XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgR2VvbWV0cnl9IGltcGxlbWVudGF0aW9uIHN1aXRhYmxlIGZvciB0aWxlZCBjdWJlIGltYWdlcyB3aXRoXG4gKiBtdWx0aXBsZSByZXNvbHV0aW9uIGxldmVscy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHJlc3RyaWN0aW9ucyBhcHBseTpcbiAqICAgLSBBbGwgdGlsZXMgaW4gYSBsZXZlbCBtdXN0IGJlIHNxdWFyZSBhbmQgZm9ybSBhIHJlY3Rhbmd1bGFyIGdyaWQ7XG4gKiAgIC0gVGhlIHNpemUgb2YgYSBsZXZlbCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIHRpbGUgc2l6ZTtcbiAqICAgLSBUaGUgc2l6ZSBvZiBhIGxldmVsIG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgcGFyZW50IGxldmVsIHNpemU7XG4gKiAgIC0gVGhlIG51bWJlciBvZiB0aWxlcyBpbiBhIGxldmVsIG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgbnVtYmVyIG9mIHRpbGVzXG4gKiAgICAgaW4gdGhlIHBhcmVudCBsZXZlbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBsZXZlbFByb3BlcnRpZXNMaXN0IExldmVsIGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxQcm9wZXJ0aWVzTGlzdFtdLnNpemUgQ3ViZSBmYWNlIHNpemUgaW4gcGl4ZWxzXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxQcm9wZXJ0aWVzTGlzdFtdLnRpbGVTaXplIFRpbGUgc2l6ZSBpbiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gQ3ViZUdlb21ldHJ5KGxldmVsUHJvcGVydGllc0xpc3QpIHtcbiAgaWYgKHR5cGUobGV2ZWxQcm9wZXJ0aWVzTGlzdCkgIT09ICdhcnJheScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGxpc3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgdGhpcy5sZXZlbExpc3QgPSBtYWtlTGV2ZWxMaXN0KGxldmVsUHJvcGVydGllc0xpc3QsIEN1YmVMZXZlbCk7XG4gIHRoaXMuc2VsZWN0YWJsZUxldmVsTGlzdCA9IG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0KHRoaXMubGV2ZWxMaXN0KTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5sZXZlbExpc3RbaV0uX3ZhbGlkYXRlV2l0aFBhcmVudExldmVsKHRoaXMubGV2ZWxMaXN0W2ktMV0pO1xuICB9XG5cbiAgdGhpcy5fdGlsZVNlYXJjaGVyID0gbmV3IFRpbGVTZWFyY2hlcih0aGlzKTtcblxuICB0aGlzLl9uZWlnaGJvcnNDYWNoZSA9IG5ldyBMcnVNYXAobmVpZ2hib3JzQ2FjaGVTaXplKTtcblxuICB0aGlzLl92ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gIHRoaXMuX3ZpZXdTaXplID0ge307XG59XG5cblxuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS5tYXhUaWxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWF4VGlsZVNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbExpc3RbaV07XG4gICAgbWF4VGlsZVNpemUgPSBNYXRoLm1heChtYXhUaWxlU2l6ZSwgbGV2ZWwudGlsZVdpZHRoLCBsZXZlbC50aWxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gbWF4VGlsZVNpemU7XG59O1xuXG5cbkN1YmVHZW9tZXRyeS5wcm90b3R5cGUubGV2ZWxUaWxlcyA9IGZ1bmN0aW9uKGxldmVsLCByZXN1bHQpIHtcblxuICB2YXIgbGV2ZWxJbmRleCA9IHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpO1xuICB2YXIgbWF4WCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMTtcbiAgdmFyIG1heFkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLSAxO1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICBmb3IgKHZhciBmID0gMDsgZiA8IGZhY2VMaXN0Lmxlbmd0aDsgZisrKSB7XG4gICAgdmFyIGZhY2UgPSBmYWNlTGlzdFtmXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBtYXhYOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IG1heFk7IHkrKykge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgQ3ViZVRpbGUoZmFjZSwgeCwgeSwgbGV2ZWxJbmRleCwgdGhpcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS5fY2xvc2VzdFRpbGUgPSBmdW5jdGlvbih2aWV3LCBsZXZlbCkge1xuICB2YXIgcmF5ID0gdGhpcy5fdmVjO1xuXG4gIC8vIENvbXB1dGUgYSB2aWV3IHJheSBpbnRvIHRoZSBjZW50cmFsIHNjcmVlbiBwb2ludC5cbiAgdmVjNC5zZXQocmF5LCAwLCAwLCAwLCAxKTtcbiAgdmFyIG1hdHJpeCA9IG1hdDQuY3JlYXRlKClcbiAgbWF0NC5tdWx0aXBseShtYXRyaXgsIHZpZXcuaW52ZXJzZVZpZXdNYXRyaXgoKSwgdmlldy5pbnZlcnNlUHJvamVjdGlvbigpKTtcbiAgdmVjNC50cmFuc2Zvcm1NYXQ0KHJheSwgcmF5LCBtYXRyaXgpO1xuXG4gIHZhciBtaW5BbmdsZSA9IEluZmluaXR5O1xuICB2YXIgY2xvc2VzdEZhY2UgPSBudWxsO1xuXG4gIC8vIEZpbmQgdGhlIGZhY2Ugd2hvc2UgdmVjdG9yIG1ha2VzIGEgbWluaW1hbCBhbmdsZSB3aXRoIHRoZSB2aWV3IHJheS5cbiAgLy8gVGhpcyBpcyB0aGUgZmFjZSBpbnRvIHdoaWNoIHRoZSB2aWV3IHJheSBwb2ludHMuXG4gIGZvciAodmFyIGZhY2UgaW4gZmFjZVZlY3RvcnMpIHtcbiAgICB2YXIgdmVjdG9yID0gZmFjZVZlY3RvcnNbZmFjZV07XG4gICAgLy8gRm9yIGEgc21hbGwgYW5nbGUgYmV0d2VlbiB0d28gbm9ybWFsaXplZCB2ZWN0b3JzLCBhbmdsZSB+IDEtY29zKGFuZ2xlKS5cbiAgICB2YXIgYW5nbGUgPSAxIC0gdmVjMy5kb3QodmVjdG9yLCByYXkpO1xuICAgIGlmIChhbmdsZSA8IG1pbkFuZ2xlKSB7XG4gICAgICBtaW5BbmdsZSA9IGFuZ2xlO1xuICAgICAgY2xvc2VzdEZhY2UgPSBmYWNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByb2plY3QgdmlldyByYXkgb250byBjdWJlLCBpLmUuLCBub3JtYWxpemUgdGhlIGNvb3JkaW5hdGUgd2l0aFxuICAvLyBsYXJnZXN0IGFic29sdXRlIHZhbHVlIHRvIMKxMC41LlxuICB2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5hYnMocmF5WzBdKSwgTWF0aC5hYnMocmF5WzFdKSwgTWF0aC5hYnMocmF5WzJdKSkgLyAwLjU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmF5W2ldID0gcmF5W2ldIC8gbWF4O1xuICB9XG5cbiAgLy8gUm90YXRlIHZpZXcgcmF5IGludG8gZnJvbnQgZmFjZS5cbiAgdmFyIHJvdCA9IGZhY2VSb3RhdGlvbltjbG9zZXN0RmFjZV07XG4gIHJvdGF0ZVZlY3RvcihyYXksIDAsIC1yb3QueCwgLXJvdC55KTtcblxuICAvLyBHZXQgdGhlIGRlc2lyZWQgem9vbSBsZXZlbC5cbiAgdmFyIHRpbGVaID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHZhciBudW1YID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBudW1ZID0gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIC8vIEZpbmQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0aWxlIHRoYXQgdGhlIHZpZXcgcmF5IHBvaW50cyBpbnRvLlxuICB2YXIgdGlsZVggPSBjbGFtcChNYXRoLmZsb29yKCgwLjUgKyByYXlbMF0pICogbnVtWCksIDAsIG51bVggLSAxKTtcbiAgdmFyIHRpbGVZID0gY2xhbXAoTWF0aC5mbG9vcigoMC41IC0gcmF5WzFdKSAqIG51bVkpLCAwLCBudW1ZIC0gMSk7XG5cbiAgcmV0dXJuIG5ldyBDdWJlVGlsZShjbG9zZXN0RmFjZSwgdGlsZVgsIHRpbGVZLCB0aWxlWiwgdGhpcyk7XG59O1xuXG5cbkN1YmVHZW9tZXRyeS5wcm90b3R5cGUudmlzaWJsZVRpbGVzID0gZnVuY3Rpb24odmlldywgbGV2ZWwsIHJlc3VsdCkge1xuICB2YXIgdmlld1NpemUgPSB0aGlzLl92aWV3U2l6ZTtcbiAgdmFyIHRpbGVTZWFyY2hlciA9IHRoaXMuX3RpbGVTZWFyY2hlcjtcblxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgdmlldy5zaXplKHZpZXdTaXplKTtcbiAgaWYgKHZpZXdTaXplLndpZHRoID09PSAwIHx8IHZpZXdTaXplLmhlaWdodCA9PT0gMCkge1xuICAgIC8vIE5vIHRpbGVzIGFyZSB2aXNpYmxlIGlmIHRoZSB2aWV3cG9ydCBpcyBlbXB0eS5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHN0YXJ0aW5nVGlsZSA9IHRoaXMuX2Nsb3Nlc3RUaWxlKHZpZXcsIGxldmVsKTtcbiAgdmFyIGNvdW50ID0gdGlsZVNlYXJjaGVyLnNlYXJjaCh2aWV3LCBzdGFydGluZ1RpbGUsIHJlc3VsdCk7XG4gIGlmICghY291bnQpIHtcbiAgICAvL3Rocm93IG5ldyBFcnJvcignU3RhcnRpbmcgdGlsZSBpcyBub3QgdmlzaWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuQ3ViZUdlb21ldHJ5LlRpbGUgPSBDdWJlR2VvbWV0cnkucHJvdG90eXBlLlRpbGUgPSBDdWJlVGlsZTtcbkN1YmVHZW9tZXRyeS50eXBlID0gQ3ViZUdlb21ldHJ5LnByb3RvdHlwZS50eXBlID0gJ2N1YmUnO1xuQ3ViZVRpbGUudHlwZSA9IEN1YmVUaWxlLnByb3RvdHlwZS50eXBlID0gJ2N1YmUnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ3ViZUdlb21ldHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlsL2luaGVyaXRzJyk7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4uL3V0aWwvaGFzaCcpO1xudmFyIGNtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY21wJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBMZXZlbCA9IHJlcXVpcmUoJy4vTGV2ZWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi4vdXRpbC90eXBlJyk7XG5cblxuLyoqXG4gKiBAY2xhc3MgRXF1aXJlY3RUaWxlXG4gKiBAaW1wbGVtZW50cyBUaWxlXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB0aWxlIGluIGFuIEB7RXF1aXJlY3RHZW9tZXRyeX0uXG4gKi9cbmZ1bmN0aW9uIEVxdWlyZWN0VGlsZSh6LCBnZW9tZXRyeSkge1xuICB0aGlzLnogPSB6O1xuICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICB0aGlzLl9sZXZlbCA9IGdlb21ldHJ5LmxldmVsTGlzdFt6XTtcbn1cblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnJvdFggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUucm90WSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMDtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5jZW50ZXJYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwLjU7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY2VudGVyWSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMC41O1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLnNjYWxlWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDE7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnogPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmV3IEVxdWlyZWN0VGlsZSh0aGlzLnogLSAxLCB0aGlzLl9nZW9tZXRyeSk7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgaWYgKHRoaXMueiA9PT0gdGhpcy5fZ2VvbWV0cnkubGV2ZWxMaXN0Lmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gIHJlc3VsdC5wdXNoKG5ldyBFcXVpcmVjdFRpbGUodGhpcy56ICsgMSwgdGhpcy5fZ2VvbWV0cnkpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtdO1xufTtcblxuXG5FcXVpcmVjdFRpbGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGhhc2godGhpcy56KTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbih0aGF0KSB7XG4gIHJldHVybiB0aGlzLl9nZW9tZXRyeSA9PT0gdGhhdC5fZ2VvbWV0cnkgJiYgdGhpcy56ID09PSB0aGF0Lno7XG59O1xuXG5cbkVxdWlyZWN0VGlsZS5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24odGhhdCkge1xuICByZXR1cm4gY21wKHRoaXMueiwgdGhhdC56KTtcbn07XG5cblxuRXF1aXJlY3RUaWxlLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdFcXVpcmVjdFRpbGUoJyArIHRpbGUueiArICcpJztcbn07XG5cblxuZnVuY3Rpb24gRXF1aXJlY3RMZXZlbChsZXZlbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBsZXZlbFByb3BlcnRpZXMpO1xuICB0aGlzLl93aWR0aCA9IGxldmVsUHJvcGVydGllcy53aWR0aDtcbn1cblxuaW5oZXJpdHMoRXF1aXJlY3RMZXZlbCwgTGV2ZWwpO1xuXG5cbkVxdWlyZWN0TGV2ZWwucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aDtcbn07XG5cblxuRXF1aXJlY3RMZXZlbC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aC8yO1xufTtcblxuXG5FcXVpcmVjdExldmVsLnByb3RvdHlwZS50aWxlV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3dpZHRoO1xufTtcblxuXG5FcXVpcmVjdExldmVsLnByb3RvdHlwZS50aWxlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl93aWR0aC8yO1xufTtcblxuXG4vKipcbiAqIEBjbGFzcyBFcXVpcmVjdEdlb21ldHJ5XG4gKiBAaW1wbGVtZW50cyBHZW9tZXRyeVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIEdlb21ldHJ5fSBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgZXF1aXJlY3Rhbmd1bGFyIGltYWdlcyB3aXRoIGFcbiAqIDI6MSBhc3BlY3QgcmF0aW8uXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gbGV2ZWxQcm9wZXJ0aWVzTGlzdCBMZXZlbCBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS53aWR0aCBMZXZlbCB3aWR0aCBpbiBwaXhlbHNcbiovXG5mdW5jdGlvbiBFcXVpcmVjdEdlb21ldHJ5KGxldmVsUHJvcGVydGllc0xpc3QpIHtcbiAgaWYgKHR5cGUobGV2ZWxQcm9wZXJ0aWVzTGlzdCkgIT09ICdhcnJheScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGxpc3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgdGhpcy5sZXZlbExpc3QgPSBjb21tb24ubWFrZUxldmVsTGlzdChsZXZlbFByb3BlcnRpZXNMaXN0LCBFcXVpcmVjdExldmVsKTtcbiAgdGhpcy5zZWxlY3RhYmxlTGV2ZWxMaXN0ID0gY29tbW9uLm1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0KHRoaXMubGV2ZWxMaXN0KTtcbn1cblxuXG5FcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS5tYXhUaWxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWF4VGlsZVNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbExpc3RbaV07XG4gICAgbWF4VGlsZVNpemUgPSBNYXRoLm1heChtYXhUaWxlU2l6ZSwgbGV2ZWwudGlsZVdpZHRoLCBsZXZlbC50aWxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gbWF4VGlsZVNpemU7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLmxldmVsVGlsZXMgPSBmdW5jdGlvbihsZXZlbCwgcmVzdWx0KSB7XG4gIHZhciBsZXZlbEluZGV4ID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgcmVzdWx0LnB1c2gobmV3IEVxdWlyZWN0VGlsZShsZXZlbEluZGV4LCB0aGlzKSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLnZpc2libGVUaWxlcyA9IGZ1bmN0aW9uKHZpZXcsIGxldmVsLCByZXN1bHQpIHtcbiAgdmFyIHRpbGUgPSBuZXcgRXF1aXJlY3RUaWxlKHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpLCB0aGlzKTtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuICByZXN1bHQubGVuZ3RoID0gMDtcbiAgcmVzdWx0LnB1c2godGlsZSk7XG59O1xuXG5cbkVxdWlyZWN0R2VvbWV0cnkuVGlsZSA9IEVxdWlyZWN0R2VvbWV0cnkucHJvdG90eXBlLlRpbGUgPSBFcXVpcmVjdFRpbGU7XG5FcXVpcmVjdEdlb21ldHJ5LnR5cGUgPSBFcXVpcmVjdEdlb21ldHJ5LnByb3RvdHlwZS50eXBlID0gJ2VxdWlyZWN0JztcbkVxdWlyZWN0VGlsZS50eXBlID0gRXF1aXJlY3RUaWxlLnByb3RvdHlwZS50eXBlID0gJ2VxdWlyZWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWlyZWN0R2VvbWV0cnk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnLi4vdXRpbC9oYXNoJyk7XG52YXIgVGlsZVNlYXJjaGVyID0gcmVxdWlyZSgnLi4vVGlsZVNlYXJjaGVyJyk7XG52YXIgTHJ1TWFwID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbnMvTHJ1TWFwJyk7XG52YXIgTGV2ZWwgPSByZXF1aXJlKCcuL0xldmVsJyk7XG52YXIgbWFrZUxldmVsTGlzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykubWFrZUxldmVsTGlzdDtcbnZhciBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdCA9IHJlcXVpcmUoJy4vY29tbW9uJykubWFrZVNlbGVjdGFibGVMZXZlbExpc3Q7XG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgbW9kID0gcmVxdWlyZSgnLi4vdXRpbC9tb2QnKTtcbnZhciBjbXAgPSByZXF1aXJlKCcuLi91dGlsL2NtcCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLi91dGlsL3R5cGUnKTtcbnZhciB2ZWMyID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMjtcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcblxudmFyIG5laWdoYm9yc0NhY2hlU2l6ZSA9IDY0O1xuXG4vLyBPZmZzZXRzIHRvIGFwcGx5IHRvIHRoZSAoeCx5KSBjb29yZGluYXRlcyBvZiBhIHRpbGUgdG8gZ2V0IGl0cyBuZWlnaGJvcnMuXG52YXIgbmVpZ2hib3JPZmZzZXRzID0gW1xuICBbICAwLCAgMSBdLCAvLyB0b3BcbiAgWyAgMSwgIDAgXSwgLy8gcmlnaHRcbiAgWyAgMCwgLTEgXSwgLy8gYm90dG9tXG4gIFsgLTEsICAwIF0gIC8vIGxlZnRcbl07XG5cblxuLyoqXG4gKiBAY2xhc3MgRmxhdFRpbGVcbiAqIEBpbXBsZW1lbnRzIFRpbGVcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHRpbGUgaW4gYSB7QGxpbmsgRmxhdEdlb21ldHJ5fS5cbiAqL1xuZnVuY3Rpb24gRmxhdFRpbGUoeCwgeSwgeiwgZ2VvbWV0cnkpIHtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy56ID0gejtcbiAgdGhpcy5fZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgdGhpcy5fbGV2ZWwgPSBnZW9tZXRyeS5sZXZlbExpc3Rbel07XG59XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLnJvdFggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5yb3RZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuY2VudGVyWCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGV2ZWxXaWR0aCA9IHRoaXMuX2xldmVsLndpZHRoKCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLl9sZXZlbC50aWxlV2lkdGgoKTtcbiAgcmV0dXJuICh0aGlzLnggKiB0aWxlV2lkdGggKyAwLjUgKiB0aGlzLndpZHRoKCkpIC8gbGV2ZWxXaWR0aCAtIDAuNTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy5fbGV2ZWwudGlsZUhlaWdodCgpO1xuICByZXR1cm4gMC41IC0gKHRoaXMueSAqIHRpbGVIZWlnaHQgKyAwLjUgKiB0aGlzLmhlaWdodCgpKSAvIGxldmVsSGVpZ2h0O1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuc2NhbGVYID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZXZlbFdpZHRoID0gdGhpcy5fbGV2ZWwud2lkdGgoKTtcbiAgcmV0dXJuIHRoaXMud2lkdGgoKSAvIGxldmVsV2lkdGg7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG4gIHJldHVybiB0aGlzLmhlaWdodCgpIC8gbGV2ZWxIZWlnaHQ7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGV2ZWxXaWR0aCA9IHRoaXMuX2xldmVsLndpZHRoKCk7XG4gIHZhciB0aWxlV2lkdGggPSB0aGlzLl9sZXZlbC50aWxlV2lkdGgoKTtcbiAgaWYgKHRoaXMueCA9PT0gdGhpcy5fbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLSAxKSB7XG4gICAgdmFyIHdpZHRoUmVtYWluZGVyID0gbW9kKGxldmVsV2lkdGgsIHRpbGVXaWR0aCk7XG4gICAgcmV0dXJuIHdpZHRoUmVtYWluZGVyIHx8IHRpbGVXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGlsZVdpZHRoO1xuICB9XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fbGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciB0aWxlSGVpZ2h0ID0gdGhpcy5fbGV2ZWwudGlsZUhlaWdodCgpO1xuICBpZiAodGhpcy55ID09PSB0aGlzLl9sZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLSAxKSB7XG4gICAgdmFyIGhlaWdodFJlbWFpbmRlciA9IG1vZChsZXZlbEhlaWdodCwgdGlsZUhlaWdodCk7XG4gICAgcmV0dXJuIGhlaWdodFJlbWFpbmRlciB8fCB0aWxlSGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aWxlSGVpZ2h0O1xuICB9XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5sZXZlbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbC53aWR0aCgpO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUubGV2ZWxIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xldmVsLmhlaWdodCgpO1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUudmVydGljZXMgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBbdmVjMi5jcmVhdGUoKSwgdmVjMi5jcmVhdGUoKSwgdmVjMi5jcmVhdGUoKSwgdmVjMi5jcmVhdGUoKV07XG4gIH1cblxuICB2YXIgbGVmdCA9IHRoaXMuY2VudGVyWCgpIC0gdGhpcy5zY2FsZVgoKSAvIDI7XG4gIHZhciByaWdodCA9IHRoaXMuY2VudGVyWCgpICsgdGhpcy5zY2FsZVgoKSAvIDI7XG4gIHZhciBib3R0b20gPSB0aGlzLmNlbnRlclkoKSAtIHRoaXMuc2NhbGVZKCkgLyAyO1xuICB2YXIgdG9wID0gdGhpcy5jZW50ZXJZKCkgKyB0aGlzLnNjYWxlWSgpIC8gMjtcblxuICB2ZWMyLnNldChyZXN1bHRbMF0sIGxlZnQsIHRvcCk7XG4gIHZlYzIuc2V0KHJlc3VsdFsxXSwgcmlnaHQsIHRvcCk7XG4gIHZlYzIuc2V0KHJlc3VsdFsyXSwgcmlnaHQsIGJvdHRvbSk7XG4gIHZlYzIuc2V0KHJlc3VsdFszXSwgbGVmdCwgYm90dG9tKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG5cblxuICBpZiAodGhpcy56ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcblxuICB2YXIgeiA9IHRoaXMueiAtIDE7XG4gIC8vIFRPRE86IEN1cnJlbnRseSBhc3N1bWluZyBlYWNoIGxldmVsIGlzIGRvdWJsZSB0aGUgc2l6ZSBvZiBwcmV2aW91cyBvbmUuXG4gIC8vIEZpeCB0byBzdXBwb3J0IG90aGVyIG11bHRpcGxlcy5cbiAgdmFyIHggPSBNYXRoLmZsb29yKHRoaXMueCAvIDIpO1xuICB2YXIgeSA9IE1hdGguZmxvb3IodGhpcy55IC8gMik7XG5cbiAgcmV0dXJuIG5ldyBGbGF0VGlsZSh4LCB5LCB6LCBnZW9tZXRyeSk7XG5cbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIGlmICh0aGlzLnogPT09IHRoaXMuX2dlb21ldHJ5LmxldmVsTGlzdC5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgdmFyIHogPSB0aGlzLnogKyAxO1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAvLyBUT0RPOiBDdXJyZW50bHkgYXNzdW1pbmcgZWFjaCBsZXZlbCBpcyBkb3VibGUgdGhlIHNpemUgb2YgcHJldmlvdXMgb25lLlxuICAvLyBGaXggdG8gc3VwcG9ydCBvdGhlciBtdWx0aXBsZXMuXG4gIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZSgyKnRoaXMueCAgLCAyKnRoaXMueSAgLCB6LCBnZW9tZXRyeSkpO1xuICByZXN1bHQucHVzaChuZXcgRmxhdFRpbGUoMip0aGlzLnggICwgMip0aGlzLnkrMSwgeiwgZ2VvbWV0cnkpKTtcbiAgcmVzdWx0LnB1c2gobmV3IEZsYXRUaWxlKDIqdGhpcy54KzEsIDIqdGhpcy55ICAsIHosIGdlb21ldHJ5KSk7XG4gIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZSgyKnRoaXMueCsxLCAyKnRoaXMueSsxLCB6LCBnZW9tZXRyeSkpO1xuXG4gIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICB2YXIgY2FjaGUgPSBnZW9tZXRyeS5fbmVpZ2hib3JzQ2FjaGU7XG5cbiAgLy8gU2F0aXNmeSBmcm9tIGNhY2hlIHdoZW4gYXZhaWxhYmxlLlxuICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KHRoaXMpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuXG4gIHZhciB4ID0gdGhpcy54O1xuICB2YXIgeSA9IHRoaXMueTtcbiAgdmFyIHogPSB0aGlzLno7XG4gIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsO1xuXG4gIHZhciBudW1YID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCkgLSAxO1xuICB2YXIgbnVtWSA9IGxldmVsLm51bVZlcnRpY2FsVGlsZXMoKSAtIDE7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JPZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHhPZmZzZXQgPSBuZWlnaGJvck9mZnNldHNbaV1bMF07XG4gICAgdmFyIHlPZmZzZXQgPSBuZWlnaGJvck9mZnNldHNbaV1bMV07XG5cbiAgICB2YXIgbmV3WCA9IHggKyB4T2Zmc2V0O1xuICAgIHZhciBuZXdZID0geSArIHlPZmZzZXQ7XG4gICAgdmFyIG5ld1ogPSB6O1xuXG4gICAgaWYgKDAgPD0gbmV3WCAmJiBuZXdYIDw9IG51bVggJiYgMCA8PSBuZXdZICYmIG5ld1kgPD0gbnVtWSkge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IEZsYXRUaWxlKG5ld1gsIG5ld1ksIG5ld1osIGdlb21ldHJ5KSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RvcmUgaW50byBjYWNoZSB0byBzYXRpc2Z5IGZ1dHVyZSByZXF1ZXN0cy5cbiAgY2FjaGUuc2V0KHRoaXMsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuXG5GbGF0VGlsZS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaGFzaCh0aGlzLnosIHRoaXMueSwgdGhpcy54KTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuICh0aGlzLl9nZW9tZXRyeSA9PT0gdGhhdC5fZ2VvbWV0cnkgJiZcbiAgICAgIHRoaXMueiA9PT0gdGhhdC56ICYmIHRoaXMueSA9PT0gdGhhdC55ICYmIHRoaXMueCA9PT0gdGhhdC54KTtcbn07XG5cblxuRmxhdFRpbGUucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuIChjbXAodGhpcy56LCB0aGF0LnopIHx8IGNtcCh0aGlzLnksIHRoYXQueSkgfHwgY21wKHRoaXMueCwgdGhhdC54KSk7XG59O1xuXG5cbkZsYXRUaWxlLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdGbGF0VGlsZSgnICsgdGlsZS54ICsgJywgJyArIHRpbGUueSArICcsICcgKyB0aWxlLnogKyAnKSc7XG59O1xuXG5cbmZ1bmN0aW9uIEZsYXRMZXZlbChsZXZlbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uY2FsbCh0aGlzLCBsZXZlbFByb3BlcnRpZXMpO1xuXG4gIHRoaXMuX3dpZHRoID0gbGV2ZWxQcm9wZXJ0aWVzLndpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBsZXZlbFByb3BlcnRpZXMuaGVpZ2h0O1xuICB0aGlzLl90aWxlV2lkdGggPSBsZXZlbFByb3BlcnRpZXMudGlsZVdpZHRoO1xuICB0aGlzLl90aWxlSGVpZ2h0ID0gbGV2ZWxQcm9wZXJ0aWVzLnRpbGVIZWlnaHQ7XG59XG5cbmluaGVyaXRzKEZsYXRMZXZlbCwgTGV2ZWwpO1xuXG5cbkZsYXRMZXZlbC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3dpZHRoO1xufTtcblxuXG5GbGF0TGV2ZWwucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufTtcblxuXG5GbGF0TGV2ZWwucHJvdG90eXBlLnRpbGVXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdGlsZVdpZHRoO1xufTtcblxuXG5GbGF0TGV2ZWwucHJvdG90eXBlLnRpbGVIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3RpbGVIZWlnaHQ7XG59O1xuXG5cbkZsYXRMZXZlbC5wcm90b3R5cGUuX3ZhbGlkYXRlV2l0aFBhcmVudExldmVsID0gZnVuY3Rpb24ocGFyZW50TGV2ZWwpIHtcblxuICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICB2YXIgdGlsZVdpZHRoID0gdGhpcy50aWxlV2lkdGgoKTtcbiAgdmFyIHRpbGVIZWlnaHQgPSB0aGlzLnRpbGVIZWlnaHQoKTtcblxuICB2YXIgcGFyZW50V2lkdGggPSBwYXJlbnRMZXZlbC53aWR0aCgpO1xuICB2YXIgcGFyZW50SGVpZ2h0ID0gcGFyZW50TGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciBwYXJlbnRUaWxlV2lkdGggPSBwYXJlbnRMZXZlbC50aWxlV2lkdGgoKTtcbiAgdmFyIHBhcmVudFRpbGVIZWlnaHQgPSBwYXJlbnRMZXZlbC50aWxlSGVpZ2h0KCk7XG5cbiAgaWYgKHdpZHRoICUgcGFyZW50V2lkdGggIT09IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdMZXZlbCB3aWR0aCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgICB3aWR0aCArICcgdnMuICcgKyBwYXJlbnRXaWR0aCk7XG4gIH1cblxuICBpZiAoaGVpZ2h0ICUgcGFyZW50SGVpZ2h0ICE9PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignTGV2ZWwgaGVpZ2h0IG11c3QgYmUgbXVsdGlwbGUgb2YgcGFyZW50IGxldmVsOiAnICtcbiAgICAgICAgICAgICAgICAgICAgIGhlaWdodCArICcgdnMuICcgKyBwYXJlbnRIZWlnaHQpO1xuICB9XG5cbiAgaWYgKHRpbGVXaWR0aCAlIHBhcmVudFRpbGVXaWR0aCAhPT0gMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0xldmVsIHRpbGUgd2lkdGggbXVzdCBiZSBtdWx0aXBsZSBvZiBwYXJlbnQgbGV2ZWw6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgdGlsZVdpZHRoICsgJyB2cy4gJyArIHBhcmVudFRpbGVXaWR0aCk7XG4gIH1cblxuICBpZiAodGlsZUhlaWdodCAlIHBhcmVudFRpbGVIZWlnaHQgIT09IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdMZXZlbCB0aWxlIGhlaWdodCBtdXN0IGJlIG11bHRpcGxlIG9mIHBhcmVudCBsZXZlbDogJyArXG4gICAgICAgICAgICAgICAgICAgICB0aWxlSGVpZ2h0ICsgJyB2cy4gJyArIHBhcmVudFRpbGVIZWlnaHQpO1xuICB9XG5cbn07XG5cblxuLyoqXG4gKiBAY2xhc3MgRmxhdEdlb21ldHJ5XG4gKiBAaW1wbGVtZW50cyBHZW9tZXRyeVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIEdlb21ldHJ5fSBpbXBsZW1lbnRhdGlvbiBzdWl0YWJsZSBmb3IgdGlsZWQgZmxhdCBpbWFnZXMgd2l0aFxuICogbXVsdGlwbGUgcmVzb2x1dGlvbiBsZXZlbHMuXG4gKlxuICogVGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnMgYXBwbHk6XG4gKiAgIC0gQWxsIHRpbGVzIG11c3QgYmUgc3F1YXJlLCBleGNlcHQgd2hlbiBpbiB0aGUgbGFzdCByb3cgb3IgY29sdW1uIHBvc2l0aW9uLFxuICogICAgIGFuZCBtdXN0IGZvcm0gYSByZWN0YW5ndWxhciBncmlkO1xuICogICAtIFRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIGEgbGV2ZWwgbXVzdCBiZSBtdWx0aXBsZXMgb2YgdGhlIHBhcmVudCBsZXZlbFxuICogICAgIHdpZHRoIGFuZCBoZWlnaHQuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gbGV2ZWxQcm9wZXJ0aWVzTGlzdCBMZXZlbCBkZXNjcmlwdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS53aWR0aCBMZXZlbCB3aWR0aCBpbiBwaXhlbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFByb3BlcnRpZXNMaXN0W10udGlsZVdpZHRoIFRpbGUgd2lkdGggaW4gcGl4ZWxzIGZvclxuICogICAgICAgICAgICAgICAgIHNxdWFyZSB0aWxlc1xuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS5oZWlnaHQgTGV2ZWwgaGVpZ2h0IGluIHBpeGVsc1xuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsUHJvcGVydGllc0xpc3RbXS50aWxlSGVpZ2h0IFRpbGUgaGVpZ2h0IGluIHBpeGVscyBmb3JcbiAqICAgICAgICAgICAgICAgICBzcXVhcmUgdGlsZXNcbiAqL1xuZnVuY3Rpb24gRmxhdEdlb21ldHJ5KGxldmVsUHJvcGVydGllc0xpc3QpIHtcbiAgaWYgKHR5cGUobGV2ZWxQcm9wZXJ0aWVzTGlzdCkgIT09ICdhcnJheScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldmVsIGxpc3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgdGhpcy5sZXZlbExpc3QgPSBtYWtlTGV2ZWxMaXN0KGxldmVsUHJvcGVydGllc0xpc3QsIEZsYXRMZXZlbCk7XG4gIHRoaXMuc2VsZWN0YWJsZUxldmVsTGlzdCA9IG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0KHRoaXMubGV2ZWxMaXN0KTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5sZXZlbExpc3RbaV0uX3ZhbGlkYXRlV2l0aFBhcmVudExldmVsKHRoaXMubGV2ZWxMaXN0W2ktMV0pO1xuICB9XG5cbiAgdGhpcy5fdGlsZVNlYXJjaGVyID0gbmV3IFRpbGVTZWFyY2hlcih0aGlzKTtcblxuICB0aGlzLl9uZWlnaGJvcnNDYWNoZSA9IG5ldyBMcnVNYXAobmVpZ2hib3JzQ2FjaGVTaXplKTtcblxuICB0aGlzLl92ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gIHRoaXMuX3ZpZXdTaXplID0ge307XG59XG5cblxuRmxhdEdlb21ldHJ5LnByb3RvdHlwZS5tYXhUaWxlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWF4VGlsZVNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbExpc3RbaV07XG4gICAgbWF4VGlsZVNpemUgPSBNYXRoLm1heChtYXhUaWxlU2l6ZSwgbGV2ZWwudGlsZVdpZHRoLCBsZXZlbC50aWxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gbWF4VGlsZVNpemU7XG59O1xuXG5cbkZsYXRHZW9tZXRyeS5wcm90b3R5cGUubGV2ZWxUaWxlcyA9IGZ1bmN0aW9uKGxldmVsLCByZXN1bHQpIHtcblxuICB2YXIgbGV2ZWxJbmRleCA9IHRoaXMubGV2ZWxMaXN0LmluZGV4T2YobGV2ZWwpO1xuICB2YXIgbWF4WCA9IGxldmVsLm51bUhvcml6b250YWxUaWxlcygpIC0gMTtcbiAgdmFyIG1heFkgPSBsZXZlbC5udW1WZXJ0aWNhbFRpbGVzKCkgLSAxO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gW107XG4gIH1cblxuICBmb3IgKHZhciB4ID0gMDsgeCA8PSBtYXhYOyB4KyspIHtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBGbGF0VGlsZSh4LCB5LCBsZXZlbEluZGV4LCB0aGlzKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuXG5GbGF0R2VvbWV0cnkucHJvdG90eXBlLl9jbG9zZXN0VGlsZSA9IGZ1bmN0aW9uKHZpZXcsIGxldmVsKSB7XG4gIHZhciByYXkgPSB0aGlzLl92ZWM7XG5cbiAgLy8gQ29tcHV0ZSBhIHZpZXcgcmF5IGludG8gdGhlIGNlbnRyYWwgc2NyZWVuIHBvaW50LlxuICB2ZWM0LnNldChyYXksIDAsIDAsIDEsIDEpO1xuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHZpZXcuaW52ZXJzZVByb2plY3Rpb24oKSk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgaW1hZ2UgY29vcmRpbmF0ZXMgdGhhdCB0aGUgdmlldyByYXkgcG9pbnRzIGludG8uXG4gIHZhciB4ID0gMC41ICsgcmF5WzBdO1xuICB2YXIgeSA9IDAuNSAtIHJheVsxXTtcblxuICAvLyBHZXQgdGhlIGRlc2lyZWQgem9vbSBsZXZlbC5cbiAgdmFyIHRpbGVaID0gdGhpcy5sZXZlbExpc3QuaW5kZXhPZihsZXZlbCk7XG4gIHZhciBsZXZlbFdpZHRoID0gbGV2ZWwud2lkdGgoKTtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gbGV2ZWwuaGVpZ2h0KCk7XG4gIHZhciB0aWxlV2lkdGggPSBsZXZlbC50aWxlV2lkdGgoKTtcbiAgdmFyIHRpbGVIZWlnaHQgPSBsZXZlbC50aWxlSGVpZ2h0KCk7XG4gIHZhciBudW1YID0gbGV2ZWwubnVtSG9yaXpvbnRhbFRpbGVzKCk7XG4gIHZhciBudW1ZID0gbGV2ZWwubnVtVmVydGljYWxUaWxlcygpO1xuXG4gIC8vIEZpbmQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0aWxlIHRoYXQgdGhlIHZpZXcgcmF5IHBvaW50cyBpbnRvLlxuICB2YXIgdGlsZVggPSBjbGFtcChNYXRoLmZsb29yKHggKiBsZXZlbFdpZHRoIC8gdGlsZVdpZHRoKSwgMCwgbnVtWCAtIDEpO1xuICB2YXIgdGlsZVkgPSBjbGFtcChNYXRoLmZsb29yKHkgKiBsZXZlbEhlaWdodCAvIHRpbGVIZWlnaHQpLCAwLCBudW1ZIC0gMSk7XG5cbiAgcmV0dXJuIG5ldyBGbGF0VGlsZSh0aWxlWCwgdGlsZVksIHRpbGVaLCB0aGlzKTtcbn07XG5cblxuRmxhdEdlb21ldHJ5LnByb3RvdHlwZS52aXNpYmxlVGlsZXMgPSBmdW5jdGlvbih2aWV3LCBsZXZlbCwgcmVzdWx0KSB7XG4gIHZhciB2aWV3U2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuICB2YXIgdGlsZVNlYXJjaGVyID0gdGhpcy5fdGlsZVNlYXJjaGVyO1xuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICB2aWV3LnNpemUodmlld1NpemUpO1xuICBpZiAodmlld1NpemUud2lkdGggPT09IDAgfHwgdmlld1NpemUuaGVpZ2h0ID09PSAwKSB7XG4gICAgLy8gTm8gdGlsZXMgYXJlIHZpc2libGUgaWYgdGhlIHZpZXdwb3J0IGlzIGVtcHR5LlxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgc3RhcnRpbmdUaWxlID0gdGhpcy5fY2xvc2VzdFRpbGUodmlldywgbGV2ZWwpO1xuICB2YXIgY291bnQgPSB0aWxlU2VhcmNoZXIuc2VhcmNoKHZpZXcsIHN0YXJ0aW5nVGlsZSwgcmVzdWx0KTtcbiAgaWYgKCFjb3VudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RhcnRpbmcgdGlsZSBpcyBub3QgdmlzaWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuRmxhdEdlb21ldHJ5LlRpbGUgPSBGbGF0R2VvbWV0cnkucHJvdG90eXBlLlRpbGUgPSBGbGF0VGlsZTtcbkZsYXRHZW9tZXRyeS50eXBlID0gRmxhdEdlb21ldHJ5LnByb3RvdHlwZS50eXBlID0gJ2ZsYXQnO1xuRmxhdFRpbGUudHlwZSA9IEZsYXRUaWxlLnByb3RvdHlwZS50eXBlID0gJ2ZsYXQnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmxhdEdlb21ldHJ5O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBMZXZlbChsZXZlbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5fZmFsbGJhY2tPbmx5ID0gISFsZXZlbFByb3BlcnRpZXMuZmFsbGJhY2tPbmx5O1xufVxuXG5MZXZlbC5wcm90b3R5cGUubnVtSG9yaXpvbnRhbFRpbGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLmNlaWwodGhpcy53aWR0aCgpIC8gdGhpcy50aWxlV2lkdGgoKSk7XG59O1xuXG5MZXZlbC5wcm90b3R5cGUubnVtVmVydGljYWxUaWxlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuaGVpZ2h0KCkgLyB0aGlzLnRpbGVIZWlnaHQoKSk7XG59O1xuXG5MZXZlbC5wcm90b3R5cGUuZmFsbGJhY2tPbmx5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9mYWxsYmFja09ubHk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExldmVsOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY21wJyk7XG5cbmZ1bmN0aW9uIG1ha2VMZXZlbExpc3QobGV2ZWxQcm9wZXJ0aWVzTGlzdCwgTGV2ZWxDbGFzcykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxQcm9wZXJ0aWVzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGxpc3QucHVzaChuZXcgTGV2ZWxDbGFzcyhsZXZlbFByb3BlcnRpZXNMaXN0W2ldKSk7XG4gIH1cblxuICBsaXN0LnNvcnQoZnVuY3Rpb24obGV2ZWwxLCBsZXZlbDIpIHtcbiAgICByZXR1cm4gY21wKGxldmVsMS53aWR0aCgpLCBsZXZlbDIud2lkdGgoKSk7XG4gIH0pO1xuXG4gIHJldHVybiBsaXN0O1xufVxuXG5mdW5jdGlvbiBtYWtlU2VsZWN0YWJsZUxldmVsTGlzdChsZXZlbExpc3QpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbGV2ZWxMaXN0W2ldLl9mYWxsYmFja09ubHkpIHtcbiAgICAgIGxpc3QucHVzaChsZXZlbExpc3RbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNlbGVjdGFibGUgbGV2ZWxzIGluIGxpc3QnKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWFrZUxldmVsTGlzdDogbWFrZUxldmVsTGlzdCxcbiAgbWFrZVNlbGVjdGFibGVMZXZlbExpc3Q6IG1ha2VTZWxlY3RhYmxlTGV2ZWxMaXN0XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvLyBTdGFnZXMuXG4gIFdlYkdsU3RhZ2U6IHJlcXVpcmUoJy4vc3RhZ2VzL1dlYkdsJyksXG5cbiAgLy8gUmVuZGVyZXJzLlxuICBXZWJHbEN1YmVSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlcnMvV2ViR2xDdWJlJyksXG4gIFdlYkdsRmxhdFJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVycy9XZWJHbEZsYXQnKSxcbiAgV2ViR2xFcXVpcmVjdFJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVycy9XZWJHbEVxdWlyZWN0JyksXG4gIHJlZ2lzdGVyRGVmYXVsdFJlbmRlcmVyczogcmVxdWlyZSgnLi9yZW5kZXJlcnMvcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzJyksXG5cbiAgLy8gR2VvbWV0cmllcy5cbiAgQ3ViZUdlb21ldHJ5OiByZXF1aXJlKCcuL2dlb21ldHJpZXMvQ3ViZScpLFxuICBGbGF0R2VvbWV0cnk6IHJlcXVpcmUoJy4vZ2VvbWV0cmllcy9GbGF0JyksXG4gIEVxdWlyZWN0R2VvbWV0cnk6IHJlcXVpcmUoJy4vZ2VvbWV0cmllcy9FcXVpcmVjdCcpLFxuXG4gIC8vIFZpZXdzLlxuICBSZWN0aWxpbmVhclZpZXc6IHJlcXVpcmUoJy4vdmlld3MvUmVjdGlsaW5lYXInKSxcbiAgRmxhdFZpZXc6IHJlcXVpcmUoJy4vdmlld3MvRmxhdCcpLFxuXG4gIC8vIFNvdXJjZXMuXG4gIEltYWdlVXJsU291cmNlOiByZXF1aXJlKCcuL3NvdXJjZXMvSW1hZ2VVcmwnKSxcbiAgU2luZ2xlQXNzZXRTb3VyY2U6IHJlcXVpcmUoJy4vc291cmNlcy9TaW5nbGVBc3NldCcpLFxuXG4gIC8vIEFzc2V0cy5cbiAgU3RhdGljQXNzZXQ6IHJlcXVpcmUoJy4vYXNzZXRzL1N0YXRpYycpLFxuICBEeW5hbWljQXNzZXQ6IHJlcXVpcmUoJy4vYXNzZXRzL0R5bmFtaWMnKSxcblxuICAvLyBUZXh0dXJlIHN0b3JlLlxuICBUZXh0dXJlU3RvcmU6IHJlcXVpcmUoJy4vVGV4dHVyZVN0b3JlJyksXG5cbiAgLy8gTGF5ZXIuXG4gIExheWVyOiByZXF1aXJlKCcuL0xheWVyJyksXG5cbiAgLy8gUmVuZGVyIGxvb3AuXG4gIFJlbmRlckxvb3A6IHJlcXVpcmUoJy4vUmVuZGVyTG9vcCcpLFxuXG4gIC8vIENvbnRyb2xzLlxuICBLZXlDb250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL0tleScpLFxuICBEcmFnQ29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9EcmFnJyksXG4gIFF0dnJDb250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL1F0dnInKSxcbiAgU2Nyb2xsWm9vbUNvbnRyb2xNZXRob2Q6IHJlcXVpcmUoJy4vY29udHJvbHMvU2Nyb2xsWm9vbScpLFxuICBQaW5jaFpvb21Db250cm9sTWV0aG9kOiByZXF1aXJlKCcuL2NvbnRyb2xzL1BpbmNoWm9vbScpLFxuICBWZWxvY2l0eUNvbnRyb2xNZXRob2Q6IHJlcXVpcmUoJy4vY29udHJvbHMvVmVsb2NpdHknKSxcbiAgRWxlbWVudFByZXNzQ29udHJvbE1ldGhvZDogcmVxdWlyZSgnLi9jb250cm9scy9FbGVtZW50UHJlc3MnKSxcbiAgQ29udHJvbHM6IHJlcXVpcmUoJy4vY29udHJvbHMvQ29udHJvbHMnKSxcbiAgRHluYW1pY3M6IHJlcXVpcmUoJy4vY29udHJvbHMvRHluYW1pY3MnKSxcblxuICAvLyBIaWdoLWxldmVsIEFQSS5cbiAgVmlld2VyOiByZXF1aXJlKCcuL1ZpZXdlcicpLFxuICBTY2VuZTogcmVxdWlyZSgnLi9TY2VuZScpLFxuXG4gIC8vIEhvdHNwb3RzLlxuICBIb3RzcG90OiByZXF1aXJlKCcuL0hvdHNwb3QnKSxcbiAgSG90c3BvdENvbnRhaW5lcjogcmVxdWlyZSgnLi9Ib3RzcG90Q29udGFpbmVyJyksXG5cbiAgLy8gRWZmZWN0cy5cbiAgY29sb3JFZmZlY3RzOiByZXF1aXJlKCcuL2NvbG9yRWZmZWN0cycpLFxuXG4gIC8vIE1pc2NlbGxhbmVvdXMgZnVuY3Rpb25zLlxuICByZWdpc3RlckRlZmF1bHRDb250cm9sczogcmVxdWlyZSgnLi9jb250cm9scy9yZWdpc3RlckRlZmF1bHRDb250cm9scycpLFxuICBhdXRvcm90YXRlOiByZXF1aXJlKCcuL2F1dG9yb3RhdGUnKSxcblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9ucy5cbiAgdXRpbDoge1xuICAgIGFzeW5jOiByZXF1aXJlKCcuL3V0aWwvYXN5bmMnKSxcbiAgICBjYW5jZWxpemU6IHJlcXVpcmUoJy4vdXRpbC9jYW5jZWxpemUnKSxcbiAgICBjaGFpbjogcmVxdWlyZSgnLi91dGlsL2NoYWluJyksXG4gICAgY2xhbXA6IHJlcXVpcmUoJy4vdXRpbC9jbGFtcCcpLFxuICAgIGNsZWFyT3duUHJvcGVydGllczogcmVxdWlyZSgnLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpLFxuICAgIGNtcDogcmVxdWlyZSgnLi91dGlsL2NtcCcpLFxuICAgIGNvbXBvc2U6IHJlcXVpcmUoJy4vdXRpbC9jb21wb3NlJyksXG4gICAgY29udmVydEZvdjogcmVxdWlyZSgnLi91dGlsL2NvbnZlcnRGb3YnKSxcbiAgICBkZWNpbWFsOiByZXF1aXJlKCcuL3V0aWwvZGVjaW1hbCcpLFxuICAgIGRlZmF1bHRzOiByZXF1aXJlKCcuL3V0aWwvZGVmYXVsdHMnKSxcbiAgICBkZWZlcjogcmVxdWlyZSgnLi91dGlsL2RlZmVyJyksXG4gICAgZGVnVG9SYWQ6IHJlcXVpcmUoJy4vdXRpbC9kZWdUb1JhZCcpLFxuICAgIGRlbGF5OiByZXF1aXJlKCcuL3V0aWwvZGVsYXknKSxcbiAgICBkb206IHJlcXVpcmUoJy4vdXRpbC9kb20nKSxcbiAgICBleHRlbmQ6IHJlcXVpcmUoJy4vdXRpbC9leHRlbmQnKSxcbiAgICBoYXNoOiByZXF1aXJlKCcuL3V0aWwvaGFzaCcpLFxuICAgIGluaGVyaXRzOiByZXF1aXJlKCcuL3V0aWwvaW5oZXJpdHMnKSxcbiAgICBtb2Q6IHJlcXVpcmUoJy4vdXRpbC9tb2QnKSxcbiAgICBub29wOiByZXF1aXJlKCcuL3V0aWwvbm9vcCcpLFxuICAgIG5vdzogcmVxdWlyZSgnLi91dGlsL25vdycpLFxuICAgIG9uY2U6IHJlcXVpcmUoJy4vdXRpbC9vbmNlJyksXG4gICAgcGl4ZWxSYXRpbzogcmVxdWlyZSgnLi91dGlsL3BpeGVsUmF0aW8nKSxcbiAgICByYWRUb0RlZzogcmVxdWlyZSgnLi91dGlsL3JhZFRvRGVnJyksXG4gICAgcmVhbDogcmVxdWlyZSgnLi91dGlsL3JlYWwnKSxcbiAgICByZXRyeTogcmVxdWlyZSgnLi91dGlsL3JldHJ5JyksXG4gICAgdHdlZW46IHJlcXVpcmUoJy4vdXRpbC90d2VlbicpLFxuICAgIHR5cGU6IHJlcXVpcmUoJy4vdXRpbC90eXBlJylcbiAgfSxcblxuICAvLyBFeHBvc2UgZGVwZW5kZW5jaWVzIGZvciBjbGllbnRzIHRvIHVzZS5cbiAgZGVwZW5kZW5jaWVzOiB7XG4gICAgYm93c2VyOiByZXF1aXJlKCdib3dzZXInKSxcbiAgICBnbE1hdHJpeDogcmVxdWlyZSgnZ2wtbWF0cml4JyksXG4gICAgZXZlbnRFbWl0dGVyOiByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKSxcbiAgICBoYW1tZXJqczogcmVxdWlyZSgnaGFtbWVyanMnKVxuICB9XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RhdGljQXNzZXQgPSByZXF1aXJlKCcuLi9hc3NldHMvU3RhdGljJyk7XG52YXIgTmV0d29ya0Vycm9yID0gcmVxdWlyZSgnLi4vTmV0d29ya0Vycm9yJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJ2Jvd3NlcicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2xvYmFsJyk7XG52YXIgb25jZSA9IHJlcXVpcmUoJy4uL3V0aWwvb25jZScpO1xuXG4vLyBUT0RPOiBNb3ZlIHRoZSBsb2FkIHF1ZXVlIGludG8gdGhlIGxvYWRlci5cblxuLy8gV2hldGhlciB0byB1c2UgY3JlYXRlSW1hZ2VCaXRtYXAgaW5zdGVhZCBvZiBhIGNhbnZhcyBmb3IgY3JvcHBpbmcuXG4vLyBTZWUgaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPWNyZWF0ZWltYWdlYml0bWFwXG52YXIgdXNlQ3JlYXRlSW1hZ2VCaXRtYXAgPSAhIWdsb2JhbC5jcmVhdGVJbWFnZUJpdG1hcCAmJiAhYnJvd3Nlci5maXJlZm94ICYmICFicm93c2VyLnNhZmFyaTtcblxuLy8gT3B0aW9ucyBmb3IgY3JlYXRlSW1hZ2VCaXRtYXAuXG52YXIgY3JlYXRlSW1hZ2VCaXRtYXBPcHRzID0ge1xuICBpbWFnZU9yaWVudGF0aW9uOiAnZmxpcFknLFxuICBwcmVtdWx0aXBseUFscGhhOiAncHJlbXVsdGlwbHknXG59O1xuXG4vKipcbiAqIEBjbGFzcyBIdG1sSW1hZ2VMb2FkZXJcbiAqIEBpbXBsZW1lbnRzIEltYWdlTG9hZGVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgTG9hZGVyfSBmb3IgSFRNTCBpbWFnZXMuXG4gKlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHN0YWdlIHdoaWNoIGlzIGdvaW5nIHRvIHJlcXVlc3QgaW1hZ2VzIHRvIGJlIGxvYWRlZC5cbiAqL1xuZnVuY3Rpb24gSHRtbEltYWdlTG9hZGVyKHN0YWdlKSB7XG4gIHRoaXMuX3N0YWdlID0gc3RhZ2U7XG59XG5cbi8qKlxuICogTG9hZHMgYW4ge0BsaW5rIEFzc2V0fSBmcm9tIGFuIGltYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgaW1hZ2UgVVJMLlxuICogQHBhcmFtIHs/UmVjdH0gcmVjdCBBIHtAbGluayBSZWN0fSBkZXNjcmliaW5nIGEgcG9ydGlvbiBvZiB0aGUgaW1hZ2UsIG9yIG51bGxcbiAqICAgICB0byB1c2UgdGhlIGZ1bGwgaW1hZ2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvciwgQXNzZXQpfSBkb25lIFRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IEEgZnVuY3Rpb24gdG8gY2FuY2VsIGxvYWRpbmcuXG4gKi9cbkh0bWxJbWFnZUxvYWRlci5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJsLCByZWN0LCBkb25lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgLy8gQWxsb3cgY3Jvc3MtZG9tYWluIGltYWdlIGxvYWRpbmcuXG4gIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gYmUgYWJsZSB0byBjcmVhdGUgV2ViR0wgdGV4dHVyZXMgZnJvbSBpbWFnZXMgZmV0Y2hlZFxuICAvLyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpbi4gTm90ZSB0aGF0IHNldHRpbmcgdGhlIGNyb3Nzb3JpZ2luIGF0dHJpYnV0ZSB0b1xuICAvLyAnYW5vbnltb3VzJyB3aWxsIHRyaWdnZXIgYSBDT1JTIHByZWZsaWdodCBmb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBidXQgbm9cbiAgLy8gY3JlZGVudGlhbHMgKGNvb2tpZXMgb3IgSFRUUCBhdXRoKSB3aWxsIGJlIHNlbnQ7IHRvIGRvIHNvLCB0aGUgYXR0cmlidXRlXG4gIC8vIHdvdWxkIGhhdmUgdG8gYmUgc2V0IHRvICd1c2UtY3JlZGVudGlhbHMnIGluc3RlYWQuIFVuZm9ydHVuYXRlbHksIHRoaXMgaXNcbiAgLy8gbm90IGEgc2FmZSBjaG9pY2UsIGFzIGl0IGNhdXNlcyByZXF1ZXN0cyB0byBmYWlsIHdoZW4gdGhlIHJlc3BvbnNlIGNvbnRhaW5zXG4gIC8vIGFuIEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiBoZWFkZXIgd2l0aCBhIHdpbGRjYXJkLiBTZWUgdGhlIHNlY3Rpb25cbiAgLy8gXCJDcmVkZW50aWFsZWQgcmVxdWVzdHMgYW5kIHdpbGRjYXJkc1wiIG9uOlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0NPUlNcbiAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG5cbiAgdmFyIHggPSByZWN0ICYmIHJlY3QueCB8fCAwO1xuICB2YXIgeSA9IHJlY3QgJiYgcmVjdC55IHx8IDA7XG4gIHZhciB3aWR0aCA9IHJlY3QgJiYgcmVjdC53aWR0aCB8fCAxO1xuICB2YXIgaGVpZ2h0ID0gcmVjdCAmJiByZWN0LmhlaWdodCB8fCAxO1xuXG4gIGRvbmUgPSBvbmNlKGRvbmUpO1xuXG4gIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9oYW5kbGVMb2FkKGltZywgeCwgeSwgd2lkdGgsIGhlaWdodCwgZG9uZSk7XG4gIH07XG5cbiAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9oYW5kbGVFcnJvcih1cmwsIGRvbmUpO1xuICB9O1xuXG4gIGltZy5zcmMgPSB1cmw7XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgaW1nLnNyYyA9ICcnO1xuICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBjYW5jZWw7XG59O1xuXG5IdG1sSW1hZ2VMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24oaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkb25lKSB7XG4gIGlmICh4ID09PSAwICYmIHkgPT09IDAgJiYgd2lkdGggPT09IDEgJiYgaGVpZ2h0ID09PSAxKSB7XG4gICAgLy8gRmFzdCBwYXRoIGZvciB3aGVuIGNyb3BwaW5nIGlzIG5vdCBuZWVkZWQuXG4gICAgZG9uZShudWxsLCBuZXcgU3RhdGljQXNzZXQoaW1nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgeCAqPSBpbWcubmF0dXJhbFdpZHRoO1xuICB5ICo9IGltZy5uYXR1cmFsSGVpZ2h0O1xuICB3aWR0aCAqPSBpbWcubmF0dXJhbFdpZHRoO1xuICBoZWlnaHQgKj0gaW1nLm5hdHVyYWxIZWlnaHQ7XG5cbiAgaWYgKHVzZUNyZWF0ZUltYWdlQml0bWFwKSB7XG4gICAgLy8gUHJlZmVyIHRvIGNyb3AgdXNpbmcgY3JlYXRlSW1hZ2VCaXRtYXAsIHdoaWNoIGNhbiBwb3RlbnRpYWxseSBvZmZsb2FkXG4gICAgLy8gd29yayB0byBhbm90aGVyIHRocmVhZCBhbmQgYXZvaWQgYmxvY2tpbmcgdGhlIHVzZXIgaW50ZXJmYWNlLlxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBwcm9taXNlIGlzIG5ldmVyIHJlamVjdGVkLlxuICAgIGdsb2JhbC5jcmVhdGVJbWFnZUJpdG1hcChpbWcsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNyZWF0ZUltYWdlQml0bWFwT3B0cylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGJpdG1hcCkge1xuICAgICAgICBkb25lKG51bGwsIG5ldyBTdGF0aWNBc3NldChiaXRtYXApKTtcbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGwgYmFjayB0byBjcm9wcGluZyB1c2luZyBhIGNhbnZhcywgd2hpY2ggY2FuIHBvdGVudGlhbGx5IGJsb2NrIHRoZVxuICAgIC8vIHVzZXIgaW50ZXJmYWNlLCBidXQgaXMgdGhlIGJlc3Qgd2UgY2FuIGRvLlxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBkb25lKG51bGwsIG5ldyBTdGF0aWNBc3NldChjYW52YXMpKTtcbiAgfVxufTtcblxuSHRtbEltYWdlTG9hZGVyLnByb3RvdHlwZS5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbih1cmwsIGRvbmUpIHtcbiAgLy8gVE9ETzogaXMgdGhlcmUgYW55IHdheSB0byBkaXN0aW5ndWlzaCBhIG5ldHdvcmsgZXJyb3IgZnJvbSBvdGhlclxuICAvLyBraW5kcyBvZiBlcnJvcnM/IEZvciBub3cgd2UgYWx3YXlzIHJldHVybiBOZXR3b3JrRXJyb3Igc2luY2UgdGhpc1xuICAvLyBwcmV2ZW50cyBpbWFnZXMgdG8gYmUgcmV0cmllZCBjb250aW51b3VzbHkgd2hpbGUgd2UgYXJlIG9mZmxpbmUuXG4gIGRvbmUobmV3IE5ldHdvcmtFcnJvcignTmV0d29yayBlcnJvcjogJyArIHVybCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sSW1hZ2VMb2FkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCcuLi9OZXR3b3JrRXJyb3InKTtcbnZhciBvbmNlID0gcmVxdWlyZSgnLi4vdXRpbC9vbmNlJyk7XG5cbi8qKlxuICogQGNsYXNzIEh0bWxNb2RlbExvYWRlclxuICogQGltcGxlbWVudHMgTW9kZWxMb2FkZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBMb2FkZXJ9IGZvciBIVE1MIG1vZGVscy5cbiAqXG4gKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUgc3RhZ2Ugd2hpY2ggaXMgZ29pbmcgdG8gcmVxdWVzdCBpbWFnZXMgdG8gYmUgbG9hZGVkLlxuICovXG5mdW5jdGlvbiBIdG1sTW9kZWxMb2FkZXIoc3RhZ2UpIHtcbiAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhbiB7QGxpbmsgQXNzZXR9IGZyb20gYSAzRCBtb2RlbCBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgM0QgbW9kZWwgVVJMLlxuICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsIEFzc2V0KX0gZG9uZSBUaGUgY2FsbGJhY2suXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBBIGZ1bmN0aW9uIHRvIGNhbmNlbCBsb2FkaW5nLlxuICovXG5IdG1sTW9kZWxMb2FkZXIucHJvdG90eXBlLmxvYWRNb2RlbCA9IGZ1bmN0aW9uICh1cmwsIGRvbmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGRvbmUgPSBvbmNlKGRvbmUpO1xuXG4gIGZldGNoKHVybClcbiAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS50ZXh0KCkpXG4gICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICBzZWxmLl9oYW5kbGVMb2FkKGRhdGEsIGRvbmUpO1xuICAgIH0pXG4gICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHNlbGYuX2hhbmRsZUVycm9yKHVybCwgZG9uZSk7XG4gICAgfSk7XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBjYW5jZWw7XG59O1xuXG5IdG1sTW9kZWxMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGRhdGEsIGRvbmUpIHtcbiAgY29uc3QgcG9zaXRpb25zID0gW107XG4gIGNvbnN0IGluZGljZXMgPSBbXTtcblxuICAvLyBTcGxpdCB0aGUgU1RMIGRhdGEgaW50byBsaW5lc1xuICBjb25zdCBsaW5lcyA9IGRhdGEudHJpbSgpLnNwbGl0KCdcXG4nKTtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBsaW5lIHRvIGV4dHJhY3QgcG9zaXRpb25zIGFuZCBpbmRpY2VzXG4gIGxldCB2ZXJ0ZXhJbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuXG4gICAgaWYgKHBhcnRzWzBdID09PSAndmVydGV4Jykge1xuICAgICAgLy8gUGFyc2UgdmVydGV4IHBvc2l0aW9uIGFuZCBhZGQgaXQgdG8gdGhlIHBvc2l0aW9ucyBhcnJheVxuICAgICAgY29uc3QgdmVydGV4ID0gbGluZS50cmltKCkuc3BsaXQoL1xccysvKS5zbGljZSgxKS5tYXAocGFyc2VGbG9hdCk7XG5cbiAgICAgIGNvbnN0IHggPSB2ZXJ0ZXhbMF07XG4gICAgICBjb25zdCB6ID0gdmVydGV4WzFdO1xuICAgICAgY29uc3QgeSA9IHZlcnRleFsyXTtcblxuICAgICAgLy9wb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHosIHksIHgpO1xuICAgICAgLy9wb3NpdGlvbnMucHVzaCgteCwgLXksIC16KTtcbiAgICAgIHZlcnRleEluZGV4Kys7XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJ2ZhY2V0Jykge1xuICAgICAgLy8gU2tpcCB0aGUgZmFjZXQgbm9ybWFsIGxpbmVcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnZW5kbG9vcCcpIHtcbiAgICAgIC8vIENyZWF0ZSBmYWNlIGJ5IGFkZGluZyB2ZXJ0ZXggaW5kaWNlc1xuICAgICAgaW5kaWNlcy5wdXNoKHZlcnRleEluZGV4IC0gMywgdmVydGV4SW5kZXggLSAyLCB2ZXJ0ZXhJbmRleCAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIGRvbmUobnVsbCwgeyBwb3NpdGlvbnMsIGluZGljZXMgfSk7XG59O1xuXG5IdG1sTW9kZWxMb2FkZXIucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uICh1cmwsIGRvbmUpIHtcbiAgLy8gVE9ETzogaXMgdGhlcmUgYW55IHdheSB0byBkaXN0aW5ndWlzaCBhIG5ldHdvcmsgZXJyb3IgZnJvbSBvdGhlclxuICAvLyBraW5kcyBvZiBlcnJvcnM/IEZvciBub3cgd2UgYWx3YXlzIHJldHVybiBOZXR3b3JrRXJyb3Igc2luY2UgdGhpc1xuICAvLyBwcmV2ZW50cyBpbWFnZXMgdG8gYmUgcmV0cmllZCBjb250aW51b3VzbHkgd2hpbGUgd2UgYXJlIG9mZmxpbmUuXG4gIGRvbmUobmV3IE5ldHdvcmtFcnJvcignTmV0d29yayBlcnJvcjogJyArIHVybCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sTW9kZWxMb2FkZXI7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgdmVjMyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzM7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIFdlYkdsQ29tbW9uID0gcmVxdWlyZSgnLi9XZWJHbENvbW1vbicpO1xudmFyIGNyZWF0ZUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmNyZWF0ZUNvbnN0YW50QnVmZmVycztcbnZhciBkZXN0cm95Q29uc3RhbnRCdWZmZXJzID0gV2ViR2xDb21tb24uZGVzdHJveUNvbnN0YW50QnVmZmVycztcbnZhciBjcmVhdGVTaGFkZXJQcm9ncmFtID0gV2ViR2xDb21tb24uY3JlYXRlU2hhZGVyUHJvZ3JhbTtcbnZhciBkZXN0cm95U2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lTaGFkZXJQcm9ncmFtO1xudmFyIGVuYWJsZUF0dHJpYnV0ZXMgPSBXZWJHbENvbW1vbi5lbmFibGVBdHRyaWJ1dGVzO1xudmFyIGRpc2FibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZGlzYWJsZUF0dHJpYnV0ZXM7XG52YXIgc2V0Vmlld3BvcnQgPSBXZWJHbENvbW1vbi5zZXRWaWV3cG9ydDtcbnZhciBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXMgPSBXZWJHbENvbW1vbi5zZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXM7XG5cbnZhciBzZXREZXB0aCA9IFdlYkdsQ29tbW9uLnNldERlcHRoO1xudmFyIHNldFRleHR1cmUgPSBXZWJHbENvbW1vbi5zZXRUZXh0dXJlO1xuXG52YXIgdmVydGV4U3JjID0gcmVxdWlyZSgnLi4vc2hhZGVycy92ZXJ0ZXhOb3JtYWwnKTtcbnZhciBmcmFnbWVudFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvZnJhZ21lbnROb3JtYWwnKTtcblxudmFyIHZlcnRleEluZGljZXMgPSBbMCwgMSwgMiwgMCwgMiwgM107XG52YXIgdmVydGV4UG9zaXRpb25zID0gWy0wLjUsIC0wLjUsIDAuMCwgMC41LCAtMC41LCAwLjAsIDAuNSwgMC41LCAwLjAsIC0wLjUsIDAuNSwgMC4wXTtcbnZhciB0ZXh0dXJlQ29vcmRzID0gWzAuMCwgMC4wLCAxLjAsIDAuMCwgMS4wLCAxLjAsIDAuMCwgMS4wXTtcblxudmFyIGF0dHJpYkxpc3QgPSBbJ2FWZXJ0ZXhQb3NpdGlvbicsICdhVGV4dHVyZUNvb3JkJ107XG52YXIgdW5pZm9ybUxpc3QgPSBbXG4gICd1RGVwdGgnLCAndU9wYWNpdHknLCAndVNhbXBsZXInLCAndVByb2pNYXRyaXgnLCAndVZpZXdNYXRyaXgnLCAndU1vZGVsTWF0cml4JywgJ3VWaWV3cG9ydE1hdHJpeCcsXG4gICd1Q29sb3JPZmZzZXQnLCAndUNvbG9yTWF0cml4J1xuXTtcblxuXG5mdW5jdGlvbiBXZWJHbEJhc2VSZW5kZXJlcihnbCkge1xuICB0aGlzLmdsID0gZ2w7XG5cbiAgLy8gVGhlIHByb2plY3Rpb24gbWF0cml4IHBvc2l0aW9ucyB0aGUgdGlsZXMgaW4gd29ybGQgc3BhY2UuXG4gIC8vIFdlIGNvbXB1dGUgaXQgaW4gSmF2YXNjcmlwdCBiZWNhdXNlIGxhY2sgb2YgcHJlY2lzaW9uIGluIHRoZSB2ZXJ0ZXggc2hhZGVyXG4gIC8vIGNhdXNlcyBzZWFtcyB0byBhcHBlYXIgYmV0d2VlbiBhZGphY2VudCB0aWxlcyBhdCBsYXJnZSB6b29tIGxldmVscy5cbiAgdGhpcy5wcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUT0RPIFdoeSBzYXZlIHRoaXMgdmFsdWUgaGVyZT8gdGhlIHNhbWUgcXVlc3Rpb24gdG8gdGhlIHByb2pNYXRyaXguXG4gIHRoaXMudmlld01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVGhlIHZpZXdwb3J0IG1hdHJpeCByZXNwb25zaWJsZSBmb3Igdmlld3BvcnQgY2xhbXBpbmcuXG4gIC8vIFNlZSBzZXRWaWV3cG9ydCgpIGZvciBhbiBleHBsYW5hdGlvbiBvZiBob3cgaXQgd29ya3MuXG4gIHRoaXMudmlld3BvcnRNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRyYW5zbGF0aW9uIGFuZCBzY2FsZSB2ZWN0b3JzIGZvciB0aWxlcy5cbiAgdGhpcy50cmFuc2xhdGVWZWN0b3IgPSB2ZWMzLmNyZWF0ZSgpO1xuICB0aGlzLnNjYWxlVmVjdG9yID0gdmVjMy5jcmVhdGUoKTtcblxuICB0aGlzLmNvbnN0YW50QnVmZmVycyA9IGNyZWF0ZUNvbnN0YW50QnVmZmVycyhnbCwgdmVydGV4SW5kaWNlcywgdmVydGV4UG9zaXRpb25zLCB0ZXh0dXJlQ29vcmRzKTtcblxuICB0aGlzLnNoYWRlclByb2dyYW0gPSBjcmVhdGVTaGFkZXJQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJMaXN0LCB1bmlmb3JtTGlzdCk7XG59XG5cbldlYkdsQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnModGhpcy5nbCwgdGhpcy5jb25zdGFudEJ1ZmZlcnMpO1xuICBkZXN0cm95U2hhZGVyUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnNoYWRlclByb2dyYW0pO1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5XZWJHbEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc3RhcnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICB2YXIgY29uc3RhbnRCdWZmZXJzID0gdGhpcy5jb25zdGFudEJ1ZmZlcnM7XG4gIHZhciB2aWV3cG9ydE1hdHJpeCA9IHRoaXMudmlld3BvcnRNYXRyaXg7XG5cbiAgZ2wudXNlUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcblxuICBlbmFibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKTtcblxuICBzZXRWaWV3cG9ydChnbCwgbGF5ZXIsIHJlY3QsIHZpZXdwb3J0TWF0cml4KTtcbiAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtLnVWaWV3cG9ydE1hdHJpeCwgZmFsc2UsIHZpZXdwb3J0TWF0cml4KTtcblxuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgY29uc3RhbnRCdWZmZXJzLnZlcnRleFBvc2l0aW9ucyk7XG4gIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbS5hVmVydGV4UG9zaXRpb24sIDMsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgMCk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudGV4dHVyZUNvb3Jkcyk7XG4gIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbS5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZ2wuRkFMU0UsIDAsIDApO1xuXG4gIHNldHVwUGl4ZWxFZmZlY3RVbmlmb3JtcyhnbCwgbGF5ZXIuZWZmZWN0cygpLCB7XG4gICAgb3BhY2l0eTogc2hhZGVyUHJvZ3JhbS51T3BhY2l0eSxcbiAgICBjb2xvck9mZnNldDogc2hhZGVyUHJvZ3JhbS51Q29sb3JPZmZzZXQsXG4gICAgY29sb3JNYXRyaXg6IHNoYWRlclByb2dyYW0udUNvbG9yTWF0cml4XG4gIH0pO1xufTtcblxuXG5XZWJHbEJhc2VSZW5kZXJlci5wcm90b3R5cGUuZW5kTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgcmVjdCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgZGlzYWJsZUF0dHJpYnV0ZXMoZ2wsIHNoYWRlclByb2dyYW0pO1xufTtcblxuXG5XZWJHbEJhc2VSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGlsZSA9IGZ1bmN0aW9uKHRpbGUsIHRleHR1cmUsIGxheWVyLCBsYXllclopIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIHZhciBjb25zdGFudEJ1ZmZlcnMgPSB0aGlzLmNvbnN0YW50QnVmZmVycztcbiAgdmFyIHByb2pNYXRyaXggPSB0aGlzLnByb2pNYXRyaXg7XG4gIHZhciB2aWV3TWF0cml4ID0gdGhpcy52aWV3TWF0cml4O1xuICB2YXIgdHJhbnNsYXRlVmVjdG9yID0gdGhpcy50cmFuc2xhdGVWZWN0b3I7XG4gIHZhciBzY2FsZVZlY3RvciA9IHRoaXMuc2NhbGVWZWN0b3I7XG5cbiAgbWF0NC5jb3B5KHByb2pNYXRyaXgsIGxheWVyLnZpZXcoKS5wcm9qZWN0aW9uKCkpO1xuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udVByb2pNYXRyaXgsIGZhbHNlLCBwcm9qTWF0cml4KTtcblxuICBtYXQ0LmNvcHkodmlld01hdHJpeCwgbGF5ZXIudmlldygpLnZpZXdNYXRyaXgoKSk7XG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51Vmlld01hdHJpeCwgZmFsc2UsIHZpZXdNYXRyaXgpO1xuICBcbiAgLy8gR2VuZXJhdGUgTW9kZWxNYXRyaXguXG4gIC8vIFRPRE8gQ2FjaGUgdGhlIG1hdHJpeCBpbiB0aGUgdGlsZSBvYmplY3Q/XG4gIHRyYW5zbGF0ZVZlY3RvclswXSA9IHRpbGUuY2VudGVyWCgpO1xuICB0cmFuc2xhdGVWZWN0b3JbMV0gPSB0aWxlLmNlbnRlclkoKTtcbiAgdHJhbnNsYXRlVmVjdG9yWzJdID0gLTAuNTtcblxuICBzY2FsZVZlY3RvclswXSA9IHRpbGUuc2NhbGVYKCk7XG4gIHNjYWxlVmVjdG9yWzFdID0gdGlsZS5zY2FsZVkoKTtcbiAgc2NhbGVWZWN0b3JbMl0gPSAxLjA7XG5cbiAgdmFyIG1vZGVsTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgbWF0NC5yb3RhdGVYKG1vZGVsTWF0cml4LCBtb2RlbE1hdHJpeCwgdGlsZS5yb3RYKCkpO1xuICBtYXQ0LnJvdGF0ZVkobW9kZWxNYXRyaXgsIG1vZGVsTWF0cml4LCB0aWxlLnJvdFkoKSk7XG4gIG1hdDQudHJhbnNsYXRlKG1vZGVsTWF0cml4LCBtb2RlbE1hdHJpeCwgdHJhbnNsYXRlVmVjdG9yKTtcbiAgbWF0NC5zY2FsZShtb2RlbE1hdHJpeCwgbW9kZWxNYXRyaXgsIHNjYWxlVmVjdG9yKTtcblxuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udU1vZGVsTWF0cml4LCBmYWxzZSwgbW9kZWxNYXRyaXgpO1xuXG4gIHNldERlcHRoKGdsLCBzaGFkZXJQcm9ncmFtLCBsYXllclosIHRpbGUueik7XG4gIHNldFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIHRleHR1cmUpO1xuXG4gIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhJbmRpY2VzKTtcbiAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdmVydGV4SW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEJhc2VSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlc2UgYXJlIHVzZWQgdG8gc2V0IHRoZSBXZWJHbCBkZXB0aCBmb3IgYSB0aWxlLlxudmFyIE1BWF9MQVlFUlMgPSAyNTY7IC8vIE1heCBudW1iZXIgb2YgbGF5ZXJzIHBlciBzdGFnZS5cbnZhciBNQVhfTEVWRUxTID0gMjU2OyAvLyBNYXggbnVtYmVyIG9mIGxldmVscyBwZXIgbGF5ZXIuXG5cbnZhciBjbGFtcCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhbXAnKTtcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcbnZhciB2ZWMzID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMztcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcblxuXG5mdW5jdGlvbiBjcmVhdGVTaGFkZXIoZ2wsIHR5cGUsIHNyYykge1xuICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgdGhyb3cgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICB9XG4gIHJldHVybiBzaGFkZXI7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmliTGlzdCwgdW5pZm9ybUxpc3QpIHtcblxuICB2YXIgdmVydGV4U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTcmMpO1xuICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTcmMpO1xuXG4gIHZhciBzaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcblxuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgdGhyb3cgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyUHJvZ3JhbSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0cmliID0gYXR0cmliTGlzdFtpXTtcbiAgICBzaGFkZXJQcm9ncmFtW2F0dHJpYl0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBhdHRyaWIpO1xuICAgIGlmIChzaGFkZXJQcm9ncmFtW2F0dHJpYl0gPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRlciBwcm9ncmFtIGhhcyBubyAnICsgYXR0cmliICsgJyBhdHRyaWJ1dGUnKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHVuaWZvcm1MaXN0Lmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHVuaWZvcm0gPSB1bmlmb3JtTGlzdFtqXTtcbiAgICBzaGFkZXJQcm9ncmFtW3VuaWZvcm1dID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIHVuaWZvcm0pO1xuICAgIGlmIChzaGFkZXJQcm9ncmFtW3VuaWZvcm1dID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgcHJvZ3JhbSBoYXMgbm8gJyArIHVuaWZvcm0gKyAnIHVuaWZvcm0nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hhZGVyUHJvZ3JhbTtcbn1cblxuXG5mdW5jdGlvbiBkZXN0cm95U2hhZGVyUHJvZ3JhbShnbCwgc2hhZGVyUHJvZ3JhbSkge1xuICB2YXIgc2hhZGVyTGlzdCA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhzaGFkZXJQcm9ncmFtKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFkZXJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoYWRlciA9IHNoYWRlckxpc3RbaV07XG4gICAgZ2wuZGV0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHNoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gIH1cbiAgZ2wuZGVsZXRlUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVDb25zdGFudEJ1ZmZlcihnbCwgdGFyZ2V0LCB1c2FnZSwgdmFsdWUpIHtcbiAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBnbC5iaW5kQnVmZmVyKHRhcmdldCwgYnVmZmVyKTtcbiAgZ2wuYnVmZmVyRGF0YSh0YXJnZXQsIHZhbHVlLCB1c2FnZSk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlQ29uc3RhbnRCdWZmZXJzKGdsLCB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIHRleHR1cmVDb29yZHMpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJ0ZXhJbmRpY2VzOiBjcmVhdGVDb25zdGFudEJ1ZmZlcihnbCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXLCBuZXcgVWludDE2QXJyYXkodmVydGV4SW5kaWNlcykpLFxuICAgIHZlcnRleFBvc2l0aW9uczogY3JlYXRlQ29uc3RhbnRCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG5ldyBGbG9hdDMyQXJyYXkodmVydGV4UG9zaXRpb25zKSksXG4gICAgdGV4dHVyZUNvb3JkczogY3JlYXRlQ29uc3RhbnRCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcsIG5ldyBGbG9hdDMyQXJyYXkodGV4dHVyZUNvb3JkcykpXG4gIH07XG59XG5cblxuZnVuY3Rpb24gZGVzdHJveUNvbnN0YW50QnVmZmVycyhnbCwgY29uc3RhbnRCdWZmZXJzKSB7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihjb25zdGFudEJ1ZmZlcnMudmVydGV4SW5kaWNlcyk7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihjb25zdGFudEJ1ZmZlcnMudmVydGV4UG9zaXRpb25zKTtcbiAgZ2wuZGVsZXRlQnVmZmVyKGNvbnN0YW50QnVmZmVycy50ZXh0dXJlQ29vcmRzKTtcbn1cblxuXG5mdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKSB7XG4gIHZhciBudW1BdHRycyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF0dHJzOyBpKyspIHtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGRpc2FibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKSB7XG4gIHZhciBudW1BdHRycyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF0dHJzOyBpKyspIHtcbiAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZXRUZXh0dXJlKGdsLCBzaGFkZXJQcm9ncmFtLCB0ZXh0dXJlKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl90ZXh0dXJlKTtcbiAgZ2wudW5pZm9ybTFpKHNoYWRlclByb2dyYW0udVNhbXBsZXIsIDApO1xufVxuXG5mdW5jdGlvbiBzZXREZXB0aG1hcFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIHRleHR1cmUpIHtcbiAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX3RleHR1cmUpO1xuICBnbC51bmlmb3JtMWkoc2hhZGVyUHJvZ3JhbS51RGVwdGhtYXAsIDEpO1xufVxuXG5mdW5jdGlvbiBzZXREZXB0aG1hcEN1YmVUZXh0dXJlKGdsLCBzaGFkZXJQcm9ncmFtLCB0ZXh0dXJlKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlKTtcbiAgZ2wudW5pZm9ybTFpKHNoYWRlclByb2dyYW0udURlcHRobWFwLCAxKTtcbn1cblxuZnVuY3Rpb24gc2V0RGVwdGgoZ2wsIHNoYWRlclByb2dyYW0sIGxheWVyWiwgdGlsZVopIHtcbiAgdmFyIGRlcHRoID0gKCgobGF5ZXJaICsgMSkgKiBNQVhfTEVWRUxTKSAtIHRpbGVaKSAvIChNQVhfTEVWRUxTICogTUFYX0xBWUVSUyk7XG4gIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtLnVEZXB0aCwgZGVwdGgpO1xufVxuXG5cbnZhciBkZWZhdWx0T3BhY2l0eSA9IDEuMDtcbnZhciBkZWZhdWx0Q29sb3JPZmZzZXQgPSB2ZWM0LmNyZWF0ZSgpO1xudmFyIGRlZmF1bHRDb2xvck1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5tYXQ0LmlkZW50aXR5KGRlZmF1bHRDb2xvck1hdHJpeCk7XG5cbmZ1bmN0aW9uIHNldHVwUGl4ZWxFZmZlY3RVbmlmb3JtcyhnbCwgZWZmZWN0cywgdW5pZm9ybXMpIHtcbiAgdmFyIG9wYWNpdHkgPSBkZWZhdWx0T3BhY2l0eTtcbiAgaWYgKGVmZmVjdHMgJiYgZWZmZWN0cy5vcGFjaXR5ICE9IG51bGwpIHtcbiAgICBvcGFjaXR5ID0gZWZmZWN0cy5vcGFjaXR5O1xuICB9XG4gIGdsLnVuaWZvcm0xZih1bmlmb3Jtcy5vcGFjaXR5LCBvcGFjaXR5KTtcblxuICB2YXIgY29sb3JPZmZzZXQgPSBkZWZhdWx0Q29sb3JPZmZzZXQ7XG4gIGlmIChlZmZlY3RzICYmIGVmZmVjdHMuY29sb3JPZmZzZXQpIHtcbiAgICBjb2xvck9mZnNldCA9IGVmZmVjdHMuY29sb3JPZmZzZXQ7XG4gIH1cbiAgZ2wudW5pZm9ybTRmdih1bmlmb3Jtcy5jb2xvck9mZnNldCwgY29sb3JPZmZzZXQpO1xuXG4gIHZhciBjb2xvck1hdHJpeCA9IGRlZmF1bHRDb2xvck1hdHJpeDtcbiAgaWYgKGVmZmVjdHMgJiYgZWZmZWN0cy5jb2xvck1hdHJpeCkge1xuICAgIGNvbG9yTWF0cml4ID0gZWZmZWN0cy5jb2xvck1hdHJpeDtcbiAgfVxuICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1zLmNvbG9yTWF0cml4LCBmYWxzZSwgY29sb3JNYXRyaXgpO1xufVxuXG5cbi8vIFRlbXBvcmFyeSB2ZWN0b3JzIGZvciBzZXRWaWV3cG9ydC5cbnZhciB0cmFuc2xhdGVWZWN0b3IgPSB2ZWMzLmNyZWF0ZSgpO1xudmFyIHNjYWxlVmVjdG9yID0gdmVjMy5jcmVhdGUoKTtcblxuXG4vLyBTZXRzIHRoZSBXZWJHTCB2aWV3cG9ydCBhbmQgcmV0dXJucyBhIHZpZXdwb3J0IGNsYW1waW5nIGNvbXBlbnNhdGlvbiBtYXRyaXguXG4vL1xuLy8gTmVnYXRpdmUgdmlld3BvcnQgb3JpZ2luIGNvb3JkaW5hdGVzIGNhdXNlIHJlbmRlcmluZyBpc3N1ZXMuIExldHRpbmcgdGhlXG4vLyB2aWV3cG9ydCBkaW1lbnNpb25zIGV4dGVuZCBiZXlvbmQgdGhlIHZpc2libGUgYXJlYSBkbyBub3Qgc2VlbSB0byBjYXVzZVxuLy8gcmVuZGVyaW5nIGlzc3VlcywgYnV0IHRoZXkgbWF5IHN0aWxsIGhhdmUgYW4gaW1wYWN0IG9uIHBlcmZvcm1hbmNlLlxuLy8gVGhlcmVmb3JlLCB3aGVuIHRoZSBzY2VuZSdzIHJlY3QgaXMgbm90IGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGUgcmVuZGVyaW5nXG4vLyBhcmVhLCB3ZSBjbGFtcCB0aGUgdmlld3BvcnQgdG8gdGhlIHJlbmRlcmluZyBhcmVhLCBhbmQgcmV0dXJuIGEgY29tcGVuc2F0aW9uXG4vLyBtYXRyaXggdG8gc2NhbGUgYW5kIHRyYW5zbGF0ZSB2ZXJ0aWNlcyBhY2NvcmRpbmdseS5cbmZ1bmN0aW9uIHNldFZpZXdwb3J0KGdsLCBsYXllciwgcmVjdCwgdmlld3BvcnRNYXRyaXgpIHtcbiAgaWYgKHJlY3QueCA9PT0gMCAmJiByZWN0LndpZHRoID09PSAxICYmIHJlY3QueSA9PT0gMCAmJiByZWN0LmhlaWdodCA9PT0gMSkge1xuICAgIC8vIEZhc3QgcGF0aCBmb3IgZnVsbCByZWN0LlxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgbWF0NC5pZGVudGl0eSh2aWV3cG9ydE1hdHJpeCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9mZnNldFggPSByZWN0Lng7XG4gIHZhciBjbGFtcGVkT2Zmc2V0WCA9IGNsYW1wKG9mZnNldFgsIDAsIDEpO1xuICB2YXIgbGVmdEV4Y2VzcyA9IGNsYW1wZWRPZmZzZXRYIC0gb2Zmc2V0WDtcbiAgdmFyIG1heENsYW1wZWRXaWR0aCA9IDEgLSBjbGFtcGVkT2Zmc2V0WDtcbiAgdmFyIGNsYW1wZWRXaWR0aCA9IGNsYW1wKHJlY3Qud2lkdGggLSBsZWZ0RXhjZXNzLCAwLCBtYXhDbGFtcGVkV2lkdGgpO1xuICB2YXIgcmlnaHRFeGNlc3MgPSByZWN0LndpZHRoIC0gY2xhbXBlZFdpZHRoO1xuXG4gIHZhciBvZmZzZXRZID0gMSAtIHJlY3QuaGVpZ2h0IC0gcmVjdC55O1xuICB2YXIgY2xhbXBlZE9mZnNldFkgPSBjbGFtcChvZmZzZXRZLCAwLCAxKTtcbiAgdmFyIGJvdHRvbUV4Y2VzcyA9IGNsYW1wZWRPZmZzZXRZIC0gb2Zmc2V0WTtcbiAgdmFyIG1heENsYW1wZWRIZWlnaHQgPSAxIC0gY2xhbXBlZE9mZnNldFk7XG4gIHZhciBjbGFtcGVkSGVpZ2h0ID0gY2xhbXAocmVjdC5oZWlnaHQgLSBib3R0b21FeGNlc3MsIDAsIG1heENsYW1wZWRIZWlnaHQpO1xuICB2YXIgdG9wRXhjZXNzID0gcmVjdC5oZWlnaHQgLSBjbGFtcGVkSGVpZ2h0O1xuXG4gIHZlYzMuc2V0KFxuICAgIHNjYWxlVmVjdG9yLFxuICAgIHJlY3Qud2lkdGggLyBjbGFtcGVkV2lkdGgsXG4gICAgcmVjdC5oZWlnaHQgLyBjbGFtcGVkSGVpZ2h0LFxuICAgIDEpO1xuXG4gIHZlYzMuc2V0KFxuICAgIHRyYW5zbGF0ZVZlY3RvcixcbiAgICAocmlnaHRFeGNlc3MgLSBsZWZ0RXhjZXNzKSAvIGNsYW1wZWRXaWR0aCxcbiAgICAodG9wRXhjZXNzIC0gYm90dG9tRXhjZXNzKSAvIGNsYW1wZWRIZWlnaHQsXG4gICAgMCk7XG5cbiAgbWF0NC5pZGVudGl0eSh2aWV3cG9ydE1hdHJpeCk7XG4gIG1hdDQudHJhbnNsYXRlKHZpZXdwb3J0TWF0cml4LCB2aWV3cG9ydE1hdHJpeCwgdHJhbnNsYXRlVmVjdG9yKTtcbiAgbWF0NC5zY2FsZSh2aWV3cG9ydE1hdHJpeCwgdmlld3BvcnRNYXRyaXgsIHNjYWxlVmVjdG9yKTtcblxuICBnbC52aWV3cG9ydChnbC5kcmF3aW5nQnVmZmVyV2lkdGggKiBjbGFtcGVkT2Zmc2V0WCxcbiAgICAgICAgICAgICAgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAqIGNsYW1wZWRPZmZzZXRZLFxuICAgICAgICAgICAgICBnbC5kcmF3aW5nQnVmZmVyV2lkdGggKiBjbGFtcGVkV2lkdGgsXG4gICAgICAgICAgICAgIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgKiBjbGFtcGVkSGVpZ2h0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVNoYWRlclByb2dyYW06IGNyZWF0ZVNoYWRlclByb2dyYW0sXG4gIGRlc3Ryb3lTaGFkZXJQcm9ncmFtOiBkZXN0cm95U2hhZGVyUHJvZ3JhbSxcbiAgY3JlYXRlQ29uc3RhbnRCdWZmZXJzOiBjcmVhdGVDb25zdGFudEJ1ZmZlcnMsXG4gIGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM6IGRlc3Ryb3lDb25zdGFudEJ1ZmZlcnMsXG4gIGVuYWJsZUF0dHJpYnV0ZXM6IGVuYWJsZUF0dHJpYnV0ZXMsXG4gIGRpc2FibGVBdHRyaWJ1dGVzOiBkaXNhYmxlQXR0cmlidXRlcyxcbiAgc2V0VGV4dHVyZTogc2V0VGV4dHVyZSxcbiAgc2V0RGVwdGhtYXBUZXh0dXJlOiBzZXREZXB0aG1hcFRleHR1cmUsXG4gIHNldERlcHRobWFwQ3ViZVRleHR1cmU6IHNldERlcHRobWFwQ3ViZVRleHR1cmUsXG4gIHNldERlcHRoOiBzZXREZXB0aCxcbiAgc2V0Vmlld3BvcnQ6IHNldFZpZXdwb3J0LFxuICBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXM6IHNldHVwUGl4ZWxFZmZlY3RVbmlmb3Jtc1xufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFdlYkdsQmFzZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9XZWJHbEJhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcblxuLyoqXG4gKiBAY2xhc3MgV2ViR2xDdWJlUmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEN1YmVHZW9tZXRyeX0gYW5kIHtAbGluayBSZWN0aWxpbmVhclZpZXd9LCBhcHByb3ByaWF0ZVxuICogZm9yIGEge0BsaW5rIFdlYkdsU3RhZ2V9LlxuICpcbiAqIE1vc3QgdXNlcnMgZG8gbm90IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcyBjbGFzcy4gUmVuZGVyZXJzIGFyZSBjcmVhdGVkIGFuZFxuICogZGVzdHJveWVkIGJ5IHtAbGluayBTdGFnZX0gYXMgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBXZWJHbEN1YmVSZW5kZXJlcigpIHtcbiAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdHMoV2ViR2xDdWJlUmVuZGVyZXIsIFdlYkdsQmFzZVJlbmRlcmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHbEN1YmVSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzMgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWMzO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBXZWJHbENvbW1vbiA9IHJlcXVpcmUoJy4vV2ViR2xDb21tb24nKTtcbnZhciBjcmVhdGVDb25zdGFudEJ1ZmZlcnMgPSBXZWJHbENvbW1vbi5jcmVhdGVDb25zdGFudEJ1ZmZlcnM7XG52YXIgZGVzdHJveUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lDb25zdGFudEJ1ZmZlcnM7XG52YXIgY3JlYXRlU2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmNyZWF0ZVNoYWRlclByb2dyYW07XG52YXIgZGVzdHJveVNoYWRlclByb2dyYW0gPSBXZWJHbENvbW1vbi5kZXN0cm95U2hhZGVyUHJvZ3JhbTtcbnZhciBlbmFibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZW5hYmxlQXR0cmlidXRlcztcbnZhciBkaXNhYmxlQXR0cmlidXRlcyA9IFdlYkdsQ29tbW9uLmRpc2FibGVBdHRyaWJ1dGVzO1xudmFyIHNldFZpZXdwb3J0ID0gV2ViR2xDb21tb24uc2V0Vmlld3BvcnQ7XG52YXIgc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zID0gV2ViR2xDb21tb24uc2V0dXBQaXhlbEVmZmVjdFVuaWZvcm1zO1xuXG52YXIgc2V0RGVwdGggPSBXZWJHbENvbW1vbi5zZXREZXB0aDtcbnZhciBzZXRUZXh0dXJlID0gV2ViR2xDb21tb24uc2V0VGV4dHVyZTtcbnZhciBzZXREZXB0aG1hcFRleHR1cmUgPSBXZWJHbENvbW1vbi5zZXREZXB0aG1hcFRleHR1cmU7XG52YXIgc2V0RGVwdGhtYXBDdWJlVGV4dHVyZSA9IFdlYkdsQ29tbW9uLnNldERlcHRobWFwQ3ViZVRleHR1cmU7XG5cbnZhciB2ZXJ0ZXhTcmMgPSByZXF1aXJlKCcuLi9zaGFkZXJzL3ZlcnRleEN1YmVEZXB0aCcpO1xudmFyIGZyYWdtZW50U3JjID0gcmVxdWlyZSgnLi4vc2hhZGVycy9mcmFnbWVudEN1YmVEZXB0aCcpO1xudmFyIHZlcnRleFNUTFNyYyA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvdmVydGV4Q3ViZURlcHRoU1RMJyk7XG5cbi8vIEluaXRpYWxpemUgYXJyYXlzIGZvciB2ZXJ0ZXhJbmRpY2VzLCB2ZXJ0ZXhQb3NpdGlvbnMsIGFuZCB0ZXh0dXJlQ29vcmRzXG52YXIgdmVydGV4SW5kaWNlcyA9IFtdO1xudmFyIHZlcnRleFBvc2l0aW9ucyA9IFtdO1xudmFyIHRleHR1cmVDb29yZHMgPSBbXTtcblxudmFyIGRlZmF1bHRXaWR0aFNlZ21lbnRzID0gNDA7XG52YXIgZGVmYXVsdEhlaWdodFNlZ21lbnRzID0gNDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleERhdGFzKHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzKSB7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggcm93IGFuZCBjb2x1bW4gdG8gZ2VuZXJhdGUgdmVydGljZXMsIHRleHR1cmUgY29vcmRpbmF0ZXMsIGFuZCBpbmRpY2VzXG4gIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8PSBoZWlnaHRTZWdtZW50czsgcm93KyspIHtcbiAgICB2YXIgdiA9IHJvdyAvIGhlaWdodFNlZ21lbnRzO1xuICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8PSB3aWR0aFNlZ21lbnRzOyBjb2wrKykge1xuICAgICAgdmFyIHUgPSBjb2wgLyB3aWR0aFNlZ21lbnRzO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdmVydGV4IHBvc2l0aW9uc1xuICAgICAgdmFyIHggPSB1IC0gMC41O1xuICAgICAgdmFyIHkgPSB2IC0gMC41O1xuICAgICAgdmFyIHogPSAwLjA7XG4gICAgICB2ZXJ0ZXhQb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRleHR1cmUgY29vcmRpbmF0ZXNcbiAgICAgIHRleHR1cmVDb29yZHMucHVzaCh1LCB2KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHZlcnRleCBpbmRpY2VzXG4gICAgICBpZiAocm93IDwgaGVpZ2h0U2VnbWVudHMgJiYgY29sIDwgd2lkdGhTZWdtZW50cykge1xuICAgICAgICB2YXIgYSA9IHJvdyAqICh3aWR0aFNlZ21lbnRzICsgMSkgKyBjb2w7XG4gICAgICAgIHZhciBiID0gYSArIDE7XG4gICAgICAgIHZhciBjID0gKHJvdyArIDEpICogKHdpZHRoU2VnbWVudHMgKyAxKSArIGNvbDtcbiAgICAgICAgdmFyIGQgPSBjICsgMTtcbiAgICAgICAgdmVydGV4SW5kaWNlcy5wdXNoKGEsIGIsIGMsIGIsIGQsIGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cmliTGlzdCA9IFsnYVZlcnRleFBvc2l0aW9uJywgJ2FUZXh0dXJlQ29vcmQnXTtcbnZhciB1bmlmb3JtTGlzdCA9IFtcbiAgJ3VEZXB0aCcsICd1T3BhY2l0eScsICd1U2FtcGxlcicsICd1RGVwdGhtYXAnLCAndVByb2pNYXRyaXgnLCAndVZpZXdNYXRyaXgnLFxuICAndU1vZGVsTWF0cml4JywgJ3VWaWV3cG9ydE1hdHJpeCcsICd1Q29sb3JPZmZzZXQnLCAndUNvbG9yTWF0cml4J1xuXTtcblxuXG5cbi8qKlxuICogQGNsYXNzIFdlYkdsQ3ViZURlcHRoUmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEN1YmVHZW9tZXRyeX0gYW5kIHtAbGluayBSZWN0aWxpbmVhclZpZXd9IHdpdGggZGVwdGhtYXAsIGFwcHJvcHJpYXRlXG4gKiBmb3IgYSB7QGxpbmsgV2ViR2xTdGFnZX0uXG4gKlxuICogTW9zdCB1c2VycyBkbyBub3QgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzLiBSZW5kZXJlcnMgYXJlIGNyZWF0ZWQgYW5kXG4gKiBkZXN0cm95ZWQgYnkge0BsaW5rIFN0YWdlfSBhcyBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIFdlYkdsQ3ViZURlcHRoUmVuZGVyZXIoZ2wsIG9wdHMpIHtcbiAgdGhpcy5nbCA9IGdsO1xuXG4gIC8vIFRoZSBwcm9qZWN0aW9uIG1hdHJpeCBwb3NpdGlvbnMgdGhlIHRpbGVzIGluIHdvcmxkIHNwYWNlLlxuICAvLyBXZSBjb21wdXRlIGl0IGluIEphdmFzY3JpcHQgYmVjYXVzZSBsYWNrIG9mIHByZWNpc2lvbiBpbiB0aGUgdmVydGV4IHNoYWRlclxuICAvLyBjYXVzZXMgc2VhbXMgdG8gYXBwZWFyIGJldHdlZW4gYWRqYWNlbnQgdGlsZXMgYXQgbGFyZ2Ugem9vbSBsZXZlbHMuXG4gIHRoaXMucHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVE9ETyBXaHkgc2F2ZSB0aGlzIHZhbHVlIGhlcmU/IHRoZSBzYW1lIHF1ZXN0aW9uIHRvIHRoZSBwcm9qTWF0cml4LlxuICB0aGlzLnZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRoZSB2aWV3cG9ydCBtYXRyaXggcmVzcG9uc2libGUgZm9yIHZpZXdwb3J0IGNsYW1waW5nLlxuICAvLyBTZWUgc2V0Vmlld3BvcnQoKSBmb3IgYW4gZXhwbGFuYXRpb24gb2YgaG93IGl0IHdvcmtzLlxuICB0aGlzLnZpZXdwb3J0TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUcmFuc2xhdGlvbiBhbmQgc2NhbGUgdmVjdG9ycyBmb3IgdGlsZXMuXG4gIHRoaXMudHJhbnNsYXRlVmVjdG9yID0gdmVjMy5jcmVhdGUoKTtcbiAgdGhpcy5zY2FsZVZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgdmFyIHdpZHRoU2VnbWVudHMgPSBvcHRzICYmIG9wdHMud2lkdGhTZWdtZW50cyA/IG9wdHMud2lkdGhTZWdtZW50cyA6IGRlZmF1bHRXaWR0aFNlZ21lbnRzO1xuICB2YXIgaGVpZ2h0U2VnbWVudHMgPSBvcHRzICYmIG9wdHMuaGVpZ2h0U2VnbWVudHMgPyBvcHRzLmhlaWdodFNlZ21lbnRzIDogZGVmYXVsdEhlaWdodFNlZ21lbnRzO1xuICBjcmVhdGVWZXJ0ZXhEYXRhcyh3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyk7XG4gIFxuICB0aGlzLmNvbnN0YW50QnVmZmVycyA9IGNyZWF0ZUNvbnN0YW50QnVmZmVycyhnbCwgdmVydGV4SW5kaWNlcywgdmVydGV4UG9zaXRpb25zLCB0ZXh0dXJlQ29vcmRzKTtcblxuICBpZiAob3B0cy5sYXllci5kZXB0aG1hcFN0b3JlKCkuc291cmNlVHlwZSgpID09ICdzdGwnKSB7XG4gICAgdGhpcy5zaGFkZXJQcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgdmVydGV4U1RMU3JjLCBmcmFnbWVudFNyYywgYXR0cmliTGlzdCwgdW5pZm9ybUxpc3QpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2hhZGVyUHJvZ3JhbSA9IGNyZWF0ZVNoYWRlclByb2dyYW0oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYkxpc3QsIHVuaWZvcm1MaXN0KTtcbiAgfVxufVxuXG5XZWJHbEN1YmVEZXB0aFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBkZXN0cm95Q29uc3RhbnRCdWZmZXJzKHRoaXMuZ2wsIHRoaXMuY29uc3RhbnRCdWZmZXJzKTtcbiAgZGVzdHJveVNoYWRlclByb2dyYW0odGhpcy5nbCwgdGhpcy5zaGFkZXJQcm9ncmFtKTtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuV2ViR2xDdWJlRGVwdGhSZW5kZXJlci5wcm90b3R5cGUuc3RhcnRMYXllciA9IGZ1bmN0aW9uIChsYXllciwgcmVjdCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgdmFyIGNvbnN0YW50QnVmZmVycyA9IHRoaXMuY29uc3RhbnRCdWZmZXJzO1xuICB2YXIgdmlld3BvcnRNYXRyaXggPSB0aGlzLnZpZXdwb3J0TWF0cml4O1xuXG4gIGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cbiAgZW5hYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG5cbiAgc2V0Vmlld3BvcnQoZ2wsIGxheWVyLCByZWN0LCB2aWV3cG9ydE1hdHJpeCk7XG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51Vmlld3BvcnRNYXRyaXgsIGZhbHNlLCB2aWV3cG9ydE1hdHJpeCk7XG5cbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbnN0YW50QnVmZmVycy52ZXJ0ZXhQb3NpdGlvbnMpO1xuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlclByb2dyYW0uYVZlcnRleFBvc2l0aW9uLCAzLCBnbC5GTE9BVCwgZ2wuRkFMU0UsIDAsIDApO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgY29uc3RhbnRCdWZmZXJzLnRleHR1cmVDb29yZHMpO1xuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlclByb2dyYW0uYVRleHR1cmVDb29yZCwgMiwgZ2wuRkxPQVQsIGdsLkZBTFNFLCAwLCAwKTtcblxuICBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXMoZ2wsIGxheWVyLmVmZmVjdHMoKSwge1xuICAgIG9wYWNpdHk6IHNoYWRlclByb2dyYW0udU9wYWNpdHksXG4gICAgY29sb3JPZmZzZXQ6IHNoYWRlclByb2dyYW0udUNvbG9yT2Zmc2V0LFxuICAgIGNvbG9yTWF0cml4OiBzaGFkZXJQcm9ncmFtLnVDb2xvck1hdHJpeFxuICB9KTtcbn07XG5cbldlYkdsQ3ViZURlcHRoUmVuZGVyZXIucHJvdG90eXBlLmVuZExheWVyID0gZnVuY3Rpb24gKGxheWVyLCByZWN0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIHZhciBzaGFkZXJQcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xuICBkaXNhYmxlQXR0cmlidXRlcyhnbCwgc2hhZGVyUHJvZ3JhbSk7XG59O1xuXG5XZWJHbEN1YmVEZXB0aFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUaWxlID0gZnVuY3Rpb24gKHRpbGUsIHRleHR1cmUsIGxheWVyLCBsYXllclopIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIHZhciBjb25zdGFudEJ1ZmZlcnMgPSB0aGlzLmNvbnN0YW50QnVmZmVycztcbiAgdmFyIHByb2pNYXRyaXggPSB0aGlzLnByb2pNYXRyaXg7XG4gIHZhciB2aWV3TWF0cml4ID0gdGhpcy52aWV3TWF0cml4O1xuICB2YXIgdHJhbnNsYXRlVmVjdG9yID0gdGhpcy50cmFuc2xhdGVWZWN0b3I7XG4gIHZhciBzY2FsZVZlY3RvciA9IHRoaXMuc2NhbGVWZWN0b3I7XG5cbiAgbWF0NC5jb3B5KHByb2pNYXRyaXgsIGxheWVyLnZpZXcoKS5wcm9qZWN0aW9uKCkpO1xuICBnbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclByb2dyYW0udVByb2pNYXRyaXgsIGZhbHNlLCBwcm9qTWF0cml4KTtcblxuICBtYXQ0LmNvcHkodmlld01hdHJpeCwgbGF5ZXIudmlldygpLnZpZXdNYXRyaXgoKSk7XG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51Vmlld01hdHJpeCwgZmFsc2UsIHZpZXdNYXRyaXgpO1xuXG4gIC8vIEdlbmVyYXRlIE1vZGVsTWF0cml4LlxuICAvLyBUT0RPIENhY2hlIHRoZSBtYXRyaXggaW4gdGhlIHRpbGUgb2JqZWN0P1xuICB0cmFuc2xhdGVWZWN0b3JbMF0gPSB0aWxlLmNlbnRlclgoKTtcbiAgdHJhbnNsYXRlVmVjdG9yWzFdID0gdGlsZS5jZW50ZXJZKCk7XG4gIHRyYW5zbGF0ZVZlY3RvclsyXSA9IC0wLjU7XG5cbiAgc2NhbGVWZWN0b3JbMF0gPSB0aWxlLnNjYWxlWCgpO1xuICBzY2FsZVZlY3RvclsxXSA9IHRpbGUuc2NhbGVZKCk7XG4gIHNjYWxlVmVjdG9yWzJdID0gMS4wO1xuXG4gIHZhciBtb2RlbE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIGlmIChsYXllci5kZXB0aG1hcFN0b3JlKCkuc291cmNlVHlwZSgpICE9ICdzdGwnKSB7XG4gICAgbWF0NC5yb3RhdGVZKG1vZGVsTWF0cml4LCBtb2RlbE1hdHJpeCwgLU1hdGguUEkgLyAyKTtcbiAgfVxuICBtYXQ0LnJvdGF0ZVgobW9kZWxNYXRyaXgsIG1vZGVsTWF0cml4LCB0aWxlLnJvdFgoKSk7XG4gIG1hdDQucm90YXRlWShtb2RlbE1hdHJpeCwgbW9kZWxNYXRyaXgsIHRpbGUucm90WSgpKTtcbiAgbWF0NC50cmFuc2xhdGUobW9kZWxNYXRyaXgsIG1vZGVsTWF0cml4LCB0cmFuc2xhdGVWZWN0b3IpO1xuICBtYXQ0LnNjYWxlKG1vZGVsTWF0cml4LCBtb2RlbE1hdHJpeCwgc2NhbGVWZWN0b3IpO1xuXG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51TW9kZWxNYXRyaXgsIGZhbHNlLCBtb2RlbE1hdHJpeCk7XG5cbiAgLy8gRGVwdGgsIFRleHR1cmUuXG4gIHNldERlcHRoKGdsLCBzaGFkZXJQcm9ncmFtLCBsYXllclosIHRpbGUueik7XG4gIHNldFRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIHRleHR1cmUpO1xuXG4gIC8vIERlcHRobWFwVGV4dHVyZS5cbiAgdmFyIGRlcHRobWFwU3RvcmUgPSBsYXllci5kZXB0aG1hcFN0b3JlKCk7XG4gIGlmIChkZXB0aG1hcFN0b3JlLnNvdXJjZVR5cGUoKSA9PSAnc3RsJykge1xuICAgIHNldERlcHRobWFwQ3ViZVRleHR1cmUoZ2wsIHNoYWRlclByb2dyYW0sIGRlcHRobWFwU3RvcmUuY3ViZVRleHR1cmUoKSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0RGVwdGhtYXBUZXh0dXJlKGdsLCBzaGFkZXJQcm9ncmFtLCBkZXB0aG1hcFN0b3JlLnRleHR1cmUoKSk7XG4gIH1cblxuICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudmVydGV4SW5kaWNlcyk7XG4gIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHZlcnRleEluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdsQ3ViZURlcHRoUmVuZGVyZXI7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxudmFyIFdlYkdsQ29tbW9uID0gcmVxdWlyZSgnLi9XZWJHbENvbW1vbicpO1xudmFyIGNyZWF0ZUNvbnN0YW50QnVmZmVycyA9IFdlYkdsQ29tbW9uLmNyZWF0ZUNvbnN0YW50QnVmZmVycztcbnZhciBkZXN0cm95Q29uc3RhbnRCdWZmZXJzID0gV2ViR2xDb21tb24uZGVzdHJveUNvbnN0YW50QnVmZmVycztcbnZhciBjcmVhdGVTaGFkZXJQcm9ncmFtID0gV2ViR2xDb21tb24uY3JlYXRlU2hhZGVyUHJvZ3JhbTtcbnZhciBkZXN0cm95U2hhZGVyUHJvZ3JhbSA9IFdlYkdsQ29tbW9uLmRlc3Ryb3lTaGFkZXJQcm9ncmFtO1xudmFyIGVuYWJsZUF0dHJpYnV0ZXMgPSBXZWJHbENvbW1vbi5lbmFibGVBdHRyaWJ1dGVzO1xudmFyIGRpc2FibGVBdHRyaWJ1dGVzID0gV2ViR2xDb21tb24uZGlzYWJsZUF0dHJpYnV0ZXM7XG52YXIgc2V0Vmlld3BvcnQgPSBXZWJHbENvbW1vbi5zZXRWaWV3cG9ydDtcbnZhciBzZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXMgPSBXZWJHbENvbW1vbi5zZXR1cFBpeGVsRWZmZWN0VW5pZm9ybXM7XG5cbnZhciBzZXREZXB0aCA9IFdlYkdsQ29tbW9uLnNldERlcHRoO1xudmFyIHNldFRleHR1cmUgPSBXZWJHbENvbW1vbi5zZXRUZXh0dXJlO1xuXG52YXIgdmVydGV4U3JjID0gcmVxdWlyZSgnLi4vc2hhZGVycy92ZXJ0ZXhFcXVpcmVjdCcpO1xudmFyIGZyYWdtZW50U3JjID0gcmVxdWlyZSgnLi4vc2hhZGVycy9mcmFnbWVudEVxdWlyZWN0Jyk7XG5cbnZhciB2ZXJ0ZXhJbmRpY2VzID0gWzAsIDEsIDIsIDAsIDIsIDNdO1xudmFyIHZlcnRleFBvc2l0aW9ucyA9IFstMS4wLCAtMS4wLCAwLjAsIDEuMCwgLTEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAtMS4wLCAxLjAsIDAuMF07XG52YXIgdGV4dHVyZUNvb3JkcyA9IFswLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIDEuMF07XG5cbnZhciBhdHRyaWJMaXN0ID0gWydhVmVydGV4UG9zaXRpb24nXTtcbnZhciB1bmlmb3JtTGlzdCA9IFtcbiAgJ3VEZXB0aCcsICd1T3BhY2l0eScsICd1U2FtcGxlcicsICd1SW52UHJvak1hdHJpeCcsICd1Vmlld3BvcnRNYXRyaXgnLFxuICAndUNvbG9yT2Zmc2V0JywgJ3VDb2xvck1hdHJpeCcsICd1VGV4dHVyZVgnLCAndVRleHR1cmVZJywgJ3VUZXh0dXJlV2lkdGgnLFxuICAndVRleHR1cmVIZWlnaHQnXG5dO1xuXG5cbi8qKlxuICogQGNsYXNzIFdlYkdsRXF1aXJlY3RSZW5kZXJlclxuICogQGltcGxlbWVudHMgUmVuZGVyZXJcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHJlbmRlcmVyIGZvciB7QGxpbmsgRXF1aXJlY3RHZW9tZXRyeX0gYW5kIHtAbGluayBSZWN0aWxpbmVhclZpZXd9LFxuICogYXBwcm9wcmlhdGUgZm9yIHtAbGluayBXZWJHbFN0YWdlfS5cbiAqXG4gKiBNb3N0IHVzZXJzIGRvIG5vdCBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MuIFJlbmRlcmVycyBhcmUgY3JlYXRlZCBhbmRcbiAqIGRlc3Ryb3llZCBieSB7QGxpbmsgU3RhZ2V9IGFzIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gV2ViR2xFcXVpcmVjdFJlbmRlcmVyKGdsKSB7XG4gIHRoaXMuZ2wgPSBnbDtcblxuICAvLyBUaGUgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgdGhpcy5pbnZQcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUaGUgdmlld3BvcnQgbWF0cml4IHJlc3BvbnNpYmxlIGZvciB2aWV3cG9ydCBjbGFtcGluZy5cbiAgLy8gU2VlIHNldFZpZXdwb3J0KCkgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIGhvdyBpdCB3b3Jrcy5cbiAgdGhpcy52aWV3cG9ydE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgdGhpcy5jb25zdGFudEJ1ZmZlcnMgPSBjcmVhdGVDb25zdGFudEJ1ZmZlcnMoZ2wsIHZlcnRleEluZGljZXMsIHZlcnRleFBvc2l0aW9ucywgdGV4dHVyZUNvb3Jkcyk7XG5cbiAgdGhpcy5zaGFkZXJQcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmliTGlzdCwgdW5pZm9ybUxpc3QpO1xufVxuXG5XZWJHbEVxdWlyZWN0UmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgZGVzdHJveUNvbnN0YW50QnVmZmVycyh0aGlzLmdsLCB0aGlzLmNvbnN0YW50QnVmZmVycyk7XG4gIGRlc3Ryb3lTaGFkZXJQcm9ncmFtKHRoaXMuZ2wsIHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuV2ViR2xFcXVpcmVjdFJlbmRlcmVyLnByb3RvdHlwZS5zdGFydExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIHZhciBjb25zdGFudEJ1ZmZlcnMgPSB0aGlzLmNvbnN0YW50QnVmZmVycztcbiAgdmFyIGludlByb2pNYXRyaXggPSB0aGlzLmludlByb2pNYXRyaXg7XG4gIHZhciB2aWV3cG9ydE1hdHJpeCA9IHRoaXMudmlld3BvcnRNYXRyaXg7XG5cbiAgZ2wudXNlUHJvZ3JhbShzaGFkZXJQcm9ncmFtKTtcblxuICBlbmFibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKTtcblxuICBzZXRWaWV3cG9ydChnbCwgbGF5ZXIsIHJlY3QsIHZpZXdwb3J0TWF0cml4KTtcbiAgZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJQcm9ncmFtLnVWaWV3cG9ydE1hdHJpeCwgZmFsc2UsIHZpZXdwb3J0TWF0cml4KTtcblxuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgY29uc3RhbnRCdWZmZXJzLnZlcnRleFBvc2l0aW9ucyk7XG4gIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyUHJvZ3JhbS5hVmVydGV4UG9zaXRpb24sIDMsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgMCk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBjb25zdGFudEJ1ZmZlcnMudGV4dHVyZUNvb3Jkcyk7XG5cbiAgLy8gQ29tcHV0ZSBhbmQgc2V0IHRoZSBpbnZlcnNlIHByb2plY3Rpb24gbWF0cml4LlxuICBtYXQ0LmNvcHkoaW52UHJvak1hdHJpeCwgbGF5ZXIudmlldygpLnByb2plY3Rpb24oKSk7XG4gIG1hdDQuaW52ZXJ0KGludlByb2pNYXRyaXgsIGludlByb2pNYXRyaXgpO1xuXG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyUHJvZ3JhbS51SW52UHJvak1hdHJpeCwgZmFsc2UsIGludlByb2pNYXRyaXgpO1xuXG4gIC8vIENvbXB1dGUgYW5kIHNldCB0aGUgdGV4dHVyZSBzY2FsZSBhbmQgY3JvcCBvZmZzZXRzLlxuICB2YXIgdGV4dHVyZUNyb3AgPSBsYXllci5lZmZlY3RzKCkudGV4dHVyZUNyb3AgfHwge307XG4gIHZhciB0ZXh0dXJlWCA9IHRleHR1cmVDcm9wLnggIT0gbnVsbCA/IHRleHR1cmVDcm9wLnggOiAwO1xuICB2YXIgdGV4dHVyZVkgPSB0ZXh0dXJlQ3JvcC55ICE9IG51bGwgPyB0ZXh0dXJlQ3JvcC55IDogMDtcbiAgdmFyIHRleHR1cmVXaWR0aCA9IHRleHR1cmVDcm9wLndpZHRoICE9IG51bGwgPyB0ZXh0dXJlQ3JvcC53aWR0aCA6IDE7XG4gIHZhciB0ZXh0dXJlSGVpZ2h0ID0gdGV4dHVyZUNyb3AuaGVpZ2h0ICE9IG51bGwgPyB0ZXh0dXJlQ3JvcC5oZWlnaHQgOiAxO1xuXG4gIGdsLnVuaWZvcm0xZihzaGFkZXJQcm9ncmFtLnVUZXh0dXJlWCwgdGV4dHVyZVgpO1xuICBnbC51bmlmb3JtMWYoc2hhZGVyUHJvZ3JhbS51VGV4dHVyZVksIHRleHR1cmVZKTtcbiAgZ2wudW5pZm9ybTFmKHNoYWRlclByb2dyYW0udVRleHR1cmVXaWR0aCwgdGV4dHVyZVdpZHRoKTtcbiAgZ2wudW5pZm9ybTFmKHNoYWRlclByb2dyYW0udVRleHR1cmVIZWlnaHQsIHRleHR1cmVIZWlnaHQpO1xuXG4gIHNldHVwUGl4ZWxFZmZlY3RVbmlmb3JtcyhnbCwgbGF5ZXIuZWZmZWN0cygpLCB7XG4gICAgb3BhY2l0eTogc2hhZGVyUHJvZ3JhbS51T3BhY2l0eSxcbiAgICBjb2xvck9mZnNldDogc2hhZGVyUHJvZ3JhbS51Q29sb3JPZmZzZXQsXG4gICAgY29sb3JNYXRyaXg6IHNoYWRlclByb2dyYW0udUNvbG9yTWF0cml4XG4gIH0pO1xufTtcblxuXG5XZWJHbEVxdWlyZWN0UmVuZGVyZXIucHJvdG90eXBlLmVuZExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHJlY3QpIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XG4gIGRpc2FibGVBdHRyaWJ1dGVzKGdsLCBzaGFkZXJQcm9ncmFtKTtcbn07XG5cblxuV2ViR2xFcXVpcmVjdFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUaWxlID0gZnVuY3Rpb24odGlsZSwgdGV4dHVyZSwgbGF5ZXIsIGxheWVyWikge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2hhZGVyUHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcbiAgdmFyIGNvbnN0YW50QnVmZmVycyA9IHRoaXMuY29uc3RhbnRCdWZmZXJzO1xuXG4gIHNldERlcHRoKGdsLCBzaGFkZXJQcm9ncmFtLCBsYXllclosIHRpbGUueik7XG5cbiAgc2V0VGV4dHVyZShnbCwgc2hhZGVyUHJvZ3JhbSwgdGV4dHVyZSk7XG5cbiAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgY29uc3RhbnRCdWZmZXJzLnZlcnRleEluZGljZXMpO1xuICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB2ZXJ0ZXhJbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdsRXF1aXJlY3RSZW5kZXJlcjtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFdlYkdsQmFzZVJlbmRlcmVyID0gcmVxdWlyZSgnLi9XZWJHbEJhc2UnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcblxuLyoqXG4gKiBAY2xhc3MgV2ViR2xGbGF0UmVuZGVyZXJcbiAqIEBpbXBsZW1lbnRzIFJlbmRlcmVyXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSByZW5kZXJlciBmb3Ige0BsaW5rIEZsYXRHZW9tZXRyeX0gYW5kIHtAbGluayBGbGF0Vmlld30sIGFwcHJvcHJpYXRlIGZvciBhXG4gKiB7QGxpbmsgV2ViR2xTdGFnZX0uXG4gKlxuICogTW9zdCB1c2VycyBkbyBub3QgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzLiBSZW5kZXJlcnMgYXJlIGNyZWF0ZWQgYW5kXG4gKiBkZXN0cm95ZWQgYnkge0BsaW5rIFN0YWdlfSBhcyBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIFdlYkdsRmxhdFJlbmRlcmVyKCkge1xuICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0cyhXZWJHbEZsYXRSZW5kZXJlciwgV2ViR2xCYXNlUmVuZGVyZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdsRmxhdFJlbmRlcmVyO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgV2ViR2xGbGF0ID0gcmVxdWlyZSgnLi9XZWJHbEZsYXQnKTtcbnZhciBXZWJHbEN1YmUgPSByZXF1aXJlKCcuL1dlYkdsQ3ViZScpO1xudmFyIFdlYkdsQ3ViZURlcHRoID0gcmVxdWlyZSgnLi9XZWJHbEN1YmVEZXB0aCcpO1xudmFyIFdlYkdsRXF1aXJlY3QgPSByZXF1aXJlKCcuL1dlYkdsRXF1aXJlY3QnKTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYWxsIGtub3duIHJlbmRlcmVycyBmb3IgdGhlIGdpdmVuIHN0YWdlIHR5cGUgaW50byB0aGF0IHN0YWdlLlxuICogTW9zdCB1c2VycyB3aWxsIG5vdCBuZWVkIHRvIHJlZ2lzdGVyIHJlbmRlcmVycywgYXMge0BsaW5rIFZpZXdlcn0gZG9lcyBpdCBmb3JcbiAqIHRoZW0uXG4gKlxuICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHN0YWdlIHdoZXJlIHRoZSByZW5kZXJlcnMgYXJlIHRvIGJlIHJlZ2lzdGVyZWQuXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBzdGFnZSB0eXBlIGlzIHVua25vd24uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdFJlbmRlcmVycyhzdGFnZSkge1xuICBzd2l0Y2ggKHN0YWdlLnR5cGUpIHtcbiAgICBjYXNlICd3ZWJnbCc6XG4gICAgICBzdGFnZS5yZWdpc3RlclJlbmRlcmVyKCdmbGF0JywgJ2ZsYXQnLCBXZWJHbEZsYXQpO1xuICAgICAgc3RhZ2UucmVnaXN0ZXJSZW5kZXJlcignY3ViZScsICdyZWN0aWxpbmVhcicsIFdlYkdsQ3ViZSk7XG4gICAgICBzdGFnZS5yZWdpc3RlclJlbmRlcmVyKCdjdWJlK2RlcHRoJywgJ3JlY3RpbGluZWFyJywgV2ViR2xDdWJlRGVwdGgpO1xuICAgICAgc3RhZ2UucmVnaXN0ZXJSZW5kZXJlcignZXF1aXJlY3QnLCAncmVjdGlsaW5lYXInLCBXZWJHbEVxdWlyZWN0KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc3RhZ2UgdHlwZTogJyArIHN0YWdlLnR5cGUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJyNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSCcsXG4gICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7JyxcbiAgJyNlbHNlJyxcbiAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICcjZW5kaWYnLFxuXG4gICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuICAndW5pZm9ybSBmbG9hdCB1T3BhY2l0eTsnLFxuICAndW5pZm9ybSB2ZWM0IHVDb2xvck9mZnNldDsnLFxuICAndW5pZm9ybSBtYXQ0IHVDb2xvck1hdHJpeDsnLFxuXG4gICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuXG4gIGBcbiAgdm9pZCBtYWluKHZvaWQpIHtcbiAgICAvL2lmICghZ2xfRnJvbnRGYWNpbmcpIHtcbiAgICAvLyAgZGlzY2FyZDsgLy8gRGlzY2FyZCB0aGUgZnJvbnQtZmFjaW5nIHRyaWFuZ2xlc1xuICAgIC8vfSBlbHNlIHtcbiAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdUNvbG9yTWF0cml4ICsgdUNvbG9yT2Zmc2V0O1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvci5yZ2JhICogdU9wYWNpdHkpO1xuICAgIC8vfVxuICB9XG4gIGBcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuJyNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSCcsXG4ncHJlY2lzaW9uIGhpZ2hwIGZsb2F0OycsXG4nI2Vsc2UnLFxuJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0JyxcbicjZW5kaWYnLFxuXG4ndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7Jyxcbid1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OycsXG4ndW5pZm9ybSBmbG9hdCB1VGV4dHVyZVg7Jyxcbid1bmlmb3JtIGZsb2F0IHVUZXh0dXJlWTsnLFxuJ3VuaWZvcm0gZmxvYXQgdVRleHR1cmVXaWR0aDsnLFxuJ3VuaWZvcm0gZmxvYXQgdVRleHR1cmVIZWlnaHQ7Jyxcbid1bmlmb3JtIHZlYzQgdUNvbG9yT2Zmc2V0OycsXG4ndW5pZm9ybSBtYXQ0IHVDb2xvck1hdHJpeDsnLFxuXG4ndmFyeWluZyB2ZWM0IHZSYXk7JyxcblxuJ2NvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDsnLFxuXG4ndm9pZCBtYWluKHZvaWQpIHsnLFxuJyAgZmxvYXQgciA9IGludmVyc2VzcXJ0KHZSYXkueCAqIHZSYXkueCArIHZSYXkueSAqIHZSYXkueSArIHZSYXkueiAqIHZSYXkueik7JyxcbicgIGZsb2F0IHBoaSAgPSBhY29zKHZSYXkueSAqIHIpOycsXG4nICBmbG9hdCB0aGV0YSA9IGF0YW4odlJheS54LCAtMS4wKnZSYXkueik7JyxcbicgIGZsb2F0IHMgPSAwLjUgKyAwLjUgKiB0aGV0YSAvIFBJOycsXG4nICBmbG9hdCB0ID0gMS4wIC0gcGhpIC8gUEk7JyxcblxuJyAgcyA9IHMgKiB1VGV4dHVyZVdpZHRoICsgdVRleHR1cmVYOycsXG4nICB0ID0gdCAqIHVUZXh0dXJlSGVpZ2h0ICsgdVRleHR1cmVZOycsXG5cbicgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIocywgdCkpICogdUNvbG9yTWF0cml4ICsgdUNvbG9yT2Zmc2V0OycsXG4nICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYmEgKiB1T3BhY2l0eSk7Jyxcbid9J1xuXS5qb2luKCdcXG4nKTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4nI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIJyxcbidwcmVjaXNpb24gaGlnaHAgZmxvYXQ7JyxcbicjZWxzZScsXG4ncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbicjZW5kaWYnLFxuXG4ndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7Jyxcbid1bmlmb3JtIGZsb2F0IHVPcGFjaXR5OycsXG4ndW5pZm9ybSB2ZWM0IHVDb2xvck9mZnNldDsnLFxuJ3VuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7JyxcblxuJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG5cbid2b2lkIG1haW4odm9pZCkgeycsXG5cbi8vIGBcbi8vIGlmICghZ2xfRnJvbnRGYWNpbmcpIHtcbi8vICAgZGlzY2FyZDsgLy8gRGlzY2FyZCB0aGUgZnJvbnQtZmFjaW5nIHRyaWFuZ2xlc1xuLy8gfSBlbHNlIHtcbi8vICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1Q29sb3JNYXRyaXggKyB1Q29sb3JPZmZzZXQ7XG4vLyAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiYSAqIHVPcGFjaXR5KTtcbi8vIH1cbi8vIGAsXG5cbicgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdUNvbG9yTWF0cml4ICsgdUNvbG9yT2Zmc2V0OycsXG4nICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYmEgKiB1T3BhY2l0eSk7Jyxcbid9J1xuXS5qb2luKCdcXG4nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247JyxcbiAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcblxuICAndW5pZm9ybSBzYW1wbGVyMkQgdURlcHRobWFwOycsXG4gICd1bmlmb3JtIGZsb2F0IHVEZXB0aDsnLFxuICAndW5pZm9ybSBtYXQ0IHVWaWV3cG9ydE1hdHJpeDsnLFxuICAndW5pZm9ybSBtYXQ0IHVQcm9qTWF0cml4OycsXG4gICd1bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7JyxcbiAgJ3VuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7JyxcblxuICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcblxuICBgXG4gIGZsb2F0IGkoaW4gZmxvYXQgYSwgaW4gZmxvYXQgYikge1xuICAgIHJldHVybiBiID09IDAuMCA/IHNpZ24oYSkqMS41NzA3OTYgOiBhdGFuKGEsIGIpO1xuICB9XG5cbiAgdm9pZCBtYWluKHZvaWQpIHtcbiAgICB2ZWMzIGMgPSBub3JtYWxpemUodmVjMyh1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkpO1xuXG4gICAgZmxvYXQgeCA9ICgxLjAgLSBpKC1jLnosIGMueCkvMy4xNDE1OTMpKjAuNTtcbiAgICBmbG9hdCB5ID0gMC41IC0gaSgtYy55LCBzcXJ0KGMueCpjLnggKyBjLnoqYy56KSkvMy4xNDE1OTM7XG4gICAgdmVjNCBmID0gdGV4dHVyZTJEKHVEZXB0aG1hcCwgdmVjMih4LCB5KSk7XG5cbiAgICBmbG9hdCBqID0gKGYucio2NTUzNi4wICsgZi5nKjI1Ni4wICsgZi5iKS82NTc5My4wO1xuICAgIHZlYzMgYiA9IGMqKDEuMCAtIGopO1xuICAgIHZlYzMgYSA9IHZlYzModVZpZXdNYXRyaXggKiB2ZWM0KGIueiwgYi55LCAtYi54LCAxKSk7XG5cbiAgICBnbF9Qb3NpdGlvbiA9IHVWaWV3cG9ydE1hdHJpeCAqIHVQcm9qTWF0cml4ICogdmVjNChhLCAxLjApO1xuICAgIGdsX1Bvc2l0aW9uLnogPSB1RGVwdGggKiBnbF9Qb3NpdGlvbi53O1xuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICB9XG4gIGBcbl0uam9pbignXFxuJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uOycsXG4gICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG5cbiAgJ3VuaWZvcm0gc2FtcGxlckN1YmUgdURlcHRobWFwOycsXG4gICd1bmlmb3JtIGZsb2F0IHVEZXB0aDsnLFxuICAndW5pZm9ybSBtYXQ0IHVWaWV3cG9ydE1hdHJpeDsnLFxuICAndW5pZm9ybSBtYXQ0IHVQcm9qTWF0cml4OycsXG4gICd1bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7JyxcbiAgJ3VuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7JyxcblxuICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcblxuICBgXG4gIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgdmVjMyBhID0gdmVjMyh1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSk7XG4gICAgdmVjMyBiID0gbm9ybWFsaXplKGEpO1xuXG4gICAgdmVjNCBlID0gdGV4dHVyZUN1YmUodURlcHRobWFwLCBhKTtcblxuICAgIGZsb2F0IGggPSAoZS5yICogMjU2LjAgKiAyNTYuMCArIGUuZyAqIDI1Ni4wICsgZS5iKS82NTAyNS4wO1xuICAgIGIgPSBiICogMS41ICogKDEuMCAtIGgpO1xuICAgIGEgPSB2ZWMzKHVWaWV3TWF0cml4ICogdmVjNChiLCAxKSk7XG5cbiAgICBnbF9Qb3NpdGlvbiA9IHVWaWV3cG9ydE1hdHJpeCAqIHVQcm9qTWF0cml4ICogdmVjNChhLCAxLjApO1xuICAgIGdsX1Bvc2l0aW9uLnogPSB1RGVwdGggKiBnbF9Qb3NpdGlvbi53O1xuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICB9XG4gIGBcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuJ2F0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuXG4ndW5pZm9ybSBmbG9hdCB1RGVwdGg7Jyxcbid1bmlmb3JtIG1hdDQgdVZpZXdwb3J0TWF0cml4OycsXG4ndW5pZm9ybSBtYXQ0IHVJbnZQcm9qTWF0cml4OycsXG5cbid2YXJ5aW5nIHZlYzQgdlJheTsnLFxuXG4ndm9pZCBtYWluKHZvaWQpIHsnLFxuJyAgdlJheSA9IHVJbnZQcm9qTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24ueHksIDEuMCwgMS4wKTsnLFxuJyAgZ2xfUG9zaXRpb24gPSB1Vmlld3BvcnRNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54eSwgdURlcHRoLCAxLjApOycsXG4nfSdcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuJ2F0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcblxuJ3VuaWZvcm0gZmxvYXQgdURlcHRoOycsXG4ndW5pZm9ybSBtYXQ0IHVWaWV3cG9ydE1hdHJpeDsnLFxuJ3VuaWZvcm0gbWF0NCB1UHJvak1hdHJpeDsnLFxuJ3VuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDsnLFxuJ3VuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7JyxcblxuJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG5cbid2b2lkIG1haW4odm9pZCkgeycsXG4nICBnbF9Qb3NpdGlvbiA9IHVWaWV3cG9ydE1hdHJpeCAqIHVQcm9qTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTsnLFxuJyAgZ2xfUG9zaXRpb24ueiA9IHVEZXB0aCAqIGdsX1Bvc2l0aW9uLnc7JyxcbicgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4nfSdcbl0uam9pbignXFxuJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBOZXR3b3JrRXJyb3IgPSByZXF1aXJlKCcuLi9OZXR3b3JrRXJyb3InKTtcbnZhciBXb3JrUG9vbCA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb25zL1dvcmtQb29sJyk7XG52YXIgY2hhaW4gPSByZXF1aXJlKCcuLi91dGlsL2NoYWluJyk7XG52YXIgZGVsYXkgPSByZXF1aXJlKCcuLi91dGlsL2RlbGF5Jyk7XG52YXIgbm93ID0gcmVxdWlyZSgnLi4vdXRpbC9ub3cnKTtcblxuXG4vLyBNYXAgdGVtcGxhdGUgcHJvcGVydGllcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHRpbGUgcHJvcGVydGllcy5cbnZhciB0ZW1wbGF0ZVByb3BlcnRpZXMgPSB7XG4gIHg6ICd4JyxcbiAgeTogJ3knLFxuICB6OiAneicsXG4gIGY6ICdmYWNlJ1xufTtcblxuLy8gRGVmYXVsdCBmYWNlIG9yZGVyIGZvciBjdWJlIG1hcHMuXG52YXIgZGVmYXVsdEN1YmVNYXBGYWNlT3JkZXIgPSAnYmRmbHJ1JztcblxuLy8gRGVmYXVsdCBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IHJlcXVlc3RzLlxudmFyIGRlZmF1bHRDb25jdXJyZW5jeSA9IDQ7XG5cbi8vIERlZmF1bHQgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJldHJ5aW5nIGZhaWxlZCByZXF1ZXN0cy5cbnZhciBkZWZhdWx0UmV0cnlEZWxheSA9IDEwMDAwO1xuXG5cbi8qKlxuICogQGNsYXNzIEltYWdlVXJsU291cmNlXG4gKiBAaW1wbGVtZW50cyBTb3VyY2VcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBTb3VyY2V9IHRoYXQgbG9hZHMge0BsaW5rIEFzc2V0IGFzc2V0c30gZnJvbSBpbWFnZXMgZ2l2ZW4gYSBVUkwgYW5kXG4gKiBhIGNyb3AgcmVjdGFuZ2xlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvdXJjZUZyb21UaWxlIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSB0aWxlIGFuZCByZXR1cm5zXG4gKiBhIGB7IHVybCwgcmVjdCB9YCBvYmplY3QsIHdoZXJlIGB1cmxgIGlzIGFuIGltYWdlIFVSTCBhbmQgYHJlY3RgLCB3aGVuXG4gKiBwcmVzZW50LCBpcyBhbiBgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH1gIG9iamVjdCBpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzXG4gKiBkZW5vdGluZyB0aGUgcG9ydGlvbiBvZiB0aGUgaW1hZ2UgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5jb25jdXJyZW5jeT00XSBNYXhpbXVtIG51bWJlciBvZiB0aWxlcyB0byByZXF1ZXN0IGF0XG4gKiAgICAgdGhlIHNhbWUgdGltZS4gVGhlIGxpbWl0IGlzIHBlciB7QGxpbmsgSW1hZ2VTb3VyY2VVcmx9IGluc3RhbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJldHJ5RGVsYXk9MTAwMDBdIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlXG4gKiAgICAgcmV0cnlpbmcgYSBmYWlsZWQgcmVxdWVzdC5cbiAqL1xuZnVuY3Rpb24gSW1hZ2VVcmxTb3VyY2Uoc291cmNlRnJvbVRpbGUsIG9wdHMpIHtcblxuICBvcHRzID0gb3B0cyA/IG9wdHMgOiB7fTtcblxuICB0aGlzLl9sb2FkUG9vbCA9IG5ldyBXb3JrUG9vbCh7XG4gICAgY29uY3VycmVuY3k6IG9wdHMuY29uY3VycmVuY3kgfHwgZGVmYXVsdENvbmN1cnJlbmN5XG4gIH0pO1xuXG4gIHRoaXMuX3JldHJ5RGVsYXkgPSBvcHRzLnJldHJ5RGVsYXkgfHwgZGVmYXVsdFJldHJ5RGVsYXk7XG4gIHRoaXMuX3JldHJ5TWFwID0ge307XG5cbiAgdGhpcy5fc291cmNlRnJvbVRpbGUgPSBzb3VyY2VGcm9tVGlsZTtcbn1cblxuZXZlbnRFbWl0dGVyKEltYWdlVXJsU291cmNlKTtcblxuXG5JbWFnZVVybFNvdXJjZS5wcm90b3R5cGUubG9hZEFzc2V0ID0gZnVuY3Rpb24oc3RhZ2UsIHRpbGUsIGRvbmUpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHJldHJ5RGVsYXkgPSB0aGlzLl9yZXRyeURlbGF5O1xuICB2YXIgcmV0cnlNYXAgPSB0aGlzLl9yZXRyeU1hcDtcblxuICB2YXIgdGlsZVNvdXJjZSA9IHRoaXMuX3NvdXJjZUZyb21UaWxlKHRpbGUpO1xuICB2YXIgdXJsID0gdGlsZVNvdXJjZS51cmw7XG4gIHZhciByZWN0ID0gdGlsZVNvdXJjZS5yZWN0O1xuXG4gIHZhciBsb2FkSW1hZ2UgPSBzdGFnZS5sb2FkSW1hZ2UuYmluZChzdGFnZSwgdXJsLCByZWN0KTtcblxuICB2YXIgbG9hZEZuID0gZnVuY3Rpb24oZG9uZSkge1xuICAgIC8vIFRPRE86IERlZHVwbGljYXRlIGxvYWQgcmVxdWVzdHMgZm9yIHRoZSBzYW1lIFVSTC4gQWx0aG91Z2ggdGhlIGJyb3dzZXJcbiAgICAvLyBtaWdodCBiZSBzbWFydCBlbm91Z2ggdG8gYXZvaWQgZHVwbGljYXRlIHJlcXVlc3RzLCB0aGV5IGFyZSBzdGlsbCB1bmR1bHlcbiAgICAvLyBpbXBhY3RlZCBieSB0aGUgY29uY3VycmVuY3kgcGFyYW1ldGVyLlxuICAgIHJldHVybiBzZWxmLl9sb2FkUG9vbC5wdXNoKGxvYWRJbWFnZSwgZnVuY3Rpb24oZXJyLCBhc3NldCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgTmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSBuZXR3b3JrIGVycm9yIG9jY3VycmVkLCB3YWl0IGJlZm9yZSByZXRyeWluZy5cbiAgICAgICAgICByZXRyeU1hcFt1cmxdID0gbm93KCk7XG4gICAgICAgICAgc2VsZi5lbWl0KCduZXR3b3JrRXJyb3InLCBlcnIsIHRpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoZXJyLCB0aWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBmZXRjaCwgZm9yZ2V0IHRoZSBwcmV2aW91cyB0aW1lb3V0LlxuICAgICAgICBkZWxldGUgcmV0cnlNYXBbdXJsXTtcbiAgICAgICAgZG9uZShudWxsLCB0aWxlLCBhc3NldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBhcmUgcmV0cnlpbmcgYSBmYWlsZWQgcmVxdWVzdC5cbiAgdmFyIGRlbGF5QW1vdW50O1xuICB2YXIgbGFzdFRpbWUgPSByZXRyeU1hcFt1cmxdO1xuICBpZiAobGFzdFRpbWUgIT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgIHZhciBlbGFwc2VkID0gY3VycmVudFRpbWUgLSBsYXN0VGltZTtcbiAgICBpZiAoZWxhcHNlZCA8IHJldHJ5RGVsYXkpIHtcbiAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nLlxuICAgICAgZGVsYXlBbW91bnQgPSByZXRyeURlbGF5IC0gZWxhcHNlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0cnkgdGltZW91dCBleHBpcmVkOyBwZXJmb3JtIHRoZSByZXF1ZXN0IGF0IG9uY2UuXG4gICAgICBkZWxheUFtb3VudCA9IDA7XG4gICAgICBkZWxldGUgcmV0cnlNYXBbdXJsXTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsYXlGbiA9IGRlbGF5LmJpbmQobnVsbCwgZGVsYXlBbW91bnQpO1xuXG4gIHJldHVybiBjaGFpbihkZWxheUZuLCBsb2FkRm4pKGRvbmUpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSW1hZ2VVcmxTb3VyY2UgZnJvbSBhIHN0cmluZyB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRpbGUgVVJMIHRlbXBsYXRlLCB3aGljaCBtYXkgY29udGFpbiB0aGUgZm9sbG93aW5nXG4gKiAgICBwbGFjZWhvbGRlcnM6XG4gKiAgICAtIGB7Zn1gIDogdGlsZSBmYWNlIChvbmUgb2YgYGJgLCBgZGAsIGBmYCwgYGxgLCBgcmAsIGB1YClcbiAqICAgIC0gYHt6fWAgOiB0aWxlIGxldmVsIGluZGV4ICgwIGlzIHRoZSBzbWFsbGVzdCBsZXZlbClcbiAqICAgIC0gYHt4fWAgOiB0aWxlIGhvcml6b250YWwgaW5kZXhcbiAqICAgIC0gYHt5fWAgOiB0aWxlIHZlcnRpY2FsIGluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBJbiBhZGRpdGlvbiB0byB0aGUgb3B0aW9ucyBhbHJlYWR5IHN1cHBvcnRlZCBieSB0aGVcbiAqICAgICB7QGxpbmsgSW1hZ2VVcmxTb3VyY2V9IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuY3ViZU1hcFByZXZpZXdVcmwgVVJMIHRvIHVzZSBhcyB0aGUgcHJldmlldyBsZXZlbC5cbiAqICAgICBUaGlzIG11c3QgYmUgYSBzaW5nbGUgaW1hZ2UgY29udGFpbmluZyBzaXggY3ViZSBmYWNlcyBsYWlkIG91dFxuICogICAgIHZlcnRpY2FsbHkgYWNjb3JkaW5nIHRvIHRoZSBmYWNlIG9yZGVyIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5jdWJlTWFwUHJldmlld0ZhY2VPcmRlcj0nYmRmbHJ1J10gRmFjZSBvcmRlciB3aXRoaW5cbiAqICAgICB0aGUgcHJldmlldyBpbWFnZS5cbiAqL1xuSW1hZ2VVcmxTb3VyY2UuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHVybCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgZmFjZU9yZGVyID0gb3B0cyAmJiBvcHRzLmN1YmVNYXBQcmV2aWV3RmFjZU9yZGVyIHx8IGRlZmF1bHRDdWJlTWFwRmFjZU9yZGVyO1xuXG4gIHZhciB1cmxGbiA9IG9wdHMuY3ViZU1hcFByZXZpZXdVcmwgPyB3aXRoUHJldmlldyA6IHdpdGhvdXRQcmV2aWV3O1xuXG4gIHJldHVybiBuZXcgSW1hZ2VVcmxTb3VyY2UodXJsRm4sIG9wdHMpO1xuXG4gIGZ1bmN0aW9uIHdpdGhvdXRQcmV2aWV3KHRpbGUpIHtcbiAgICB2YXIgdGlsZVVybCA9IHVybDtcblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRlbXBsYXRlUHJvcGVydGllcykge1xuICAgICAgdmFyIHRlbXBsYXRlUHJvcGVydHkgPSB0ZW1wbGF0ZVByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgdmFyIHJlZ0V4cCA9IHByb3BlcnR5UmVnRXhwKHByb3BlcnR5KTtcbiAgICAgIHZhciB2YWx1ZUZyb21UaWxlID0gdGlsZS5oYXNPd25Qcm9wZXJ0eSh0ZW1wbGF0ZVByb3BlcnR5KSA/IHRpbGVbdGVtcGxhdGVQcm9wZXJ0eV0gOiAnJztcbiAgICAgIHRpbGVVcmwgPSB0aWxlVXJsLnJlcGxhY2UocmVnRXhwLCB2YWx1ZUZyb21UaWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB1cmw6IHRpbGVVcmwgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhQcmV2aWV3KHRpbGUpIHtcbiAgICBpZiAodGlsZS56ID09PSAwKSB7XG4gICAgICByZXR1cm4gY3ViZU1hcFVybCh0aWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gd2l0aG91dFByZXZpZXcodGlsZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3ViZU1hcFVybCh0aWxlKSB7XG4gICAgdmFyIHkgPSBmYWNlT3JkZXIuaW5kZXhPZih0aWxlLmZhY2UpIC8gNjtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiBvcHRzLmN1YmVNYXBQcmV2aWV3VXJsLFxuICAgICAgcmVjdDogeyB4OiAwLCB5OiB5LCB3aWR0aDogMSwgaGVpZ2h0OiAxLzYgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHByb3BlcnR5UmVnRXhwKHByb3BlcnR5KSB7XG4gIHZhciByZWdFeHBTdHIgPSAnXFxcXHsoJyArIHByb3BlcnR5ICsgJylcXFxcfSc7XG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ0V4cFN0ciwgJ2cnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVVybFNvdXJjZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3MgU2luZ2xlQXNzZXRTb3VyY2VcbiAqIEBpbXBsZW1lbnRzIFNvdXJjZVxuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIFNvdXJjZX0gdGhhdCBhbHdheXMgcHJvdmlkZXMgdGhlIHNhbWUge0BsaW5rIEFzc2V0fS5cbiAqXG4gKiBAcGFyYW0ge0Fzc2V0fSBhc3NldCBUaGUgYXNzZXQuXG4qL1xuZnVuY3Rpb24gU2luZ2xlQXNzZXRTb3VyY2UoYXNzZXQpIHtcbiAgdGhpcy5fYXNzZXQgPSBhc3NldDtcbn1cblxuU2luZ2xlQXNzZXRTb3VyY2UucHJvdG90eXBlLmFzc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hc3NldDtcbn07XG5cblNpbmdsZUFzc2V0U291cmNlLnByb3RvdHlwZS5sb2FkQXNzZXQgPSBmdW5jdGlvbihzdGFnZSwgdGlsZSwgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRvbmUobnVsbCwgdGlsZSwgc2VsZi5fYXNzZXQpO1xuICB9LCAwKTtcblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBjYW5jZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbmdsZUFzc2V0U291cmNlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzcyBSZW5kZXJlclJlZ2lzdHJ5XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSBSZW5kZXJlclJlZ2lzdHJ5IG1hcHMgcGFpcnMgb2Yge0BsaW5rIEdlb21ldHJ5fSBhbmQge0BsaW5rIFZpZXd9IHR5cGUgaW50b1xuICogdGhlIGFwcHJvcHJpYXRlIHtAbGluayBSZW5kZXJlcn0gY2xhc3MuIEl0IGlzIHVzZWQgYnkgYSB7QGxpbmsgU3RhZ2V9IHRvXG4gKiBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIHJlbmRlcmVyIGZvciBhIHtAbGluayBMYXllcn0uXG4gKlxuICogU2VlIGFsc28ge0BsaW5rIFN0YWdlI3JlZ2lzdGVyUmVuZGVyZXJ9LlxuICovXG5mdW5jdGlvbiBSZW5kZXJlclJlZ2lzdHJ5KCkge1xuICB0aGlzLl9yZW5kZXJlcnMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSByZW5kZXJlciBmb3IgdGhlIGdpdmVuIGdlb21ldHJ5IGFuZCB2aWV3IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLlxuICovXG5SZW5kZXJlclJlZ2lzdHJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihnZW9tZXRyeVR5cGUsIHZpZXdUeXBlLCBSZW5kZXJlcikge1xuICBpZiAoIXRoaXMuX3JlbmRlcmVyc1tnZW9tZXRyeVR5cGVdKSB7XG4gICAgdGhpcy5fcmVuZGVyZXJzW2dlb21ldHJ5VHlwZV0gPSB7fTtcbiAgfVxuICB0aGlzLl9yZW5kZXJlcnNbZ2VvbWV0cnlUeXBlXVt2aWV3VHlwZV0gPSBSZW5kZXJlcjtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSByZW5kZXJlciBmb3IgdGhlIGdpdmVuIGdlb21ldHJ5IGFuZCB2aWV3IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLCBvciBudWxsIGlmIG5vIHN1Y2ggcmVuZGVyZXIgaGFzIGJlZW5cbiAqIHJlZ2lzdGVyZWQuXG4gKi9cblJlbmRlcmVyUmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGdlb21ldHJ5VHlwZSwgdmlld1R5cGUpIHtcbiAgdmFyIFJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzW2dlb21ldHJ5VHlwZV0gJiZcbiAgICAgIHRoaXMuX3JlbmRlcmVyc1tnZW9tZXRyeVR5cGVdW3ZpZXdUeXBlXTtcbiAgcmV0dXJuIFJlbmRlcmVyIHx8IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyUmVnaXN0cnk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBXb3JrUXVldWUgPSByZXF1aXJlKCcuLi9jb2xsZWN0aW9ucy9Xb3JrUXVldWUnKTtcbnZhciBjYWxjUmVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvY2FsY1JlY3QnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvYXN5bmMnKTtcbnZhciBjYW5jZWxpemUgPSByZXF1aXJlKCcuLi91dGlsL2NhbmNlbGl6ZScpO1xudmFyIGNsZWFyT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2xlYXJPd25Qcm9wZXJ0aWVzJyk7XG5cbnZhciBSZW5kZXJlclJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9SZW5kZXJlclJlZ2lzdHJ5Jyk7XG5cbmZ1bmN0aW9uIGZvcndhcmRUaWxlQ21wKHQxLCB0Mikge1xuICByZXR1cm4gdDEuY21wKHQyKTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVRpbGVDbXAodDEsIHQyKSB7XG4gIHJldHVybiAtdDEuY21wKHQyKTtcbn1cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgdGhlIHN0YWdlIGhhcyBiZWVuIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhYmxlIFdoZXRoZXIgYWxsIHRpbGVzIHdlcmUgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHdpdGhvdXRcbiAqICAgICBtaXNzaW5nIHRleHR1cmVzIG9yIHJlc29ydGluZyB0byBmYWxsYmFja3MuXG4gKiBAZXZlbnQgU3RhZ2UjcmVuZGVyQ29tcGxldGVcbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCB0aGUgY29udGVudHMgb2YgdGhlIHN0YWdlIGhhdmUgYmVlbiBpbnZhbGlkYXRlZCBhbmQgbXVzdCBiZVxuICogcmVuZGVyZWQgYWdhaW4uXG4gKlxuICogVGhpcyBpcyB1c2VkIGJ5IHRoZSB7QGxpbmsgUmVuZGVyTG9vcH0gaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV2ZW50IFN0YWdlI3JlbmRlckludmFsaWRcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgU3RhZ2VcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIFN0YWdlIGlzIGEgY29udGFpbmVyIHdpdGggdGhlIGFiaWxpdHkgdG8gcmVuZGVyIGEgc3RhY2sgb2ZcbiAqIHtAbGluayBMYXllciBsYXllcnN9LlxuICpcbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gVXNlIHtAbGluayBXZWJHbFN0YWdlfVxuICogaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wcm9ncmVzc2l2ZT1mYWxzZV1cbiAqXG4gKiBPcHRpb25zIGxpc3RlZCBoZXJlIG1heSBiZSBwYXNzZWQgaW50byB0aGUgYG9wdHNgIGNvbnN0cnVjdG9yIGFyZ3VtZW50IG9mXG4gKiBzdWJjbGFzc2VzLlxuICpcbiAqIFRoZSBgcHJvZ3Jlc3NpdmVgIG9wdGlvbiBjb250cm9scyB3aGV0aGVyIHJlc29sdXRpb24gbGV2ZWxzIGFyZSBsb2FkZWQgaW5cbiAqIG9yZGVyLCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LiBUaGlzIHJlc3VsdHMgaW4gYSBtb3JlIHBsZWFzaW5nIGVmZmVjdCB3aGVuXG4gKiB6b29taW5nIHBhc3Qgc2V2ZXJhbCBsZXZlbHMgaW4gYSBsYXJnZSBwYW5vcmFtYXMsIGJ1dCBjb25zdW1lcyBhZGRpdGlvbmFsXG4gKiBiYW5kd2lkdGguXG4gKi9cbmZ1bmN0aW9uIFN0YWdlKG9wdHMpIHtcbiAgdGhpcy5fcHJvZ3Jlc3NpdmUgPSAhIShvcHRzICYmIG9wdHMucHJvZ3Jlc3NpdmUpO1xuXG4gIC8vIFRoZSBsaXN0IG9mIGxheWVycyBpbiBkaXNwbGF5IG9yZGVyIChiYWNrZ3JvdW5kIHRvIGZvcmVncm91bmQpLlxuICB0aGlzLl9sYXllcnMgPSBbXTtcblxuICAvLyBUaGUgbGlzdCBvZiByZW5kZXJlcnM7IHRoZSBpLXRoIHJlbmRlcmVyIGlzIGZvciB0aGUgaS10aCBsYXllci5cbiAgdGhpcy5fcmVuZGVyZXJzID0gW107XG5cbiAgLy8gVGhlIGxpc3RzIG9mIHRpbGVzIHRvIGxvYWQgYW5kIHJlbmRlciwgcG9wdWxhdGVkIGR1cmluZyByZW5kZXIoKS5cbiAgdGhpcy5fdGlsZXNUb0xvYWQgPSBbXTtcbiAgdGhpcy5fdGlsZXNUb1JlbmRlciA9IFtdO1xuXG4gIC8vIFRlbXBvcmFyeSB0aWxlIGxpc3RzLlxuICB0aGlzLl90bXBWaXNpYmxlID0gW107XG4gIHRoaXMuX3RtcENoaWxkcmVuID0gW107XG5cbiAgLy8gQ2FjaGVkIHN0YWdlIGRpbWVuc2lvbnMuXG4gIC8vIFN0YXJ0IHdpdGggemVybywgd2hpY2ggaW5oaWJpdHMgcmVuZGVyaW5nIHVudGlsIHNldFNpemUoKSBpcyBjYWxsZWQuXG4gIHRoaXMuX3dpZHRoID0gMDtcbiAgdGhpcy5faGVpZ2h0ID0gMDtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIHJlY3QuXG4gIHRoaXMuX3RtcFJlY3QgPSB7fTtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZm9yIHNpemUuXG4gIHRoaXMuX3RtcFNpemUgPSB7fTtcblxuICAvLyBXb3JrIHF1ZXVlIGZvciBjcmVhdGVUZXh0dXJlLlxuICB0aGlzLl9jcmVhdGVUZXh0dXJlV29ya1F1ZXVlID0gbmV3IFdvcmtRdWV1ZSgpO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGVtaXQgZXZlbnQgd2hlbiByZW5kZXIgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkID0gdGhpcy5fZW1pdFJlbmRlckludmFsaWQuYmluZCh0aGlzKTtcblxuICAvLyBUaGUgcmVuZGVyZXIgcmVnaXN0cnkgbWFwcyBlYWNoIGdlb21ldHJ5L3ZpZXcgcGFpciBpbnRvIHRoZSByZXNwZWN0aXZlXG4gIC8vIFJlbmRlcmVyIGNsYXNzLlxuICB0aGlzLl9yZW5kZXJlclJlZ2lzdHJ5ID0gbmV3IFJlbmRlcmVyUmVnaXN0cnkoKTtcbn1cblxuZXZlbnRFbWl0dGVyKFN0YWdlKTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblN0YWdlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlQWxsTGF5ZXJzKCk7XG4gIGNsZWFyT3duUHJvcGVydGllcyh0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSB7QGxpbmsgUmVuZGVyZXJ9IGZvciB0aGUgZ2l2ZW4ge0BsaW5rIEdlb21ldHJ5fSBhbmQge0BsaW5rIFZpZXd9XG4gKiB0eXBlLlxuICpcbiAqIFRoZSB7QGxpbmsgcmVnaXN0ZXJEZWZhdWx0UmVuZGVyZXJzfSB1dGlsaXR5IGZ1bmN0aW9uIG1heSBiZSB1c2VkIHRvXG4gKiByZWdpc3RlciBhbGwga25vd24gcmVuZGVyZXJzIGZvciBhIHN0YWdlIHR5cGUgaW50byB0aGF0IHN0YWdlLiBNb3N0IHVzZXJzXG4gKiB3aWxsIG5vdCBuZWVkIHRvIHJlZ2lzdGVyIHJlbmRlcmVycywgYXMge0BsaW5rIFZpZXdlcn0gZG9lcyBpdCBmb3IgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2VvbWV0cnlUeXBlIFRoZSBnZW9tZXRyeSB0eXBlLCBhcyBnaXZlbiBieVxuICogICAgIHtAbGluayBHZW9tZXRyeSN0eXBlfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3VHlwZSBUaGUgdmlldyB0eXBlLCBhcyBnaXZlbiBieSB7QGxpbmsgVmlldyN0eXBlfS5cbiAqIEBwYXJhbSB7Kn0gUmVuZGVyZXIgVGhlIHJlbmRlcmVyIGNsYXNzLlxuICovXG5TdGFnZS5wcm90b3R5cGUucmVnaXN0ZXJSZW5kZXJlciA9IGZ1bmN0aW9uKGdlb21ldHJ5VHlwZSwgdmlld1R5cGUsIFJlbmRlcmVyKSB7XG4gIHJldHVybiB0aGlzLl9yZW5kZXJlclJlZ2lzdHJ5LnNldChnZW9tZXRyeVR5cGUsIHZpZXdUeXBlLCBSZW5kZXJlcik7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqXG4gKiBNdXN0IGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5TdGFnZS5wcm90b3R5cGUuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgZG9tRWxlbWVudCcpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgc3RhZ2Ugd2lkdGguXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblN0YWdlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGg7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBzdGFnZSBoZWlnaHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblN0YWdlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHN0YWdlIGRpbWVuc2lvbnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aFxuICogdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1NpemU9fSBzaXplXG4gKi9cblN0YWdlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICBzaXplID0gc2l6ZSB8fCB7fTtcbiAgc2l6ZS53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICBzaXplLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzdGFnZSBkaW1lbnNpb25zLlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHNpemUgdXBkYXRlIGxvZ2ljIGNvbW1vbiB0byBhbGwgc3RhZ2UgdHlwZXMuIFN1YmNsYXNzZXNcbiAqIG11c3QgZGVmaW5lIHRoZSB7QGxpbmsgU3RhZ2Ujc2V0U2l6ZUZvclR5cGV9IG1ldGhvZCB0byBwZXJmb3JtIHRoZWlyIG93blxuICogbG9naWMuXG4gKlxuICogQHBhcmFtIHtTaXplfSBzaXplXG4gKi9cblN0YWdlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICB0aGlzLl93aWR0aCA9IHNpemUud2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gIHRoaXMuc2V0U2l6ZUZvclR5cGUoKTsgLy8gbXVzdCBiZSBkZWZpbmVkIGJ5IHN1YmNsYXNzZXMuXG5cbiAgdGhpcy5lbWl0KCdyZXNpemUnKTtcbiAgdGhpcy5fZW1pdFJlbmRlckludmFsaWQoKTtcbn07XG5cblxuLyoqXG4gKiBDYWxsIHtAbGluayBTdGFnZSNzZXRTaXplfSBpbnN0ZWFkLlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHNpemUgdXBkYXRlIGxvZ2ljIHNwZWNpZmljIHRvIGEgc3RhZ2UgdHlwZS4gSXQgaXMgY2FsbGVkIGJ5XG4gKiB7QGxpbmsgU3RhZ2Ujc2V0U2l6ZX0gYWZ0ZXIgdGhlIGJhc2UgY2xhc3MgaGFzIGJlZW4gdXBkYXRlZCB0byByZWZsZWN0IHRoZVxuICogbmV3IHNpemUsIGJ1dCBiZWZvcmUgYW55IGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAqXG4gKiBAcGFyYW0ge1NpemV9IHNpemVcbiAqL1xuU3RhZ2UucHJvdG90eXBlLnNldFNpemVGb3JUeXBlID0gZnVuY3Rpb24oc2l6ZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgc2V0U2l6ZUZvclR5cGUnKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkcyBhbiB7QGxpbmsgQXNzZXR9IGZyb20gYW4gaW1hZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBpbWFnZSBVUkwuXG4gKiBAcGFyYW0gez9SZWN0fSByZWN0IEEge0BsaW5rIFJlY3R9IGRlc2NyaWJpbmcgYSBwb3J0aW9uIG9mIHRoZSBpbWFnZSwgb3IgbnVsbFxuICogICAgIHRvIHVzZSB0aGUgZnVsbCBpbWFnZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCBBc3NldCl9IGRvbmUgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gQSBmdW5jdGlvbiB0byBjYW5jZWwgbG9hZGluZy5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgbG9hZEltYWdlJyk7XG59O1xuXG4vKipcbiAqIExvYWRzIGFuIHtAbGluayBBc3NldH0gZnJvbSBhIDNEIG1vZGVsIGZpbGUsIG9ubHkgc3VwcG9ydCBTVEwgZm9yIG5vdy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFNUTCBmaWxlIFVSTC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yLCBBc3NldCl9IGRvbmUgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gQSBmdW5jdGlvbiB0byBjYW5jZWwgbG9hZGluZy5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLmxvYWRNb2RlbCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgbG9hZFNUTE1vZGVsJyk7XG59O1xuXG5TdGFnZS5wcm90b3R5cGUuX2VtaXRSZW5kZXJJbnZhbGlkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgncmVuZGVySW52YWxpZCcpO1xufTtcblxuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgdGhlIGxheWVyIGlzIHZhbGlkIGZvciB0aGlzIHN0YWdlLCB0aHJvd2luZyBhbiBleGNlcHRpb25cbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBsYXllciBpcyBub3QgdmFsaWQgZm9yIHRoaXMgc3RhZ2UuXG4gKi9cblN0YWdlLnByb3RvdHlwZS52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBpbXBsZW1lbnRhdGlvbiBtdXN0IG92ZXJyaWRlIHZhbGlkYXRlTGF5ZXInKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwge0BsaW5rIExheWVyIGxheWVyc30gYmVsb25naW5nIHRvIHRoZSBzdGFnZS4gVGhlXG4gKiByZXR1cm5lZCBsaXN0IGlzIGluIGRpc3BsYXkgb3JkZXIsIGJhY2tncm91bmQgdG8gZm9yZWdyb3VuZC5cbiAqIEByZXR1cm4ge0xheWVyW119XG4gKi9cblN0YWdlLnByb3RvdHlwZS5saXN0TGF5ZXJzID0gZnVuY3Rpb24oKSB7XG4gIC8vIFJldHVybiBhIGNvcHkgdG8gcHJldmVudCB1bmludGVuZGVkIG11dGF0aW9uIGJ5IHRoZSBjYWxsZXIuXG4gIHJldHVybiBbXS5jb25jYXQodGhpcy5fbGF5ZXJzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIHtAbGluayBMYXllciBsYXllcn0gYmVsb25ncyB0byB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuU3RhZ2UucHJvdG90eXBlLmhhc0xheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgcmV0dXJuIHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKSA+PSAwO1xufTtcblxuXG4vKipcbiAqIEFkZHMgYSB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGludG8gdGhlIHN0YWdlLlxuICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGFkZC5cbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gaSBUaGUgb3B0aW9uYWwgcG9zaXRpb24sIHdoZXJlIDAg4omkIGkg4omkIG4gYW5kIG4gaXNcbiAqICAgICB0aGUgY3VycmVudCBudW1iZXIgb2YgbGF5ZXJzLiBUaGUgZGVmYXVsdCBpcyBuLCB3aGljaCBpbnNlcnRzIGF0IHRoZVxuICogICAgIHRvcCBvZiB0aGUgZGlzcGxheSBzdGFjay5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGxheWVyIGFscmVhZHkgYmVsb25ncyB0byB0aGUgc3RhZ2Ugb3IgaWYgdGhlIHBvc2l0aW9uXG4gKiAgICAgaXMgaW52YWxpZC5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGkpIHtcbiAgaWYgKHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMYXllciBhbHJlYWR5IGluIHN0YWdlJyk7XG4gIH1cblxuICBpZiAoaSA9PSBudWxsKSB7XG4gICAgaSA9IHRoaXMuX2xheWVycy5sZW5ndGg7XG4gIH1cbiAgaWYgKGkgPCAwIHx8IGkgPiB0aGlzLl9sYXllcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxheWVyIHBvc2l0aW9uJyk7XG4gIH1cblxuICB0aGlzLnZhbGlkYXRlTGF5ZXIobGF5ZXIpOyAvLyBtdXN0IGJlIGRlZmluZWQgYnkgc3ViY2xhc3Nlcy5cblxuICB2YXIgZ2VvbWV0cnlUeXBlID0gbGF5ZXIuZ2VvbWV0cnkoKS50eXBlO1xuICBpZiAobGF5ZXIuZGVwdGhtYXAoKSkge1xuICAgIGdlb21ldHJ5VHlwZSArPSAnK2RlcHRoJztcbiAgfVxuICB2YXIgdmlld1R5cGUgPSBsYXllci52aWV3KCkudHlwZTtcbiAgdmFyIHJlbmRlcmVyQ2xhc3MgPSB0aGlzLl9yZW5kZXJlclJlZ2lzdHJ5LmdldChnZW9tZXRyeVR5cGUsIHZpZXdUeXBlKTtcbiAgaWYgKCFyZW5kZXJlckNsYXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyAnICsgdGhpcy50eXBlICsgJyByZW5kZXJlciBhdmFpYWJsZSBmb3IgJyArXG4gICAgICAgIGdlb21ldHJ5VHlwZSArICcgZ2VvbWV0cnkgYW5kICcgKyB2aWV3VHlwZSArICcgdmlldycpO1xuICB9XG4gIHZhciByZW5kZXJlciA9IHRoaXMuY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJDbGFzcywgeyBsYXllciB9KTtcblxuICB0aGlzLl9sYXllcnMuc3BsaWNlKGksIDAsIGxheWVyKTtcbiAgdGhpcy5fcmVuZGVyZXJzLnNwbGljZShpLCAwLCByZW5kZXJlcik7XG5cbiAgLy8gTGlzdGVuZXJzIGZvciByZW5kZXIgaW52YWxpZC5cbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZWZmZWN0c0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZml4ZWRMZXZlbENoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndGV4dHVyZVN0b3JlQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogTW92ZXMgYSB7QGxpbmsgTGF5ZXIgbGF5ZXJ9IGludG8gYSBkaWZmZXJlbnQgcG9zaXRpb24gaW4gdGhlIGRpc3BsYXkgc3RhY2suXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gbW92ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBwb3NpdGlvbiwgd2hlcmUgMCDiiaQgaSDiiaQgbi0xIGFuZCBuIGlzIHRoZSBjdXJyZW50IG51bWJlclxuICogICAgIG9mIGxheWVycy5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGxheWVyIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgc3RhZ2Ugb3IgaWYgdGhlIHBvc2l0aW9uXG4gKiAgICAgaXMgaW52YWxpZC5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLm1vdmVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBpKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2xheWVycy5pbmRleE9mKGxheWVyKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBsYXllciBpbiBzdGFnZScpO1xuICB9XG5cbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5fbGF5ZXJzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsYXllciBwb3NpdGlvbicpO1xuICB9XG5cbiAgbGF5ZXIgPSB0aGlzLl9sYXllcnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG5cbiAgdGhpcy5fbGF5ZXJzLnNwbGljZShpLCAwLCBsYXllcik7XG4gIHRoaXMuX3JlbmRlcmVycy5zcGxpY2UoaSwgMCwgcmVuZGVyZXIpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhIHtAbGluayBMYXllcn0gZnJvbSB0aGUgc3RhZ2UuXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gcmVtb3ZlLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgbGF5ZXIgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBzdGFnZS5cbiAqL1xuU3RhZ2UucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGxheWVyIGluIHN0YWdlJyk7XG4gIH1cblxuICB2YXIgcmVtb3ZlZExheWVyID0gdGhpcy5fbGF5ZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG4gIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuXG4gIHRoaXMuZGVzdHJveVJlbmRlcmVyKHJlbmRlcmVyKTtcblxuICByZW1vdmVkTGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlld0NoYW5nZScsIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKTtcbiAgcmVtb3ZlZExheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VmZmVjdHNDaGFuZ2UnLCB0aGlzLl9lbWl0UmVuZGVySW52YWxpZCk7XG4gIHJlbW92ZWRMYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdmaXhlZExldmVsQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuICByZW1vdmVkTGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGV4dHVyZVN0b3JlQ2hhbmdlJywgdGhpcy5fZW1pdFJlbmRlckludmFsaWQpO1xuXG4gIHRoaXMuX2VtaXRSZW5kZXJJbnZhbGlkKCk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwge0BsaW5rIExheWVyIGxheWVyc30gZnJvbSB0aGUgc3RhZ2UuXG4gKi9cblN0YWdlLnByb3RvdHlwZS5yZW1vdmVBbGxMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMuX2xheWVycy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbMF0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2FsbGVkIGJlZm9yZSBhIGZyYW1lIGlzIHJlbmRlcmVkLlxuICpcbiAqIE11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICovXG5TdGFnZS5wcm90b3R5cGUuc3RhcnRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0YWdlIGltcGxlbWVudGF0aW9uIG11c3Qgb3ZlcnJpZGUgc3RhcnRGcmFtZScpO1xufTtcblxuXG4vKipcbiAqIENhbGxlZCBhZnRlciBhIGZyYW1lIGlzIHJlbmRlcmVkLlxuICpcbiAqIE11c3QgYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICovXG5TdGFnZS5wcm90b3R5cGUuZW5kRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBpbXBsZW1lbnRhdGlvbiBtdXN0IG92ZXJyaWRlIGVuZEZyYW1lJyk7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyIHRoZSBjdXJyZW50IGZyYW1lLiBVc3VhbGx5IGNhbGxlZCBmcm9tIGEge0BsaW5rIFJlbmRlckxvb3B9LlxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIHJlbmRlcmluZyBsb2dpYyBjb21tb24gdG8gYWxsIHN0YWdlIHR5cGVzLiBTdWJjbGFzc2VzXG4gKiBkZWZpbmUgdGhlIHN0YXJ0RnJhbWUoKSBhbmQgZW5kRnJhbWUoKSBtZXRob2RzIHRvIHBlcmZvcm0gdGhlaXIgb3duIGxvZ2ljLlxuICovXG5TdGFnZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpLCBqO1xuXG4gIHZhciB0aWxlc1RvTG9hZCA9IHRoaXMuX3RpbGVzVG9Mb2FkO1xuICB2YXIgdGlsZXNUb1JlbmRlciA9IHRoaXMuX3RpbGVzVG9SZW5kZXI7XG5cbiAgdmFyIHN0YWJsZVN0YWdlID0gdHJ1ZTtcbiAgdmFyIHN0YWJsZUxheWVyO1xuXG4gIC8vIEdldCB0aGUgc3RhZ2UgZGltZW5zaW9ucy5cbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgdmFyIHJlY3QgPSB0aGlzLl90bXBSZWN0O1xuICB2YXIgc2l6ZSA9IHRoaXMuX3RtcFNpemU7XG5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXJ0RnJhbWUoKTsgLy8gZGVmaW5lZCBieSBzdWJjbGFzc2VzXG5cbiAgLy8gU2lnbmFsIHN0YXJ0IG9mIGZyYW1lIHRvIHRoZSB0ZXh0dXJlIHN0b3Jlcy5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2xheWVyc1tpXS50ZXh0dXJlU3RvcmUoKS5zdGFydEZyYW1lKCk7XG4gIH1cblxuICAvLyBSZW5kZXIgbGF5ZXJzLlxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xuICAgIHZhciBlZmZlY3RzID0gbGF5ZXIuZWZmZWN0cygpO1xuICAgIHZhciB2aWV3ID0gbGF5ZXIudmlldygpO1xuICAgIHZhciB0ZXh0dXJlU3RvcmUgPSBsYXllci50ZXh0dXJlU3RvcmUoKTtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcnNbaV07XG4gICAgdmFyIGRlcHRoID0gdGhpcy5fbGF5ZXJzLmxlbmd0aCAtIGk7XG4gICAgdmFyIHRpbGUsIHRleHR1cmU7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSByZWN0IGVmZmVjdCBpbnRvIGEgbm9ybWFsaXplZCByZWN0LlxuICAgIC8vIFRPRE86IGF2b2lkIGRvaW5nIHRoaXMgb24gZXZlcnkgZnJhbWUuXG4gICAgY2FsY1JlY3Qod2lkdGgsIGhlaWdodCwgZWZmZWN0cyAmJiBlZmZlY3RzLnJlY3QsIHJlY3QpO1xuXG4gICAgaWYgKHJlY3Qud2lkdGggPD0gMCB8fCByZWN0LmhlaWdodCA8PSAwKSB7XG4gICAgICAvLyBTa2lwIHJlbmRlcmluZyBvbiBhIG51bGwgdmlld3BvcnQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZpZXcgc2l6ZS5cbiAgICBzaXplLndpZHRoID0gcmVjdC53aWR0aCAqIHRoaXMuX3dpZHRoO1xuICAgIHNpemUuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiB0aGlzLl9oZWlnaHQ7XG4gICAgdmlldy5zZXRTaXplKHNpemUpO1xuXG4gICAgLy8gU2lnbmFsIHN0YXJ0IG9mIGxheWVyIHRvIHRoZSByZW5kZXJlci5cbiAgICByZW5kZXJlci5zdGFydExheWVyKGxheWVyLCByZWN0KTtcblxuICAgIC8vIFdlIHJlbmRlciB3aXRoIGJvdGggYWxwaGEgYmxlbmRpbmcgYW5kIGRlcHRoIHRlc3RpbmcgZW5hYmxlZC4gVGh1cywgd2hlblxuICAgIC8vIHJlbmRlcmluZyBhIHN1YnNlcXVlbnQgcGl4ZWwgYXQgdGhlIHNhbWUgbG9jYXRpb24gdGhhbiBhbiBleGlzdGluZyBvbmUsXG4gICAgLy8gdGhlIHN1YnNlcXVlbnQgcGl4ZWwgZ2V0cyBkaXNjYXJkZWQgdW5sZXNzIGl0IGhhcyBzbWFsbGVyIGRlcHRoLCBhbmQgaXNcbiAgICAvLyBvdGhlcndpc2UgY29tcG9zaXRlZCB3aXRoIHRoZSBleGlzdGluZyBwaXhlbC5cbiAgICAvL1xuICAgIC8vIFdoZW4gdXNpbmcgZmFsbGJhY2sgdGlsZXMgdG8gZmlsbCBhIGdhcCBpbiB0aGUgcHJlZmVycmVkIHJlc29sdXRpb25cbiAgICAvLyBsZXZlbCwgd2UgcHJlZmVyIGhpZ2hlciByZXNvbHV0aW9uIGZhbGxiYWNrcyB0byBsb3dlciByZXNvbHV0aW9uIG9uZXMuXG4gICAgLy8gSG93ZXZlciwgd2hlcmUgZmFsbGJhY2tzIG92ZXJsYXAsIHdlIHdhbnQgaGlnaGVyIHJlc29sdXRpb24gb25lcyB0b1xuICAgIC8vIHByZXZhaWwsIGFuZCB3ZSBkb24ndCB3YW50IG11bHRpcGxlIGZhbGxiYWNrcyB0byBiZSBjb21wb3NpdGVkIHdpdGggZWFjaFxuICAgIC8vIG90aGVyLCBhcyB0aGF0IHdvdWxkIHByb2R1Y2UgYSBiYWQgcmVzdWx0IHdoZW4gc2VtaXRyYW5zcGFyZW50IHRleHR1cmVzXG4gICAgLy8gYXJlIGludm9sdmVkLlxuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYWNoaWV2ZSB0aGlzIHdpdGhpbiB0aGUgY29uc3RyYWludHMgb2YgYWxwaGEgYmxlbmRpbmcgYW5kXG4gICAgLy8gZGVwdGggdGVzdGluZywgdGhlIGRlcHRoIG9mIGEgdGlsZSBtdXN0IGJlIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gaXRzXG4gICAgLy8gcmVzb2x1dGlvbiwgYW5kIGhpZ2hlci1yZXNvbHV0aW9uIHRpbGVzIG11c3QgYmUgcmVuZGVyZWQgYmVmb3JlIGxvd2VyLVxuICAgIC8vIHJlc29sdXRpb24gb25lcy5cblxuICAgIC8vIENvbGxlY3QgdGhlIGxpc3RzIG9mIHRpbGVzIHRvIGxvYWQgYW5kIHJlbmRlci5cbiAgICBzdGFibGVMYXllciA9IHRoaXMuX2NvbGxlY3RUaWxlcyhsYXllciwgdGV4dHVyZVN0b3JlKTtcblxuICAgIC8vIE1hcmsgYWxsIHRoZSB0aWxlcyB3aG9zZSB0ZXh0dXJlcyBtdXN0IGJlIGxvYWRlZC5cbiAgICAvLyBUaGlzIHdpbGwgZWl0aGVyIHRyaWdnZXIgbG9hZGluZyAoZm9yIHRleHR1cmVzIG5vdCB5ZXQgbG9hZGVkKSBvclxuICAgIC8vIHByZXZlbnQgdW5sb2FkaW5nIChmb3IgdGV4dHVyZXMgYWxyZWFkeSBsb2FkZWQpLlxuICAgIGZvciAoaiA9IDA7IGogPCB0aWxlc1RvTG9hZC5sZW5ndGg7IGorKykge1xuICAgICAgdGlsZSA9IHRpbGVzVG9Mb2FkW2pdO1xuICAgICAgdGV4dHVyZVN0b3JlLm1hcmtUaWxlKHRpbGUpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciB0aWxlcy5cbiAgICBmb3IgKGogPSAwOyBqIDwgdGlsZXNUb1JlbmRlci5sZW5ndGg7IGorKykge1xuICAgICAgdGlsZSA9IHRpbGVzVG9SZW5kZXJbal07XG4gICAgICB0ZXh0dXJlID0gdGV4dHVyZVN0b3JlLnRleHR1cmUodGlsZSk7XG4gICAgICByZW5kZXJlci5yZW5kZXJUaWxlKHRpbGUsIHRleHR1cmUsIGxheWVyLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgbGF5ZXIuZW1pdCgncmVuZGVyQ29tcGxldGUnLCBzdGFibGVMYXllcik7XG4gICAgaWYgKCFzdGFibGVMYXllcikge1xuICAgICAgc3RhYmxlU3RhZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTaWduYWwgZW5kIG9mIGxheWVyIHRvIHRoZSByZW5kZXJlci5cbiAgICByZW5kZXJlci5lbmRMYXllcihsYXllciwgcmVjdCk7XG4gIH1cblxuICAvLyBTaWduYWwgZW5kIG9mIGZyYW1lIHRvIHRoZSB0ZXh0dXJlIHN0b3Jlcy5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2xheWVyc1tpXS50ZXh0dXJlU3RvcmUoKS5lbmRGcmFtZSgpO1xuICB9XG5cbiAgdGhpcy5lbmRGcmFtZSgpOyAvLyBkZWZpbmVkIGJ5IHN1YmNsYXNzZXNcblxuICB0aGlzLmVtaXQoJ3JlbmRlckNvbXBsZXRlJywgc3RhYmxlU3RhZ2UpO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0VGlsZXMgPSBmdW5jdGlvbihsYXllciwgdGV4dHVyZVN0b3JlKSB7XG4gIHZhciB0aWxlc1RvTG9hZCA9IHRoaXMuX3RpbGVzVG9Mb2FkO1xuICB2YXIgdGlsZXNUb1JlbmRlciA9IHRoaXMuX3RpbGVzVG9SZW5kZXI7XG4gIHZhciB0bXBWaXNpYmxlID0gdGhpcy5fdG1wVmlzaWJsZTtcblxuICB0aWxlc1RvTG9hZC5sZW5ndGggPSAwO1xuICB0aWxlc1RvUmVuZGVyLmxlbmd0aCA9IDA7XG4gIHRtcFZpc2libGUubGVuZ3RoID0gMDtcblxuICBsYXllci52aXNpYmxlVGlsZXModG1wVmlzaWJsZSk7XG5cbiAgdmFyIGlzU3RhYmxlID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcFZpc2libGUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGlsZSA9IHRtcFZpc2libGVbaV07XG4gICAgdmFyIG5lZWRzRmFsbGJhY2s7XG4gICAgdGhpcy5fY29sbGVjdFRpbGVUb0xvYWQodGlsZSk7XG4gICAgaWYgKHRleHR1cmVTdG9yZS50ZXh0dXJlKHRpbGUpKSB7XG4gICAgICAvLyBUaGUgcHJlZmVycmVkIHRleHR1cmUgaXMgYXZhaWxhYmxlLlxuICAgICAgLy8gTm8gZmFsbGJhY2sgaXMgcmVxdWlyZWQuXG4gICAgICBuZWVkc0ZhbGxiYWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9jb2xsZWN0VGlsZVRvUmVuZGVyKHRpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcHJlZmVycmVkIHRleHR1cmUgaXMgdW5hdmFpbGFibGUuXG4gICAgICAvLyBDb2xsZWN0IGNoaWxkcmVuIGZvciByZW5kZXJpbmcgYXMgYSBmYWxsYmFjay5cbiAgICAgIG5lZWRzRmFsbGJhY2sgPSB0aGlzLl9jb2xsZWN0Q2hpbGRyZW4odGlsZSwgdGV4dHVyZVN0b3JlKTtcbiAgICAgIGlzU3RhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENvbGxlY3QgYWxsIHBhcmVudHMgZm9yIGxvYWRpbmcsIGFuZCB0aGUgY2xvc2VzdCBwYXJlbnQgZm9yIHJlbmRlcmluZyBpZlxuICAgIC8vIGEgZmFsbGJhY2sgaXMgcmVxdWlyZWQuXG4gICAgdGhpcy5fY29sbGVjdFBhcmVudHModGlsZSwgdGV4dHVyZVN0b3JlLCBuZWVkc0ZhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNvcnQgdGlsZXMgdG8gbG9hZCBpbiBhc2NlbmRpbmcgcmVzb2x1dGlvbiBvcmRlci5cbiAgdGlsZXNUb0xvYWQuc29ydChmb3J3YXJkVGlsZUNtcCk7XG5cbiAgLy8gU29ydCB0aWxlcyB0byByZW5kZXIgaW4gZGVzY2VuZGluZyByZXNvbHV0aW9uIG9yZGVyLlxuICB0aWxlc1RvUmVuZGVyLnNvcnQocmV2ZXJzZVRpbGVDbXApO1xuXG4gIHJldHVybiBpc1N0YWJsZTtcbn07XG5cblN0YWdlLnByb3RvdHlwZS5fY29sbGVjdENoaWxkcmVuID0gZnVuY3Rpb24odGlsZSwgdGV4dHVyZVN0b3JlKSB7XG4gIHZhciB0bXBDaGlsZHJlbiA9IHRoaXMuX3RtcENoaWxkcmVuO1xuXG4gIHZhciBuZWVkc0ZhbGxiYWNrID0gdHJ1ZTtcblxuICAvLyBGYWxsIGJhY2sgYXMgbWFueSBsZXZlbHMgYXMgbmVjZXNzYXJ5IG9uIHNpbmdsZS1jaGlsZCBnZW9tZXRyaWVzLCBidXQgZG9cbiAgLy8gbm90IGdvIGJleW9uZCBpbW1lZGlhdGUgY2hpbGRyZW4gb24gbXVsdGlwbGUtY2hpbGQgZ2VvbWV0cmllcywgdG8gYXZvaWRcbiAgLy8gZXhwbG9yaW5nIGFuIGV4cG9uZW50aWFsIG51bWJlciBvZiB0aWxlcy5cbiAgZG8ge1xuICAgIHRtcENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgaWYgKCF0aWxlLmNoaWxkcmVuKHRtcENoaWxkcmVuKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5lZWRzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aWxlID0gdG1wQ2hpbGRyZW5baV07XG4gICAgICBpZiAodGV4dHVyZVN0b3JlLnRleHR1cmUodGlsZSkpIHtcbiAgICAgICAgdGhpcy5fY29sbGVjdFRpbGVUb0xvYWQodGlsZSk7XG4gICAgICAgIHRoaXMuX2NvbGxlY3RUaWxlVG9SZW5kZXIodGlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWVkc0ZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKG5lZWRzRmFsbGJhY2sgJiYgdG1wQ2hpbGRyZW4ubGVuZ3RoID09PSAxKVxuXG4gIHJldHVybiBuZWVkc0ZhbGxiYWNrO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0UGFyZW50cyA9IGZ1bmN0aW9uKHRpbGUsIHRleHR1cmVTdG9yZSwgbmVlZHNGYWxsYmFjaykge1xuICAvLyBSZWN1cnNpdmVseSB2aXNpdCBwYXJlbnQgdGlsZXMgdW50aWw6XG4gIC8vICAgLSBhbGwgcGFyZW50cyBoYXZlIGJlZW4gbWFya2VkIGZvciBsb2FkaW5nLCBpZiBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXNcbiAgLy8gICAgIGVuYWJsZWQ7IGFuZFxuICAvLyAgIC0gYXQgbGVhc3Qgb25lIHBhcmVudCBoYXMgYmVlbiBtYXJrZWQgZm9yIGJvdGggbG9hZGluZyBhbmQgcmVuZGVyaW5nLCBpZlxuICAvLyAgICAgYSBmYWxsYmFjayBpcyByZXF1aXJlZC5cbiAgdmFyIG5lZWRzTG9hZGluZyA9IHRoaXMuX3Byb2dyZXNzaXZlO1xuICB3aGlsZSAoKG5lZWRzTG9hZGluZyB8fCBuZWVkc0ZhbGxiYWNrKSAmJiAodGlsZSA9IHRpbGUucGFyZW50KCkpICE9IG51bGwpIHtcbiAgICBpZiAobmVlZHNGYWxsYmFjaykge1xuICAgICAgaWYgKHRleHR1cmVTdG9yZS50ZXh0dXJlKHRpbGUpKSB7XG4gICAgICAgIHRoaXMuX2NvbGxlY3RUaWxlVG9SZW5kZXIodGlsZSk7XG4gICAgICAgIG5lZWRzRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3Byb2dyZXNzaXZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2NvbGxlY3RUaWxlVG9Mb2FkKHRpbGUpKSB7XG4gICAgICBuZWVkc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWRzRmFsbGJhY2s7XG59O1xuXG5TdGFnZS5wcm90b3R5cGUuX2NvbGxlY3RUaWxlVG9Mb2FkID0gZnVuY3Rpb24odGlsZSkge1xuICByZXR1cm4gdGhpcy5fY29sbGVjdFRpbGVJbnRvTGlzdCh0aWxlLCB0aGlzLl90aWxlc1RvTG9hZCk7XG59O1xuXG5TdGFnZS5wcm90b3R5cGUuX2NvbGxlY3RUaWxlVG9SZW5kZXIgPSBmdW5jdGlvbih0aWxlKSB7XG4gIHJldHVybiB0aGlzLl9jb2xsZWN0VGlsZUludG9MaXN0KHRpbGUsIHRoaXMuX3RpbGVzVG9SZW5kZXIpO1xufTtcblxuU3RhZ2UucHJvdG90eXBlLl9jb2xsZWN0VGlsZUludG9MaXN0ID0gZnVuY3Rpb24odGlsZSwgdGlsZUxpc3QpIHtcbiAgLy8gVE9ETzogSW52ZXN0aWdhdGUgd2hldGhlciBpdCdzIHdvcnRoIGl0IHRvIG1ha2UgdGhpcyBiZXR0ZXIgdGhhbiBPKG7CsikuXG4gIHZhciBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRpbGUuZXF1YWxzKHRpbGVMaXN0W2ldKSkge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghZm91bmQpIHtcbiAgICB0aWxlTGlzdC5wdXNoKHRpbGUpO1xuICB9XG4gIHJldHVybiAhZm91bmQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRleHR1cmUgZm9yIHRoZSBnaXZlbiB0aWxlIGFuZCBhc3NldC4gQ2FsbGVkIGJ5IHtAbGluayBUZXh0dXJlU3RvcmV9IGFuZCB7QGxpbmsgRGVwdGhtYXBTdG9yZX0uXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGVcbiAqIEBwYXJhbSB7QXNzZXR9IGFzc2V0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cblN0YWdlLnByb3RvdHlwZS5jcmVhdGVUZXh0dXJlID0gZnVuY3Rpb24odGlsZSwgYXNzZXQsIGRvbmUpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gbWFrZVRleHR1cmUoKSB7XG4gICAgcmV0dXJuIG5ldyBzZWxmLlRleHR1cmVDbGFzcyhzZWxmLCB0aWxlLCBhc3NldCk7XG4gIH1cblxuICB2YXIgZm4gPSBjYW5jZWxpemUoYXN5bmMobWFrZVRleHR1cmUpKTtcblxuICByZXR1cm4gdGhpcy5fY3JlYXRlVGV4dHVyZVdvcmtRdWV1ZS5wdXNoKGZuLCBmdW5jdGlvbihlcnIsIHRleHR1cmUpIHtcbiAgICBkb25lKGVyciwgdGlsZSwgYXNzZXQsIHRleHR1cmUpO1xuICB9KTtcblxufTtcblxuLyoqXG4gKiBUaGUgc3RhZ2UgdHlwZSwgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIHJlbmRlcmVyIGZvciBhIGdpdmVuXG4gKiBnZW9tZXRyeSBhbmQgdmlldy5cbiAqXG4gKiBUaGUgc29sZSBrbm93biB2YWx1ZSBpcyBgXCJ3ZWJnbFwiLlxuICpcbiAqIFNlZSBhbHNvIHtAbGluayBTdGFnZSNyZWdpc3RlclJlbmRlcmVyfS5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ31cbiAqIEBuYW1lIFN0YWdlI3R5cGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWdlO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RhZ2UgPSByZXF1aXJlKCcuL1N0YWdlJyk7XG52YXIgSHRtbEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vbG9hZGVycy9IdG1sSW1hZ2UnKTtcbnZhciBIdG1sTW9kZWxMb2FkZXIgPSByZXF1aXJlKCcuLi9sb2FkZXJzL0h0bWxNb2RlbCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCdib3dzZXInKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWwvaW5oZXJpdHMnKTtcbnZhciBwaXhlbFJhdGlvID0gcmVxdWlyZSgnLi4vdXRpbC9waXhlbFJhdGlvJyk7XG52YXIgaXNwb3QgPSByZXF1aXJlKCcuLi91dGlsL2lzcG90Jyk7XG52YXIgc2V0QWJzb2x1dGUgPSByZXF1aXJlKCcuLi91dGlsL2RvbScpLnNldEFic29sdXRlO1xudmFyIHNldEZ1bGxTaXplID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKS5zZXRGdWxsU2l6ZTtcbnZhciBjbGVhck93blByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91dGlsL2NsZWFyT3duUHJvcGVydGllcycpO1xuXG4vLyBUT0RPKHRqZ3EpOiBVbmlmeSBTdGFnZSBhbmQgV2ViR2xTdGFnZS5cblxuLy8gQnJvd3Nlci1zcGVjaWZpYyB3b3JrYXJvdW5kcy5cbnZhciBicm93c2VyUXVpcmtzID0ge1xuICAvLyBXaGV0aGVyIHRvIHVzZSB0ZXhJbWFnZTJEIGluc3RlYWQgb2YgdGV4U3ViSW1hZ2UyRCB3aGVuIHJlcGFpbnRpbmcgYW5cbiAgLy8gZXhpc3RpbmcgdGV4dHVyZSBmcm9tIGEgdmlkZW8gZWxlbWVudC4gT24gbW9zdCBicm93c2VycyB0ZXhTdWJJbWFnZTJEIGlzXG4gIC8vIGZhc3RlciwgYnV0IG9uIENocm9tZSB0aGUgcGVyZm9ybWFuY2UgZGVncmFkZXMgc2lnbmlmaWNhbnRseS4gU2VlOlxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MTI1NDJcbiAgdmlkZW9Vc2VUZXhJbWFnZTJEOiBicm93c2VyLmNocm9tZVxufTtcblxuXG5mdW5jdGlvbiBpbml0V2ViR2xDb250ZXh0KGNhbnZhcywgb3B0cykge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXG4gICAgYW50aWFsaWFzOiAhIShvcHRzICYmIG9wdHMuYW50aWFsaWFzKSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ICEhKG9wdHMgJiYgb3B0cy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpXG4gIH07XG5cbiAgdmFyIGdsID0gKGNhbnZhcy5nZXRDb250ZXh0KSAmJiAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgb3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG9wdGlvbnMpKTtcblxuICBpZiAoIWdsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFdlYkdMIGNvbnRleHQnKTtcbiAgfVxuXG4gIC8vIEVuYWJsZSBiYWNrLWZhY2UgY3VsbGluZ1xuICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgZ2wuZnJvbnRGYWNlKGdsLkNXKTtcbiAgZ2wuY3VsbEZhY2UoZ2wuRlJPTlQpOyAvLyBEaXNjYXJkIGZyb250LWZhY2luZyB0cmlhbmdsZXNcbiAgXG4gIGlmIChvcHRzLndyYXBDb250ZXh0KSB7XG4gICAgZ2wgPSBvcHRzLndyYXBDb250ZXh0KGdsKTtcbiAgfVxuXG4gIHJldHVybiBnbDtcbn1cblxuLyoqXG4gKiBAY2xhc3MgV2ViR2xTdGFnZVxuICogQGV4dGVuZHMgU3RhZ2VcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBBIHtAbGluayBTdGFnZX0gaW1wbGVtZW50YXRpb24gdXNpbmcgV2ViR2wuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYW50aWFsaWFzPWZhbHNlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmdlbmVyYXRlTWlwbWFwcz1mYWxzZV1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRzLndyYXBDb250ZXh0XVxuICpcbiAqIFRoZSBgYW50aWFsaWFzYCBhbmQgYHByZXNlcnZlRHJhd2luZ0J1ZmZlcmAgb3B0aW9ucyBjb250cm9sIHRoZSBXZWJHTFxuICogY29udGV4dCBhdHRyaWJ1dGVzIG9mIHRoZSBzYW1lIG5hbWUuIFRoZSBgYWxwaGFgIGFuZCBgcHJlbXVsdGlwbGllZEFscGhhYFxuICogV2ViR0wgY29udGV4dCBhdHRyaWJ1dGVzIGFyZSBzZXQgdG8gdGhlaXIgZGVmYXVsdCB0cnVlIHZhbHVlIGFuZCBjYW5ub3RcbiAqIGJlIG92ZXJyaWRlbjsgdGhpcyBhbGxvd3Mgc2VtaXRyYW5zcGFyZW50IHRleHR1cmVzIHRvIGJlIGNvbXBvc2l0ZWQgd2l0aFxuICogdGhlIHBhZ2UuIFNlZTpcbiAqIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzLzEuMC8jV0VCR0xDT05URVhUQVRUUklCVVRFU1xuICpcbiAqIFRoZSBgZ2VuZXJhdGVNaXBtYXBzYCBvcHRpb24gY29udHJvbHMgdGV4dHVyZSBtaXBtYXAgZ2VuZXJhdGlvbi4gTWlwbWFwc1xuICogbWF5IGltcHJvdmUgcmVuZGVyaW5nIHF1YWxpdHksIGF0IHRoZSBjb3N0IG9mIGluY3JlYXNlZCBtZW1vcnkgdXNhZ2UuXG4gKiBEdWUgdG8gdGVjaG5pY2FsIGxpbWl0YXRpb25zLCB0aGV5IGFyZSBvbmx5IGdlbmVyYXRlZCBmb3IgdGV4dHVyZXMgd2hvc2VcbiAqIGRpbWVuc2lvbnMgYXJlIGEgcG93ZXIgb2YgdHdvLiBTZWU6XG4gKiBodHRwczovL3d3dy5raHJvbm9zLm9yZy93ZWJnbC93aWtpL1dlYkdMX2FuZF9PcGVuR0xfRGlmZmVyZW5jZXMjTm9uLVBvd2VyX29mX1R3b19UZXh0dXJlX1N1cHBvcnRcbiAqXG4gKiBUaGUgYHdyYXBDb250ZXh0YCBvcHRpb24gaXMgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGFuZCByZXR1cm5zIGFcbiAqIFdlYkdMUmVuZGVyaW5nQ29udGV4dC4gVGhlIHN0YWdlIHdpbGwgdXNlIGl0cyByZXR1cm4gdmFsdWUgYXMgdGhlIGNvbnRleHQuXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzZWQgdG9nZXRoZXIgd2l0aCBXZWJHTERlYnVnVXRpbHMgdG8gZGVidWcgV2ViR0wgaXNzdWVzLlxuICogU2VlIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3dlYmdsL3dpa2kvRGVidWdnaW5nLlxuICpcbiAqIEFsc28gc2VlIHRoZSBhdmFpbGFibGUge0BsaW5rIFN0YWdlfSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBXZWJHbFN0YWdlKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5fZ2VuZXJhdGVNaXBtYXBzID0gb3B0cy5nZW5lcmF0ZU1pcG1hcHMgIT0gbnVsbCA/XG4gICAgb3B0cy5nZW5lcmF0ZU1pcG1hcHMgOiBmYWxzZTtcblxuICB0aGlzLl9sb2FkZXIgPSBuZXcgSHRtbEltYWdlTG9hZGVyKHRoaXMpO1xuICB0aGlzLl9tb2RlbExvYWRlciA9IG5ldyBIdG1sTW9kZWxMb2FkZXIodGhpcyk7XG5cbiAgdGhpcy5fZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gIHNldEFic29sdXRlKHRoaXMuX2RvbUVsZW1lbnQpO1xuICBzZXRGdWxsU2l6ZSh0aGlzLl9kb21FbGVtZW50KTtcblxuICB0aGlzLl9nbCA9IGluaXRXZWJHbENvbnRleHQodGhpcy5fZG9tRWxlbWVudCwgb3B0cyk7XG5cbiAgdGhpcy5faGFuZGxlQ29udGV4dExvc3MgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ3dlYmdsY29udGV4dGxvc3QnKTtcbiAgICBzZWxmLl9nbCA9IG51bGw7XG4gIH07XG5cbiAgLy8gSGFuZGxlIFdlYkdsIGNvbnRleHQgbG9zcy5cbiAgdGhpcy5fZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5faGFuZGxlQ29udGV4dExvc3MpO1xuXG4gIC8vIFdlYkdsIHJlbmRlcmVycyBhcmUgc2luZ2xldG9ucyBmb3IgYSBnaXZlbiBzdGFnZS4gVGhpcyBsaXN0IHN0b3JlcyB0aGVcbiAgLy8gZXhpc3RpbmcgcmVuZGVyZXJzIHNvIHRoZXkgY2FuIGJlIHJldXNlZCBhY3Jvc3MgbGF5ZXJzIHdpdGggdGhlIHNhbWVcbiAgLy8gZ2VvbWV0cnkgYW5kIHZpZXcgdHlwZS5cbiAgdGhpcy5fcmVuZGVyZXJJbnN0YW5jZXMgPSBbXTtcblxuICAvLyBXaWR0aCBhbmQgSGVpZ2h0IHNlZ21lbnRzIGZvciBkZXB0aG1hcCBtZXNoLlxuICB0aGlzLl93aWR0aFNlZ21lbnRzID0gb3B0cy53aWR0aFNlZ21lbnRzID8gb3B0cy53aWR0aFNlZ21lbnRzIDogdW5kZWZpbmVkO1xuICB0aGlzLl9oZWlnaHRTZWdtZW50cyA9IG9wdHMuaGVpZ2h0U2VnbWVudHMgPyBvcHRzLmhlaWdodFNlZ21lbnRzIDogdW5kZWZpbmVkO1xufVxuXG5pbmhlcml0cyhXZWJHbFN0YWdlLCBTdGFnZSk7XG5cblxuLyoqXG4gKiBEZXN0cnVjdG9yLlxuICovXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX2hhbmRsZUNvbnRleHRMb3NzKTtcbiAgLy8gRGVsZWdhdGUgY2xlYXJpbmcgb3duIHByb3BlcnRpZXMgdG8gdGhlIFN0YWdlIGRlc3RydWN0b3IuXG4gIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBET00gZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5kb21FbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9kb21FbGVtZW50O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXG4gKlxuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0IH1cbiAqL1xuV2ViR2xTdGFnZS5wcm90b3R5cGUud2ViR2xDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9nbDtcbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUuc2V0U2l6ZUZvclR5cGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gVXBkYXRlIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZS5cbiAgLy9cbiAgLy8gVGhlIHNpemUgaXMgb2J0YWluZWQgYnkgdGFraW5nIHRoZSBzdGFnZSBkaW1lbnNpb25zLCB3aGljaCBhcmUgc2V0IGluIENTU1xuICAvLyBwaXhlbHMsIGFuZCBtdWx0aXBseWluZyB0aGVtIGJ5IHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8uIENydWNpYWxseSwgdGhpc1xuICAvLyBtdXN0IGJlIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHRoZSBXZWJHTCByZW5kZXJpbmcgcGlwZWxpbmUgYWNjZXNzZXMgdGhlXG4gIC8vIHBpeGVsIHJhdGlvOyBzdWJzZXF1ZW50IHVzZXMgc2hvdWxkIHJlZmVyZW5jZSB0aGUgYGRyYXdpbmdCdWZmZXJXaWR0aGAgYW5kXG4gIC8vIGBkcmF3aW5nQnVmZmVySGVpZ2h0YCBwcm9wZXJ0aWVzIG9uIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuIEZhaWxpbmcgdG9cbiAgLy8gZG8gc28gd2lsbCBicmVhayB0aGUgcmVuZGVyaW5nIGlmIHRoZSBwaXhlbCByYXRpbyBjaGFuZ2VzIGJ1dCB0aGUgc3RhZ2VcbiAgLy8gc2l6ZSBkb2VzIG5vdCwgZS5nLiB3aGVuIG1vdmluZyB0aGUgd2luZG93IGFjcm9zcyBzY3JlZW5zLlxuICB2YXIgcmF0aW8gPSBwaXhlbFJhdGlvKCk7XG4gIHRoaXMuX2RvbUVsZW1lbnQud2lkdGggPSByYXRpbyAqIHRoaXMuX3dpZHRoO1xuICB0aGlzLl9kb21FbGVtZW50LmhlaWdodCA9IHJhdGlvICogdGhpcy5faGVpZ2h0O1xufTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIHJlY3QsIGRvbmUpIHtcbiAgcmV0dXJuIHRoaXMuX2xvYWRlci5sb2FkSW1hZ2UodXJsLCByZWN0LCBkb25lKTtcbn07XG5cbldlYkdsU3RhZ2UucHJvdG90eXBlLmxvYWRNb2RlbCA9IGZ1bmN0aW9uKHVybCwgZG9uZSkge1xuICByZXR1cm4gdGhpcy5fbW9kZWxMb2FkZXIubG9hZE1vZGVsKHVybCwgZG9uZSk7XG59O1xuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5tYXhUZXh0dXJlU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9URVhUVVJFX1NJWkUpO1xufTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgdmFyIHRpbGVTaXplID0gbGF5ZXIuZ2VvbWV0cnkoKS5tYXhUaWxlU2l6ZSgpO1xuICB2YXIgbWF4VGV4dHVyZVNpemUgPSB0aGlzLm1heFRleHR1cmVTaXplKCk7XG4gIGlmICh0aWxlU2l6ZSA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMYXllciBoYXMgbGV2ZWwgd2l0aCB0aWxlIHNpemUgbGFyZ2VyIHRoYW4gbWF4aW11bSB0ZXh0dXJlIHNpemUgKCcgKyB0aWxlU2l6ZSArICcgdnMuICcgKyBtYXhUZXh0dXJlU2l6ZSArICcpJyk7XG4gIH1cbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbihSZW5kZXJlciwgb3B0cykge1xuICB2YXIgcmVuZGVyZXJJbnN0YW5jZXMgPSB0aGlzLl9yZW5kZXJlckluc3RhbmNlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW5kZXJlckluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZW5kZXJlckluc3RhbmNlc1tpXSBpbnN0YW5jZW9mIFJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXJJbnN0YW5jZXNbaV07XG4gICAgfVxuICB9XG4gIHZhciByZW5kZXJlciA9IG5ldyBSZW5kZXJlcih0aGlzLl9nbCwge1xuICAgIHdpZHRoU2VnbWVudHM6IHRoaXMuX3dpZHRoU2VnbWVudHMsXG4gICAgaGVpZ2h0U2VnbWVudHM6IHRoaXMuX2hlaWdodFNlZ21lbnRzLFxuICAgIC4uLm9wdHNcbiAgfSk7XG4gIHJlbmRlcmVySW5zdGFuY2VzLnB1c2gocmVuZGVyZXIpO1xuICByZXR1cm4gcmVuZGVyZXI7XG59O1xuXG5cbldlYkdsU3RhZ2UucHJvdG90eXBlLmRlc3Ryb3lSZW5kZXJlciA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gIHZhciByZW5kZXJlckluc3RhbmNlcyA9IHRoaXMuX3JlbmRlcmVySW5zdGFuY2VzO1xuICBpZiAodGhpcy5fcmVuZGVyZXJzLmluZGV4T2YocmVuZGVyZXIpIDwgMCkge1xuICAgIHJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICB2YXIgaW5kZXggPSByZW5kZXJlckluc3RhbmNlcy5pbmRleE9mKHJlbmRlcmVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmVuZGVyZXJJbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbn07XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUuc3RhcnRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnbCA9IHRoaXMuX2dsO1xuXG4gIGlmICghZ2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBXZWJHTCBjb250ZXh0IC0gbWF5YmUgY29udGV4dCB3YXMgbG9zdD8nKTtcbiAgfVxuXG4gIC8vIFNldCB0aGUgV2ViR0wgdmlld3BvcnQuXG4gIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG5cbiAgLy8gQ2xlYXIgZnJhbWVidWZmZXIuXG4gIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXG4gIC8vIEVuYWJsZSBkZXB0aCB0ZXN0aW5nLlxuICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgLy8gRW5hYmxlIGJsZW5kaW5nLiBPTkUgYW5kIE9ORV9NSU5VU19TUkNfQUxQSEEgYXJlIHRoZSByaWdodCBjaG9pY2VzIGZvclxuICAvLyBwcmVtdWx0aXBsaWVkIHRleHR1cmVzLlxuICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxufTtcblxuXG5XZWJHbFN0YWdlLnByb3RvdHlwZS5lbmRGcmFtZSA9IGZ1bmN0aW9uKCkge307XG5cblxuV2ViR2xTdGFnZS5wcm90b3R5cGUudGFrZVNuYXBzaG90ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gIC8vIFZhbGlkYXRlIHBhc3NlZCBhcmd1bWVudFxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBxdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5O1xuXG4gIC8vIFNldCBkZWZhdWx0IHF1YWxpdHkgaWYgaXQgaXMgbm90IHBhc3NlZFxuICBpZiAodHlwZW9mIHF1YWxpdHkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBxdWFsaXR5ID0gNzU7XG4gIH1cblxuICAvLyBUaHJvdyBpZiBxdWFsaXR5IGlzIG9mIGludmxpZCB0eXBlIG9yIG91dCBvZiBib3VuZHNcbiAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAnbnVtYmVyJyB8fCBxdWFsaXR5IDwgMCB8fCBxdWFsaXR5ID4gMTAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTFN0YWdlOiBTbmFwc2hvdCBxdWFsaXR5IG5lZWRzIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMTAwJyk7XG4gIH1cblxuICAvLyBDYW52YXMgbWV0aG9kIFwidG9EYXRhVVJMXCIgbmVlZHMgdG8gYmUgY2FsbGVkIGluIHRoZSBzYW1lXG4gIC8vIGNvbnRleHQgYXMgd2hlcmUgdGhlIGFjdHVhbCByZW5kZXJpbmcgaXMgZG9uZS4gSGVuY2UgdGhpcy5cbiAgdGhpcy5yZW5kZXIoKTtcblxuICAvLyBSZXR1cm4gdGhlIHNuYXBzaG90XG4gIHJldHVybiB0aGlzLl9kb21FbGVtZW50LnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIHF1YWxpdHkgLyAxMDApO1xufVxuXG5cbldlYkdsU3RhZ2UudHlwZSA9IFdlYkdsU3RhZ2UucHJvdG90eXBlLnR5cGUgPSAnd2ViZ2wnO1xuXG5cbmZ1bmN0aW9uIFdlYkdsVGV4dHVyZShzdGFnZSwgdGlsZSwgYXNzZXQpIHtcbiAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcbiAgdGhpcy5fZ2wgPSBzdGFnZS5fZ2w7XG4gIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICB0aGlzLl90aW1lc3RhbXAgPSBudWxsO1xuICB0aGlzLl93aWR0aCA9IHRoaXMuX2hlaWdodCA9IG51bGw7XG4gIHRoaXMucmVmcmVzaCh0aWxlLCBhc3NldCk7XG59XG5cblxuV2ViR2xUZXh0dXJlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24odGlsZSwgYXNzZXQpIHtcblxuICB2YXIgZ2wgPSB0aGlzLl9nbDtcbiAgdmFyIHN0YWdlID0gdGhpcy5fc3RhZ2U7XG4gIHZhciB0ZXh0dXJlO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHRleHR1cmUgbmVlZHMgdG8gYmUgdXBkYXRlZC5cbiAgdmFyIHRpbWVzdGFtcCA9IGFzc2V0LnRpbWVzdGFtcCgpO1xuICBpZiAodGltZXN0YW1wID09PSB0aGlzLl90aW1lc3RhbXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBHZXQgYXNzZXQgZWxlbWVudC5cbiAgdmFyIGVsZW1lbnQgPSBhc3NldC5lbGVtZW50KCk7XG5cbiAgLy8gR2V0IGFzc2V0IGRpbWVuc2lvbnMuXG4gIHZhciB3aWR0aCA9IGFzc2V0LndpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSBhc3NldC5oZWlnaHQoKTtcblxuICBpZiAod2lkdGggIT09IHRoaXMuX3dpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5faGVpZ2h0KSB7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBkaW1lbnNpb25zIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCByZWZyZXNoLCBjcmVhdGVcbiAgICAvLyBhIG5ldyB0ZXh0dXJlIHdpdGggdGhlIGNvcnJlY3Qgc2l6ZS5cblxuICAgIC8vIENoZWNrIGlmIHRleHR1cmUgZGltZW5zaW9ucyB3b3VsZCBleGNlZWQgdGhlIG1heGltdW0gdGV4dHVyZSBzaXplLlxuICAgIHZhciBtYXhTaXplID0gc3RhZ2UubWF4VGV4dHVyZVNpemUoKTtcbiAgICBpZiAod2lkdGggPiBtYXhTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmUgd2lkdGggbGFyZ2VyIHRoYW4gbWF4IHNpemUgKCcgKyB3aWR0aCArICcgdnMuICcgKyBtYXhTaXplICsgJyknKTtcbiAgICB9XG4gICAgaWYgKGhlaWdodCA+IG1heFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZSBoZWlnaHQgbGFyZ2VyIHRoYW4gbWF4IHNpemUgKCcgKyBoZWlnaHQgKyAnIHZzLiAnICsgbWF4U2l6ZSArICcpJyk7XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIHRoZSBjdXJyZW50IHRleHR1cmUgaWYgaXQgZXhpc3RzLlxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBDaHJvbWUgb24gQW5kcm9pZC4gSWYgaXQgaXNuJ3QgZG9uZSB0aGUgdGV4dHVyZXNcbiAgICAvLyBkbyBub3QgcmVuZGVyIHdoZW4gdGhlIHNpemUgY2hhbmdlcy5cbiAgICBpZiAodGhpcy5fdGV4dHVyZSkge1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgdGV4dHVyZSBtdXN0IGJlIHByZW11bHRpcGxpZWQgYnkgYWxwaGEgdG8gZW5zdXJlIGNvcnJlY3QgYmxlbmRpbmcgb2ZcbiAgICAvLyBzZW1pdHJhbnNwYXJlbnQgdGV4dHVyZXMuIEZvciBkZXRhaWxzLCBzZWU6XG4gICAgLy8gaHR0cDovL3d3dy5yZWFsdGltZXJlbmRlcmluZy5jb20vYmxvZy9ncHVzLXByZWZlci1wcmVtdWx0aXBsaWNhdGlvbi9cbiAgICB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZWxlbWVudCk7XG5cbiAgfSBlbHNlIHtcblxuICAgIC8vIElmIHRoZSB0ZXh0dXJlIGRpbWVuc2lvbnMgcmVtYWluIHRoZSBzYW1lLCByZXBhaW50IHRoZSBleGlzdGluZyB0ZXh0dXJlLlxuICAgIC8vIFJlcGFpbnRpbmcgd2l0aCB0ZXhTdWJJbWFnZTJEIGlzIHVzdWFsbHkgZmFzdGVyIHRoYW4gd2l0aCB0ZXhJbWFnZTJELFxuICAgIC8vIGV4Y2VwdCBpbiB0aGUgY2FzZSBub3RlZCBpbiBicm93c2VyUXVpcmtzLlxuXG4gICAgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCAmJiBicm93c2VyUXVpcmtzLnZpZGVvVXNlVGV4SW1hZ2UyRCkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBlbGVtZW50KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB0aGUgY29ycmVzcG9uZGluZyBzdGFnZSBvcHRpb24gaXMgc2V0IGFuZCB0aGUgdGV4dHVyZVxuICAvLyBkaW1lbnNpb25zIGFyZSBwb3dlcnMgb2YgdHdvLlxuICBpZiAoc3RhZ2UuX2dlbmVyYXRlTWlwbWFwcyAmJiBpc3BvdCh3aWR0aCkgJiYgaXNwb3QoaGVpZ2h0KSkge1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XG4gICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gIH0gZWxzZSB7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gIH1cblxuICAvLyBDbGFtcCB0ZXh0dXJlIHRvIGVkZ2VzLlxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgLy8gVW5iaW5kIHRleHR1cmUuXG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXG4gIC8vIFVwZGF0ZSB0ZXh0dXJlIGRpbWVuc2lvbnMgYW5kIHRpbWVzdGFtcC5cbiAgdGhpcy5fdGltZXN0YW1wID0gdGltZXN0YW1wO1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbn07XG5cblxuV2ViR2xUZXh0dXJlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgdGhpcy5fZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLl90ZXh0dXJlKTtcbiAgfVxuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbldlYkdsU3RhZ2UuVGV4dHVyZUNsYXNzID0gV2ViR2xTdGFnZS5wcm90b3R5cGUuVGV4dHVyZUNsYXNzID0gV2ViR2xUZXh0dXJlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR2xTdGFnZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gVHJhbnNmb3JtIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBhbiBhc3luY2hyb25vdXMgb25lLlxuZnVuY3Rpb24gYXN5bmMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFzeW5jZWQoZG9uZSkge1xuICAgIHZhciBlcnIsIHJldDtcbiAgICB0cnkge1xuICAgICAgcmV0ID0gZm4oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRvbmUoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUobnVsbCwgcmV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgUmVjdFNwZWN9IGludG8gYW4gZXF1aXZhbGVudCB7QGxpbmsgUmVjdH0uXG4gKlxuICogQSB7QGxpbmsgUmVjdFNwZWN9IGlzIGEgY29udmVuaWVudCB1c2VyIEFQSSBmb3JtYXQsIHByb3ZpZGluZyBkZWZhdWx0IHZhbHVlc1xuICogYW5kIHRoZSBmbGV4aWJpbGl0eSBvZiBzcGVjaWZ5aW5nIGFic29sdXRlLCByZWxhdGl2ZSBvciBtaXhlZCBkaW1lbnNpb25zLlxuICpcbiAqIEEge0BsaW5rIFJlY3R9IGlzIGEgbW9yZSBjb252ZW5pZW50IGZvcm1hdCBmb3IgdGhlIHJlbmRlcmluZyBwaXBlbGluZS4gSXQgaXNcbiAqIGFsd2F5cyBleHByZXNzZWQgaW4gbm9ybWFsaXplZCBjb29yZGluYXRlcywgYW5kIGFsbCBpdHMgcHJvcGVydGllcyBhcmVcbiAqIGd1YXJhbnRlZWQgdG8gYmUgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxXaWR0aCBUaGUgdG90YWwgd2lkdGggb2YgdGhlIHJlbmRlcmluZyBhcmVhIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbEhlaWdodCBUaGUgdG90YWwgaGVpZ2h0IG9mIHRoZSByZW5kZXJpbmcgYXJlYSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge1JlY3RTcGVjfSBzcGVjIFRoZSBpbnB1dCBzcGVjLCBkZWZhdWx0aW5nIHRvIHRoZSBmdWxsIHJlbmRlcmluZyBhcmVhXG4gKiAgICAgaWYgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge1JlY3R9IHJlc3VsdCBUaGUgb3V0cHV0IHNwZWMuIElmIHRoZSBhcmd1bWVudCBpcyBwcmVzZW50LCBpdCBpc1xuICogICAgIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQ7IG90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGNhbGNSZWN0KHRvdGFsV2lkdGgsIHRvdGFsSGVpZ2h0LCBzcGVjLCByZXN1bHQpIHtcblxuICByZXN1bHQgPSByZXN1bHQgfHwge307XG5cbiAgdmFyIHdpZHRoO1xuICBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMuYWJzb2x1dGVXaWR0aCAhPSBudWxsKSB7XG4gICAgd2lkdGggPSBzcGVjLmFic29sdXRlV2lkdGggLyB0b3RhbFdpZHRoO1xuICB9IGVsc2UgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLnJlbGF0aXZlV2lkdGggIT0gbnVsbCkge1xuICAgIHdpZHRoID0gc3BlYy5yZWxhdGl2ZVdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gMTtcbiAgfVxuXG4gIHZhciBoZWlnaHQ7XG4gIGlmIChzcGVjICYmIHNwZWMuYWJzb2x1dGVIZWlnaHQgIT0gbnVsbCkge1xuICAgIGhlaWdodCA9IHNwZWMuYWJzb2x1dGVIZWlnaHQgLyB0b3RhbEhlaWdodDtcbiAgfSBlbHNlIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5yZWxhdGl2ZUhlaWdodCAhPSBudWxsKSB7XG4gICAgaGVpZ2h0ID0gc3BlYy5yZWxhdGl2ZUhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBoZWlnaHQgPSAxO1xuICB9XG5cbiAgdmFyIHg7XG4gIGlmIChzcGVjICE9IG51bGwgJiYgc3BlYy5hYnNvbHV0ZVggIT0gbnVsbCkge1xuICAgIHggPSBzcGVjLmFic29sdXRlWCAvIHRvdGFsV2lkdGg7XG4gIH0gZWxzZSBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMucmVsYXRpdmVYICE9IG51bGwpIHtcbiAgICB4ID0gc3BlYy5yZWxhdGl2ZVg7XG4gIH0gZWxzZSB7XG4gICAgeCA9IDA7XG4gIH1cblxuICB2YXIgeTtcbiAgaWYgKHNwZWMgIT0gbnVsbCAmJiBzcGVjLmFic29sdXRlWSAhPSBudWxsKSB7XG4gICAgeSA9IHNwZWMuYWJzb2x1dGVZIC8gdG90YWxIZWlnaHQ7XG4gIH0gZWxzZSBpZiAoc3BlYyAhPSBudWxsICYmIHNwZWMucmVsYXRpdmVZICE9IG51bGwpIHtcbiAgICB5ID0gc3BlYy5yZWxhdGl2ZVk7XG4gIH0gZWxzZSB7XG4gICAgeSA9IDA7XG4gIH1cblxuICByZXN1bHQueCA9IHg7XG4gIHJlc3VsdC55ID0geTtcbiAgcmVzdWx0LndpZHRoID0gd2lkdGg7XG4gIHJlc3VsdC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWxjUmVjdDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG9uY2UgPSByZXF1aXJlKCcuL29uY2UnKTtcblxuLy8gQSBjYW5jZWxhYmxlIGZ1bmN0aW9uIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiAoaS5lLiwgb25lIHdob3NlIGxhc3Rcbi8vIGFyZ3VtZW50IGlzIGEgY2FsbGJhY2sgcmVjZWl2aW5nIGFuIGVycm9yIHBsdXMgemVybyBvciBtb3JlIHJldHVybiB2YWx1ZXMpXG4vLyB0aGF0IChzeW5jaHJvbm91c2x5KSByZXR1cm5zIGEgY2FuY2VsKCkgZnVuY3Rpb24uIENhbGxpbmcgY2FuY2VsKCkgc2hvdWxkXG4vLyBhYm9ydCB0aGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbiBhbmQgY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgYXJndW1lbnRzXG4vLyB0aGF0IHdlcmUgcGFzc2VkIGludG8gY2FuY2VsKCkuIENhbGxpbmcgY2FuY2VsKCkgdHdpY2UsIGFzIHdpdGggY2FsbGJhY2tzLFxuLy8gaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgc2FmZS5cblxuLy8gV3JhcCBhIG5vbi1jYW5jZWxsYWJsZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBhIGNhbmNlbGFibGUgb25lLlxuLy9cbi8vIENhbGxpbmcgY2FuY2VsKCkgb24gdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgbm90IGludGVycnVwdCB0aGUgZXhlY3V0aW9uXG4vLyBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb247IGl0IHdpbGwgbWVyZWx5IGlnbm9yZSBpdHMgcmV0dXJuIHZhbHVlLlxuLy9cbi8vIFVzdWFsbHksIGluc3RlYWQgb2Ygd3JhcHBpbmcgeW91ciBmdW5jdGlvbiwgeW91IHdhbnQgdG8gaW1wbGVtZW50IGNhbmNlbCgpXG4vLyB5b3Vyc2VsZiBpbiBvcmRlciB0byBoYXZlIHNvbWUgYWJvcnQgbG9naWMuIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBwcm92aWRlcyBhXG4vLyBzdHJhaWdoZm9yd2FyZCBzb2x1dGlvbiBmb3IgY2FzZXMgaW4gd2hpY2ggbm8gY3VzdG9tIGFib3J0IGxvZ2ljIGlzIHJlcXVpcmVkLlxuZnVuY3Rpb24gY2FuY2VsaXplKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjYW5jZWxpemVkKCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5jZWxpemVkOiBleHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIHZhciBkb25lID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gb25jZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pO1xuXG4gICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIGNhbmNlbDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW5jZWxpemU7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBub29wID0gcmVxdWlyZSgnLi9ub29wJyk7XG5cbi8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgaXRzIGFyZ3VtZW50cyAod2hpY2ggc2hvdWxkIGJlIGNhbmNlbGFibGVzKVxuLy8gaW4gc2VxdWVuY2UsIHNvIHRoYXQgZWFjaCBvZiB0aGVtIHBhc3NlcyBpdHMgcmV0dXJuIHZhbHVlcyB0byB0aGUgbmV4dC5cbi8vIEV4ZWN1dGlvbiBpcyBhYm9ydGVkIGlmIG9uZSBvZiB0aGUgZnVuY3Rpb25zIHJldHVybnMgYW4gZXJyb3I7IGluIHRoYXQgY2FzZVxuLy8gdGhlIGxhc3QgZnVuY3Rpb24gaW4gdGhlIHNlcXVlbmNlIGlzIGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbi8vIFNlZSB1dGlsL2NhbmNlbGl6ZS5qcyBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2hhdCBjYW5jZWxhYmxlcyBhcmUuXG5mdW5jdGlvbiBjaGFpbigpIHtcblxuICAvLyBUaGUgbGlzdCBvZiBmdW5jdGlvbnMgdG8gY2hhaW4gdG9nZXRoZXIuXG4gIHZhciBhcmdMaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZCgpIHtcblxuICAgIC8vIExpc3Qgb2YgcmVtYWluaW5nIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZC5cbiAgICAvLyBNYWtlIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgbGlzdCBzbyB3ZSBjYW4gbXV0YXRlIHRoZSBmb3JtZXIgd2hpbGVcbiAgICAvLyBwcmVzZXJ2aW5nIHRoZSBsYXR0ZXIgaW50YWN0IGZvciBmdXR1cmUgaW52b2NhdGlvbnMgb2YgdGhlIGNoYWluLlxuICAgIHZhciBmbkxpc3QgPSBhcmdMaXN0LnNsaWNlKDApO1xuXG4gICAgLy8gQ3VycmVudGx5IGV4ZWN1dGluZyBmdW5jdGlvbi5cbiAgICB2YXIgZm4gPSBudWxsO1xuXG4gICAgLy8gQ2FuY2VsIG1ldGhvZCBmb3IgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgZnVuY3Rpb24uXG4gICAgdmFyIGNmbiA9IG51bGw7XG5cbiAgICAvLyBBcmd1bWVudHMgZm9yIHRoZSBmaXJzdCBmdW5jdGlvbi5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKSA6IFtdO1xuXG4gICAgLy8gQ2FsbGJhY2sgZm9yIHRoZSBjaGFpbi5cbiAgICB2YXIgZG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdIDogbm9vcDtcblxuICAgIC8vIEV4ZWN1dGUgdGhlIG5leHQgZnVuY3Rpb24gaW4gdGhlIGNoYWluLlxuICAgIC8vIFJlY2VpdmVzIHRoZSBlcnJvciBhbmQgcmV0dXJuIHZhbHVlcyBmcm9tIHRoZSBwcmV2aW91cyBmdW5jdGlvbi5cbiAgICBmdW5jdGlvbiBleGVjKCkge1xuXG4gICAgICAvLyBFeHRyYWN0IGVycm9yIGZyb20gYXJndW1lbnRzLlxuICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgLy8gQWJvcnQgY2hhaW4gb24gZXJyb3IuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGZuID0gY2ZuID0gbnVsbDtcbiAgICAgICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRlcm1pbmF0ZSBpZiB0aGVyZSBhcmUgbm8gZnVuY3Rpb25zIGxlZnQgaW4gdGhlIGNoYWluLlxuICAgICAgaWYgKCFmbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGZuID0gY2ZuID0gbnVsbDtcbiAgICAgICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgZnVuY3Rpb24gaW4gdGhlIGNoYWluLlxuICAgICAgZm4gPSBmbkxpc3Quc2hpZnQoKTtcbiAgICAgIHZhciBfZm4gPSBmbjtcblxuICAgICAgLy8gRXh0cmFjdCBhcmd1bWVudHMgdG8gcGFzcyBpbnRvIHRoZSBuZXh0IGZ1bmN0aW9uLlxuICAgICAgdmFyIHJldCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIC8vIENhbGwgbmV4dCBmdW5jdGlvbiB3aXRoIHByZXZpb3VzIHJldHVybiB2YWx1ZSBhbmQgY2FsbCBiYWNrIGV4ZWMuXG4gICAgICByZXQucHVzaChleGVjKTtcbiAgICAgIHZhciBfY2ZuID0gZm4uYXBwbHkobnVsbCwgcmV0KTsgLy8gZm4obnVsbCwgcmV0Li4uLCBleGVjKVxuXG4gICAgICAvLyBEZXRlY3Qgd2hlbiBmbiBoYXMgY29tcGxldGVkIHN5bmNocm9ub3VzbHkgYW5kIGRvIG5vdCBjbG9iYmVyIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgc3RhdGUgaW4gdGhhdCBjYXNlLiBZb3UncmUgbm90IGV4cGVjdGVkIHRvIHVuZGVyc3RhbmQgdGhpcy5cbiAgICAgIGlmIChfZm4gIT09IGZuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGNhbmNlbCBtZXRob2QgZm9yIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIGZ1bmN0aW9uLlxuICAgICAgLy8gRGV0ZWN0IGNoYWluaW5nIG9uIG5vbi1jYW5jZWxsYWJsZSBmdW5jdGlvbi5cbiAgICAgIGlmICh0eXBlb2YgX2NmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYWluOiBjaGFpbmluZyBvbiBub24tY2FuY2VsbGFibGUgZnVuY3Rpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNmbiA9IF9jZm47XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBDYW5jZWwgY2hhaW4gZXhlY3V0aW9uLlxuICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGlmIChjZm4pIHtcbiAgICAgICAgY2ZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgY2hhaW4gZXhlY3V0aW9uLlxuICAgIC8vIFdlIGNhbGwgZXhlYyBhcyBpZiBsaW5raW5nIGZyb20gYSBwcmV2aW91cyBmdW5jdGlvbiBpbiB0aGUgY2hhaW4sXG4gICAgLy8gZXhjZXB0IHRoYXQgdGhlIGVycm9yIGlzIGFsd2F5cyBudWxsLiBBcyBhIGNvbnNlcXVlbmNlLCBjaGFpbmluZyBvbiBhblxuICAgIC8vIGVtcHR5IGxpc3QgeWllbGRzIHRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgZXhlYy5hcHBseShudWxsLCBhcmdzKTsgLy8gZXhlYyhudWxsLCBhcmdzLi4uKVxuXG4gICAgcmV0dXJuIGNhbmNlbDtcblxuICB9O1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhaW47XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhbXA7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZXRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIHRvIHVuZGVmaW5lZC4gVGhpcyBtYXkgYmUgY2FsbGVkIGJ5XG4vLyBkZXN0cnVjdG9ycyB0byBhdm9pZCByZXRhaW5pbmcgcmVmZXJlbmNlcyBhbmQgaGVscCBkZXRlY3QgaW5jb3JyZWN0IHVzZSBvZlxuLy8gZGVzdHJveWVkIGluc3RhbmNlcy5cbmZ1bmN0aW9uIGNsZWFyT3duUHJvcGVydGllcyhvYmopIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBvYmpbcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xlYXJPd25Qcm9wZXJ0aWVzO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjbXAoeCwgeSkge1xuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHggPiB5KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY21wOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gICogQ29tcG9zZSBtdWx0aXBsZSBmdW5jdGlvbnNcbiAgKlxuICAqIGBjb21wb3NlKGYsIGcpYCByZXR1cm5zIGBmdW5jdGlvbih4KSB7IHJldHVybiBmKGcoeCkpOyB9YFxuICAqXG4gICogQG1lbWJlcm9mIHV0aWxcbiAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IGZ1bmN0aW9ucyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKi9cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIHZhciBmbkxpc3QgPSBhcmd1bWVudHM7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wb3NlZChpbml0aWFsQXJnKSB7XG4gICAgdmFyIHJldCA9IGluaXRpYWxBcmc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbiA9IGZuTGlzdFtpXTtcbiAgICAgIHJldCA9IGZuLmNhbGwobnVsbCwgcmV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb3NlOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb252ZXJ0IGZvdlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBjb252ZXJ0IGZyb20gaGZvdiB0byB2Zm92IG9uZSB3b3VsZCBjYWxsIFxuICogYGNvbnZlcnQoaGZvdiwgd2lkdGgsIGhlaWdodClgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiBjb252ZXJ0KGZvdiwgZnJvbURpbWVuc2lvbiwgdG9EaW1lbnNpb24pIHtcbiAgcmV0dXJuIDIgKiBNYXRoLmF0YW4odG9EaW1lbnNpb24gKiBNYXRoLnRhbihmb3YgLyAyKSAvIGZyb21EaW1lbnNpb24pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gaHRvdihmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCB3aWR0aCwgaGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbURpbWVuc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IHRvRGltZW5zaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAbWVtYmVyb2YgdXRpbC5jb252ZXJ0Rm92XG4gKi9cbmZ1bmN0aW9uIGh0b2QoZm92LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBjb252ZXJ0KGZvdiwgd2lkdGgsIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiB2dG9oKGZvdiwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gY29udmVydChmb3YsIGhlaWdodCwgd2lkdGgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gdnRvZChmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCBoZWlnaHQsIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21EaW1lbnNpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0RpbWVuc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICogQG1lbWJlcm9mIHV0aWwuY29udmVydEZvdlxuICovXG5mdW5jdGlvbiBkdG9oKGZvdiwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gY29udmVydChmb3YsIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSwgd2lkdGgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3ZcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tRGltZW5zaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdG9EaW1lbnNpb25cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBtZW1iZXJvZiB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xuZnVuY3Rpb24gZHRvdihmb3YsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIGNvbnZlcnQoZm92LCBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCksIGhlaWdodCk7XG59XG5cbi8qKlxuICogQG5hbWVzcGFjZSB1dGlsLmNvbnZlcnRGb3ZcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnZlcnQ6IGNvbnZlcnQsXG4gIGh0b3Y6IGh0b3YsXG4gIGh0b2Q6IGh0b2QsXG4gIHZ0b2g6IHZ0b2gsXG4gIHZ0b2Q6IHZ0b2QsXG4gIGR0b2g6IGR0b2gsXG4gIGR0b3Y6IGR0b3Zcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIENvbnZlcnQgYSBudW1iZXIgdG8gYSBzdHJpbmcgaW4gZGVjaW1hbCBub3RhdGlvbi5cbmZ1bmN0aW9uIGRlY2ltYWwoeCkge1xuICAvLyBEb3VibGUtcHJlY2lzaW9uIGZsb2F0cyBoYXZlIDE1IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXRzLlxuICByZXR1cm4geC50b1ByZWNpc2lvbigxNSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjaW1hbDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRzKG9iaiwgZGVmYXVsdHNPYmopIHtcbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzT2JqKSB7XG4gICAgaWYgKCEoa2V5IGluIG9iaikpIHtcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdHNPYmpba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0czsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRlZmVyKGZuLCBhcmdzKSB7XG4gIGZ1bmN0aW9uIGRlZmVycmVkKCkge1xuICAgIGlmIChhcmdzICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG4gIHNldFRpbWVvdXQoZGVmZXJyZWQsIDApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmVyOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWdUb1JhZChkZWcpIHtcbiAgcmV0dXJuIGRlZyAqIE1hdGguUEkgLyAxODA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVnVG9SYWQ7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQZXJmb3JtIGEgY2FuY2VsYWJsZSBkZWxheS5cbi8vIFNlZSB1dGlsL2NhbmNlbGl6ZS5qcyBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2hhdCBjYW5jZWxhYmxlcyBhcmUuXG5mdW5jdGlvbiBkZWxheShtcywgZG9uZSkge1xuXG4gIC8vIFdvcmsgYXJvdW5kIElFOCBidWcgd2hlcmVieSBhIHNldFRpbWVvdXQgY2FsbGJhY2sgbWF5IHN0aWxsIGJlIGNhbGxlZFxuICAvLyBhZnRlciB0aGUgY29ycmVzcG9uZGluZyBjbGVhclRpbWVvdXQgaXMgaW52b2tlZC5cbiAgdmFyIHRpbWVyID0gbnVsbDtcblxuICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgaWYgKHRpbWVyICE9IG51bGwpIHtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgIGRvbmUobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lciAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHRpbWVyID0gc2V0VGltZW91dChmaW5pc2gsIG1zKTtcblxuICByZXR1cm4gY2FuY2VsO1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVsYXk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gcHJlZml4UHJvcGVydHkocHJvcGVydHkpIHtcblxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG4gIHZhciBwcmVmaXhMaXN0ID0gWydNb3onLCAnV2Via2l0JywgJ0todG1sJywgJ08nLCAnbXMnXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4TGlzdFtpXTtcbiAgICB2YXIgY2FwaXRhbGl6ZWRQcm9wZXJ0eSA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcbiAgICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IHByZWZpeCArIGNhcGl0YWxpemVkUHJvcGVydHk7XG5cbiAgICBpZiAocHJlZml4ZWRQcm9wZXJ0eSBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkUHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BlcnR5O1xuXG59XG5cblxuZnVuY3Rpb24gZ2V0V2l0aFZlbmRvclByZWZpeChwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IHByZWZpeFByb3BlcnR5KHByb3BlcnR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3BlcnR5V2l0aFZlbmRvclByZWZpeChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbcHJlZml4ZWRQcm9wZXJ0eV07XG4gIH07XG5cbn1cblxuXG5mdW5jdGlvbiBzZXRXaXRoVmVuZG9yUHJlZml4KHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gcHJlZml4UHJvcGVydHkocHJvcGVydHkpO1xuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvcGVydHlXaXRoVmVuZG9yUHJlZml4KGVsZW1lbnQsIHZhbCkge1xuICAgIHJldHVybiAoZWxlbWVudC5zdHlsZVtwcmVmaXhlZFByb3BlcnR5XSA9IHZhbCk7XG4gIH07XG59XG5cblxudmFyIHNldFRyYW5zZm9ybSA9IHNldFdpdGhWZW5kb3JQcmVmaXgoJ3RyYW5zZm9ybScpO1xudmFyIHNldFRyYW5zZm9ybU9yaWdpbiA9IHNldFdpdGhWZW5kb3JQcmVmaXgoJ3RyYW5zZm9ybU9yaWdpbicpO1xuXG5cbmZ1bmN0aW9uIHNldE51bGxUcmFuc2Zvcm0oZWxlbWVudCkge1xuICBzZXRUcmFuc2Zvcm0oZWxlbWVudCwgJ3RyYW5zbGF0ZVooMCknKTtcbn1cblxuXG5mdW5jdGlvbiBzZXROdWxsVHJhbnNmb3JtT3JpZ2luKGVsZW1lbnQpIHtcbiAgc2V0VHJhbnNmb3JtT3JpZ2luKGVsZW1lbnQsICcwIDAgMCcpO1xufVxuXG5cbmZ1bmN0aW9uIHNldEFic29sdXRlKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG59XG5cblxuZnVuY3Rpb24gc2V0UGl4ZWxQb3NpdGlvbihlbGVtZW50LCB4LCB5KSB7XG4gIGVsZW1lbnQuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICBlbGVtZW50LnN0eWxlLnRvcCA9IHkgKyAncHgnO1xufVxuXG5cbmZ1bmN0aW9uIHNldFBpeGVsU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcbn1cblxuXG5mdW5jdGlvbiBzZXROdWxsU2l6ZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSBlbGVtZW50LnN0eWxlLmhlaWdodCA9IDA7XG59XG5cblxuZnVuY3Rpb24gc2V0RnVsbFNpemUoZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLndpZHRoID0gZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG59XG5cblxuZnVuY3Rpb24gc2V0T3ZlcmZsb3dIaWRkZW4oZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG59XG5cblxuZnVuY3Rpb24gc2V0T3ZlcmZsb3dWaXNpYmxlKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJztcbn1cblxuXG5mdW5jdGlvbiBzZXROb1BvaW50ZXJFdmVudHMoZWxlbWVudCkge1xuICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByZWZpeFByb3BlcnR5OiBwcmVmaXhQcm9wZXJ0eSxcbiAgZ2V0V2l0aFZlbmRvclByZWZpeDogZ2V0V2l0aFZlbmRvclByZWZpeCxcbiAgc2V0V2l0aFZlbmRvclByZWZpeDogc2V0V2l0aFZlbmRvclByZWZpeCxcbiAgc2V0VHJhbnNmb3JtOiBzZXRUcmFuc2Zvcm0sXG4gIHNldFRyYW5zZm9ybU9yaWdpbjogc2V0VHJhbnNmb3JtT3JpZ2luLFxuICBzZXROdWxsVHJhbnNmb3JtOiBzZXROdWxsVHJhbnNmb3JtLFxuICBzZXROdWxsVHJhbnNmb3JtT3JpZ2luOiBzZXROdWxsVHJhbnNmb3JtT3JpZ2luLFxuICBzZXRBYnNvbHV0ZTogc2V0QWJzb2x1dGUsXG4gIHNldFBpeGVsUG9zaXRpb246IHNldFBpeGVsUG9zaXRpb24sXG4gIHNldFBpeGVsU2l6ZTogc2V0UGl4ZWxTaXplLFxuICBzZXROdWxsU2l6ZTogc2V0TnVsbFNpemUsXG4gIHNldEZ1bGxTaXplOiBzZXRGdWxsU2l6ZSxcbiAgc2V0T3ZlcmZsb3dIaWRkZW46IHNldE92ZXJmbG93SGlkZGVuLFxuICBzZXRPdmVyZmxvd1Zpc2libGU6IHNldE92ZXJmbG93VmlzaWJsZSxcbiAgc2V0Tm9Qb2ludGVyRXZlbnRzOiBzZXROb1BvaW50ZXJFdmVudHNcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmosIHNvdXJjZU9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlT2JqKSB7XG4gICAgb2JqW2tleV0gPSBzb3VyY2VPYmpba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBnbG9iYWwgb2JqZWN0LlxudmFyIGdsb2JhbE9iamVjdCA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsT2JqZWN0O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBKZW5raW5zIG9uZS1hdC1hLXRpbWUgaGFzaFxuLy8gaHR0cDovL3d3dy5idXJ0bGVidXJ0bGUubmV0L2JvYi9oYXNoL2Rvb2JzLmh0bWxcbi8vIElucHV0OiBhbiBhcnJheSBvZiBpbnRlZ2Vyc1xuLy8gT3V0cHV0OiBhbiBpbnRlZ2VyXG5cbmZ1bmN0aW9uIGhhc2goKSB7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgayA9IGFyZ3VtZW50c1tpXTtcbiAgICBoICs9IGs7XG4gICAgaCArPSBrIDw8IDEwO1xuICAgIGggXj0gayA+PiA2O1xuICB9XG4gIGggKz0gaCA8PCAzO1xuICBoIF49IGggPj4gMTE7XG4gIGggKz0gaCA8PCAxNTtcbiAgcmV0dXJuIGggPj0gMCA/IGggOiAtaDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gTWFrZSBjdG9yIGEgc3ViY2xhc3Mgb2Ygc3VwZXJDdG9yLlxuLy8gRG8gbm90IGRlcGVuZCBvbiBFUzUgT2JqZWN0LmNyZWF0ZSBzZW1hbnRpY3MgYmVjYXVzZSBvZiBvbGRlciBicm93c2Vycy5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24oKSB7fTtcbiAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaGVyaXRzOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gUmV0dXJucyB3aGV0aGVyIG4gaXMgYSBwb3dlciBvZiB0d28uXG5mdW5jdGlvbiBpc3BvdChuKSB7XG4gIHJldHVybiAobiAmIChuIC0gMSkpID09IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNwb3Q7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsbyBvcGVyYXRpb25cbiAqXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpdmlkZW5kXG4gKiBAcGFyYW0ge051bWJlcn0gZGl2aXNvclxuICogQHJldHVybnMge051bWJlcn0gVmFsdWUgaW4gcmFuZ2UgYFswLGRpdmlzb3JbYFxuICovXG5mdW5jdGlvbiBtb2QoYSwgYikge1xuICByZXR1cm4gKCthICUgKGIgPSArYikgKyBiKSAlIGI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW9kOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldE5vdygpIHtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGRhdGVOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm93KCk7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgdmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlZCgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIHZhbHVlID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9uY2U7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdFBpeGVsUmF0aW8gPSAxO1xuXG5mdW5jdGlvbiBwaXhlbFJhdGlvKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2NyZWVuID0gd2luZG93LnNjcmVlbjtcbiAgICAgIGlmIChzY3JlZW4gJiYgc2NyZWVuLmRldmljZVhEUEkgJiYgc2NyZWVuLmxvZ2ljYWxYRFBJKSB7XG4gICAgICAgIHJldHVybiBzY3JlZW4uZGV2aWNlWERQSSAvIHNjcmVlbi5sb2dpY2FsWERQSTtcbiAgICAgIH0gZWxzZSBpZiAoc2NyZWVuICYmIHNjcmVlbi5zeXN0ZW1YRFBJICYmIHNjcmVlbi5sb2dpY2FsWERQSSkge1xuICAgICAgICByZXR1cm4gc2NyZWVuLnN5c3RlbVhEUEkgLyBzY3JlZW4ubG9naWNhbFhEUEk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0UGl4ZWxSYXRpbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXhlbFJhdGlvO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi9kb20nKS5zZXRUcmFuc2Zvcm07XG52YXIgZGVjaW1hbCA9IHJlcXVpcmUoJy4vZGVjaW1hbCcpO1xuXG5mdW5jdGlvbiBwb3NpdGlvbkFic29sdXRlbHkoZWxlbWVudCwgeCwgeSwgZXh0cmFUcmFuc2Zvcm1zKSB7XG4gIGV4dHJhVHJhbnNmb3JtcyA9IGV4dHJhVHJhbnNmb3JtcyB8fCAnJztcbiAgLy8gQSB0cmFuc2xhdGVaKDApIHRyYW5zZm9ybSBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBDaHJvbWUgYnkgY3JlYXRpbmcgYVxuICAvLyBuZXcgbGF5ZXIgZm9yIHRoZSBlbGVtZW50LCB3aGljaCBwcmV2ZW50cyB1bm5lY2Vzc2FyeSByZXBhaW50cy5cbiAgdmFyIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcgKyBkZWNpbWFsKHgpICsgJ3B4KSB0cmFuc2xhdGVZKCcgKyBkZWNpbWFsKHkpICsgJ3B4KSB0cmFuc2xhdGVaKDApICcgKyBleHRyYVRyYW5zZm9ybXM7XG4gIHNldFRyYW5zZm9ybShlbGVtZW50LCB0cmFuc2Zvcm0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc2l0aW9uQWJzb2x1dGVseTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiByYWRUb0RlZyhyYWQpIHtcbiAgcmV0dXJuIHJhZCAqIDE4MCAvIE1hdGguUEk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmFkVG9EZWc7IiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZWFsKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFsOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vb3AgPSByZXF1aXJlKCcuL25vb3AnKTtcblxuLy8gUmV0dXJuIGEgY2FuY2VsYWJsZSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGZuIGluIGEgbG9vcCB1bnRpbCBpdCByZXR1cm5zXG4vLyBzdWNjZXNzZnVsbHkuXG5mdW5jdGlvbiByZXRyeShmbikge1xuXG4gIHJldHVybiBmdW5jdGlvbiByZXRyaWVkKCkge1xuXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBhcmd1bWVudHMubGVuZ3RoIC0gMSkgOiBbXTtcbiAgICB2YXIgZG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdIDogbm9vcDtcblxuICAgIHZhciBjZm4gPSBudWxsO1xuICAgIHZhciBjYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoIWVyciB8fCBjYW5jZWxlZCkge1xuICAgICAgICBkb25lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZm4gPSBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhcmdzLnB1c2goZXhlYyk7XG4gICAgZXhlYyh0cnVlKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICBjZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gIH07XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXRyeTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vdyA9IHJlcXVpcmUoJy4vbm93Jyk7XG5cbmZ1bmN0aW9uIHR3ZWVuKGR1cmF0aW9uLCB1cGRhdGUsIGRvbmUpIHtcbiAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcblxuICBmdW5jdGlvbiBydW5VcGRhdGUoKSB7XG4gICAgaWYoY2FuY2VsbGVkKSB7IHJldHVybjsgfVxuICAgIHZhciB0d2VlblZhbCA9IChub3coKSAtIHN0YXJ0VGltZSkvZHVyYXRpb247XG4gICAgaWYodHdlZW5WYWwgPCAxKSB7XG4gICAgICB1cGRhdGUodHdlZW5WYWwpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1blVwZGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXBkYXRlKDEpO1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSgwKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1blVwZGF0ZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIGRvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHR3ZWVuOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gdHlwZSh4KSB7XG4gIHZhciB0eXAgPSB0eXBlb2YgeDtcbiAgaWYgKHR5cCA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiB0eXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ21pbmltYWwtZXZlbnQtZW1pdHRlcicpO1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xudmFyIHZlYzQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWM0O1xudmFyIHBpeGVsUmF0aW8gPSByZXF1aXJlKCcuLi91dGlsL3BpeGVsUmF0aW8nKTtcbnZhciByZWFsID0gcmVxdWlyZSgnLi4vdXRpbC9yZWFsJyk7XG52YXIgY2xhbXAgPSByZXF1aXJlKCcuLi91dGlsL2NsYW1wJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLy8gRGVmYXVsdCB2aWV3cG9ydCBkaW1lbnNpb25zLlxuLy8gU3RhcnQgd2l0aCB6ZXJvIHRvIGVuc3VyZSB0aGF0IHRob3NlIHZhbHVlcyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG52YXIgZGVmYXVsdFdpZHRoID0gMDtcbnZhciBkZWZhdWx0SGVpZ2h0ID0gMDtcblxuLy8gRGVmYXVsdCB2aWV3IHBhcmFtZXRlcnMuXG52YXIgZGVmYXVsdFggPSAwLjU7XG52YXIgZGVmYXVsdFkgPSAwLjU7XG52YXIgZGVmYXVsdFpvb20gPSAxO1xuXG4vLyBDb25zdGFudCB2YWx1ZXMgdXNlZCB0byBzaW1wbGlmeSB0aGUgZnJ1c3R1bSBjdWxsaW5nIGxvZ2ljLlxuLy8gcGxhbmVBeGVzW2ldIGluZGljYXRlcyB0aGUgY29vcmRpbmF0ZSB2YWx1ZSB0aGF0IGRlZmluZXMgYSBmcnVzdHVtIHBsYW5lLlxuLy8gcGxhbmVDbXBbaV0gaW5kaWNhdGVzIGhvdyBwb2ludCBhbmQgcGxhbmUgY29vcmRpbmF0ZXMgc2hvdWxkIGJlIGNvbXBhcmVkXG4vLyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgcG9pbnQgaXMgb24gdGhlIG91dGVyIHNpZGUgb2YgdGhlIHBsYW5lLlxudmFyIHBsYW5lQXhlcyA9IFtcbiAgMSwgLy8gdG9wXG4gIDAsIC8vIHJpZ2h0XG4gIDEsIC8vIGJvdHRvbVxuICAwICAvLyBsZWZ0XG5dO1xudmFyIHBsYW5lQ21wID0gW1xuICAtMSwgLy8gdG9wXG4gIC0xLCAvLyByaWdodFxuICAgMSwgLy8gYm90dG9tXG4gICAxICAvLyBsZWZ0XG5dO1xuXG4vLyBBIHpvb20gb2YgZXhhY3RseSAwIGJyZWFrcyBzb21lIGNvbXB1dGF0aW9ucywgc28gd2UgZm9yY2UgYSBtaW5pbXVtIHBvc2l0aXZlXG4vLyB2YWx1ZS4gV2UgdXNlIDYgZGVjaW1hbCBwbGFjZXMgZm9yIHRoZSBlcHNpbG9uIHZhbHVlIHRvIGF2b2lkIGJyb2tlblxuLy8gcmVuZGVyaW5nIGR1ZSB0byBsb3NzIG9mIHByZWNpc2lvbiBpbiBmbG9hdGluZyBwb2ludCBjb21wdXRhdGlvbnMuXG52YXIgem9vbUxpbWl0RXBzaWxvbiA9IDAuMDAwMDAxO1xuXG5cbi8qKlxuICogQGludGVyZmFjZSBGbGF0Vmlld1BhcmFtc1xuICpcbiAqIEEgY2FtZXJhIGNvbmZpZ3VyYXRpb24gZm9yIGEge0BsaW5rIEZsYXRWaWV3fS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoZSBpbWFnZSBwb2ludCBkaXNwbGF5ZWRcbiAqICAgICBhdCB0aGUgdmlld3BvcnQgY2VudGVyLCBpbiB0aGUgWzAsIDFdIHJhbmdlLlxuICogICAgIFdoZW4gYHggPT09IDAuNWAsIHRoZSBpbWFnZSBpcyBjZW50ZXJlZCBob3Jpem9udGFsbHkuXG4gKiAgICAgV2hlbiBgeCA9PT0gMGAsIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGltYWdlIGlzIGF0IHRoZSB2aWV3cG9ydCBjZW50ZXIuXG4gKiAgICAgV2hlbiBgeCA9PT0gMWAsIHRoZSByaWdodCBlZGdlIG9mIHRoZSBpbWFnZSBpcyBhdCB0aGUgdmlld3BvcnQgY2VudGVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIGltYWdlIHBvaW50IGRpc3BsYXllZCBhdFxuICogICAgIHRoZSB2aWV3cG9ydCBjZW50ZXIsIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gKiAgICAgV2hlbiBgeSA9PT0gMC41YCwgdGhlIGltYWdlIGlzIGNlbnRlcmVkIHZlcnRpY2FsbHkuXG4gKiAgICAgV2hlbiBgeSA9PT0gMGAsIHRoZSB0b3AgZWRnZSBvZiB0aGUgaW1hZ2UgaXMgYXQgdGhlIHZpZXdwb3J0IGNlbnRlci5cbiAqICAgICBXaGVuIGB5ID09PSAxYCwgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSBpbWFnZSBpcyBhdCB0aGUgdmlld3BvcnQgY2VudGVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvb20gVGhlIGhvcml6b250YWwgem9vbSwgaW4gdGhlIFswLCDiiJ4pIHJhbmdlLlxuICogICAgIFdoZW4gYHpvb20gPT09IDFgLCB0aGUgdmlld3BvcnQgaXMgYXMgd2lkZSBhcyB0aGUgaW1hZ2UuXG4gKiAgICAgV2hlbiBgem9vbSA8IDFgLCB0aGUgaW1hZ2UgaXMgem9vbWVkIGluLlxuICogICAgIFdoZW4gYHpvb20gPiAxYCwgdGhlIGltYWdlIGlzIHpvb21lZCBvdXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWVkaWFBc3BlY3RSYXRpbyBUaGUgaW1hZ2UgYXNwZWN0IHJhdGlvLlxuICogICAgIFdoZW4gYG1lZGlhQXNwZWN0UmF0aW8gPT09IDFgLCB0aGUgaW1hZ2Ugd2lkdGggZXF1YWxzIGl0cyBoZWlnaHQuXG4gKiAgICAgV2hlbiBgbWVkaWFBc3BlY3RSYXRpbyA8IDFgLCB0aGUgaW1hZ2Ugd2lkdGggaXMgbGVzcyB0aGFuIGl0cyBoZWlnaHQuXG4gKiAgICAgV2hlbiBgbWVkaWFBc3BlY3RSYXRpbyA+IDFgLCB0aGUgaW1hZ2UgaGVpZ2h0IGlzIGxlc3MgdGhhbiBpdHMgd2lkdGguXG4gKi9cblxuXG4vKipcbiAqIEBpbnRlcmZhY2UgRmxhdFZpZXdDb29yZHNcbiAqXG4gKiBUaGUgcG9zaXRpb24gb2YgYSBwb2ludCBpbiBhIGZsYXQgaW1hZ2UuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSwgaW4gdGhlIFswLCAxXSByYW5nZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLCBpbiB0aGUgWzAsIDFdIHJhbmdlLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IEZsYXRWaWV3TGltaXRlclxuICpcbiAqIFZpZXcgbGltaXRlciBmb3IgYSB7QGxpbmsgRmxhdFZpZXd9LlxuICpcbiAqIEEgdmlldyBsaW1pdGVyIGlzIGEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHtAbGluayBGbGF0Vmlld1BhcmFtc30gb2JqZWN0LFxuICogb3B0aW9uYWxseSBtb2RpZmllcyBpdCBpbiBwbGFjZSwgYW5kIHJldHVybnMgaXQuIEl0IGNhbiBiZSB1c2VkIHRvIGVuZm9yY2VcbiAqIGNvbnN0cmFpbnRzIG9uIHRoZSB2aWV3IHBhcmFtZXRlcnMuXG4gKlxuICogU2VlIHtAbGluayBGbGF0Vmlldy5saW1pdH0gZm9yIGNvbW1vbmx5IHVzZWQgbGltaXRlcnMuIFRoZXkgbWF5IGJlIGNvbXBvc2VkXG4gKiB0b2dldGhlciBvciB3aXRoIHVzZXItZGVmaW5lZCBsaW1pdGVycyB3aXRoIHtAbGluayB1dGlsLmNvbXBvc2V9LlxuICpcbiAqIEBwYXJhbSB7RmxhdFZpZXdQYXJhbXN9IHBhcmFtc1xuICogQHJldHVybiB7RmxhdFZpZXdQYXJhbXN9XG4gKi9cblxuXG4vKipcbiAqIEBjbGFzcyBGbGF0Vmlld1xuICogQGltcGxlbWVudHMgVmlld1xuICogQGNsYXNzZGVzY1xuICpcbiAqIEEge0BsaW5rIFZpZXd9IGltcGxlbWVudGluZyBhbiBvcnRob2dvbmFsIHByb2plY3Rpb24gZm9yIGZsYXQgaW1hZ2VzLlxuICpcbiAqIEBwYXJhbSB7RmxhdFZpZXdQYXJhbXN9IHBhcmFtcyBUaGUgaW5pdGlhbCB2aWV3IHBhcmFtZXRlcnMuIFRoZVxuICogICAgIGBtZWRpYUFzcGVjdFJhdGlvYCBwYXJhbWV0ZXIgbXVzdCBhbHdheXMgYmUgc2V0LiBUaGUgb3RoZXIgcGFyYW1ldGVyc1xuICogICAgIGRlZmF1bHQgdG8gYHt4OiAwLjUsIHk6IDAuNSwgejogMSB9YCBpZiB1bnNwZWNpZmllZC5cbiAqIEBwYXJhbSB7RmxhdFZpZXdMaW1pdGVyPX0gbGltaXRlciBUaGUgdmlldyBsaW1pdGVyLiBJZiB1bnNwZWNpZmllZCwgbm8gdmlld1xuICogICAgIGxpbWl0aW5nIGlzIGFwcGxpZWQuIFNlZSB7QGxpbmsgRmxhdFZpZXcubGltaXR9IGZvciBjb21tb25seSB1c2VkXG4gKiAgICAgbGltaXRlcnMuXG4gKi9cbmZ1bmN0aW9uIEZsYXRWaWV3KHBhcmFtcywgbGltaXRlcikge1xuICAvLyBSZXF1aXJlIGFuIGFzcGVjdCByYXRpbyB0byBiZSBzcGVjaWZpZWQuXG4gIGlmICghKHBhcmFtcyAmJiBwYXJhbXMubWVkaWFBc3BlY3RSYXRpbyAhPSBudWxsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVkaWFBc3BlY3RSYXRpbyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuXG4gIC8vIFRoZSBpbml0aWFsIHZhbHVlcyBmb3IgdGhlIHZpZXcgcGFyYW1ldGVycy5cbiAgdGhpcy5feCA9IHBhcmFtcyAmJiBwYXJhbXMueCAhPSBudWxsID8gcGFyYW1zLnggOiBkZWZhdWx0WDtcbiAgdGhpcy5feSA9IHBhcmFtcyAmJiBwYXJhbXMueSAhPSBudWxsID8gcGFyYW1zLnkgOiBkZWZhdWx0WTtcbiAgdGhpcy5fem9vbSA9IHBhcmFtcyAmJiBwYXJhbXMuem9vbSAhPSBudWxsID8gcGFyYW1zLnpvb20gOiBkZWZhdWx0Wm9vbTtcbiAgdGhpcy5fbWVkaWFBc3BlY3RSYXRpbyA9IHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvO1xuICB0aGlzLl93aWR0aCA9IHBhcmFtcyAmJiBwYXJhbXMud2lkdGggIT0gbnVsbCA/XG4gICAgcGFyYW1zLndpZHRoIDogZGVmYXVsdFdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBwYXJhbXMgJiYgcGFyYW1zLmhlaWdodCAhPSBudWxsID9cbiAgICBwYXJhbXMuaGVpZ2h0IDogZGVmYXVsdEhlaWdodDtcblxuICAvLyBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIHZpZXcgbGltaXRlci5cbiAgdGhpcy5fbGltaXRlciA9IGxpbWl0ZXIgfHwgbnVsbDtcblxuICAvLyBUaGUgbGFzdCBjYWxjdWxhdGVkIHByb2plY3Rpb24gbWF0cml4IGFuZCBpdHMgaW52ZXJzZS5cbiAgdGhpcy5fcHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIHRoaXMuX2ludlByb2pNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gIC8vIFRoZSBsYXN0IGNhbGN1bGF0ZWQgdmlldyBmcnVzdHVtLlxuICB0aGlzLl9mcnVzdHVtID0gW1xuICAgIDAsIC8vIHRvcFxuICAgIDAsIC8vIHJpZ2h0XG4gICAgMCwgLy8gYm90dG9tXG4gICAgMCAgLy8gbGVmdFxuICBdO1xuXG4gIC8vIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gbWF0cmljZXMgYW5kIHZpZXcgZnJ1c3R1bSBuZWVkIHRvIGJlIHVwZGF0ZWQuXG4gIHRoaXMuX3Byb2plY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcblxuICAvLyBUZW1wb3JhcnkgdmFyaWFibGVzIHVzZWQgZm9yIGNhbGN1bGF0aW9ucy5cbiAgdGhpcy5fcGFyYW1zID0ge307XG4gIHRoaXMuX3ZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgLy8gRm9yY2UgdmlldyBsaW1pdGluZyBvbiBpbml0aWFsIHBhcmFtZXRlcnMuXG4gIHRoaXMuX3VwZGF0ZSgpO1xufVxuXG5ldmVudEVtaXR0ZXIoRmxhdFZpZXcpO1xuXG5cbi8qKlxuICogRGVzdHJ1Y3Rvci5cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJPd25Qcm9wZXJ0aWVzKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgeCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS54ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl94O1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgeSBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS55ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl95O1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgem9vbSB2YWx1ZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3pvb207XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBtZWRpYSBhc3BlY3QgcmF0aW8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5tZWRpYUFzcGVjdFJhdGlvID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgdmlld3BvcnQgd2lkdGguXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGg7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9ydCBoZWlnaHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aFxuICogdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U2l6ZT19IHNpemVcbiAqIEByZXR1cm4ge1NpemV9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICBzaXplID0gc2l6ZSB8fCB7fTtcbiAgc2l6ZS53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICBzaXplLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2aWV3IHBhcmFtZXRlcnMuIElmIGFuIGFyZ3VtZW50IGlzIHN1cHBsaWVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aCB0aGVcbiAqIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaCBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqIEBwYXJhbSB7RmxhdFZpZXdQYXJhbXM9fSBwYXJhbXNcbiAqIEByZXR1cm4ge0ZsYXRWaWV3UGFyYW1zfVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIHBhcmFtcy54ID0gdGhpcy5feDtcbiAgcGFyYW1zLnkgPSB0aGlzLl95O1xuICBwYXJhbXMuem9vbSA9IHRoaXMuX3pvb207XG4gIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvID0gdGhpcy5fbWVkaWFBc3BlY3RSYXRpbztcbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXcgbGltaXRlciwgb3IgbnVsbCBpZiB1bnNldC5cbiAqIEByZXR1cm4gez9GbGF0Vmlld0xpbWl0ZXJ9XG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5saW1pdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9saW1pdGVyO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgeCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uKHgpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnggPSB4O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHkgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbih5KSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy55ID0geTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB6b29tIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHpvb21cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNldFpvb20gPSBmdW5jdGlvbih6b29tKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy56b29tID0gem9vbTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogQWRkIHhPZmZzZXQgdG8gdGhlIHggcGFyYW1ldGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHhPZmZzZXRcbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLm9mZnNldFggPSBmdW5jdGlvbih4T2Zmc2V0KSB7XG4gIHRoaXMuc2V0WCh0aGlzLl94ICsgeE9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogQWRkIHlPZmZzZXQgdG8gdGhlIHkgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXRcbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLm9mZnNldFkgPSBmdW5jdGlvbih5T2Zmc2V0KVxue1xuICB0aGlzLnNldFkodGhpcy5feSArIHlPZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIEFkZCB6b29tT2Zmc2V0IHRvIHRoZSB6b29tIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHpvb21PZmZzZXRcbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLm9mZnNldFpvb20gPSBmdW5jdGlvbih6b29tT2Zmc2V0KSB7XG4gIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgem9vbU9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBtZWRpYSBhc3BlY3QgcmF0aW8uXG4gKiBAcGFyYW0ge251bWJlcn0gbWVkaWFBc3BlY3RSYXRpb1xuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0TWVkaWFBc3BlY3RSYXRpbyA9IGZ1bmN0aW9uKG1lZGlhQXNwZWN0UmF0aW8pIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW8gPSBtZWRpYUFzcGVjdFJhdGlvO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge1NpemV9IHNpemVcbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy53aWR0aCA9IHNpemUud2lkdGg7XG4gIHRoaXMuX3BhcmFtcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB2aWV3IHBhcmFtZXRlcnMuIFVuc3BlY2lmaWVkIHBhcmFtZXRlcnMgYXJlIGxlZnQgdW5jaGFuZ2VkLlxuICogQHBhcmFtIHtGbGF0Vmlld1BhcmFtZXRlcnN9IHBhcmFtc1xuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuc2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMueCA9IHBhcmFtcy54O1xuICB0aGlzLl9wYXJhbXMueSA9IHBhcmFtcy55O1xuICB0aGlzLl9wYXJhbXMuem9vbSA9IHBhcmFtcy56b29tO1xuICB0aGlzLl9wYXJhbXMubWVkaWFBc3BlY3RSYXRpbyA9IHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXcgbGltaXRlci5cbiAqIEBwYXJhbSB7P0ZsYXRWaWV3TGltaXRlcn0gbGltaXRlciBUaGUgbmV3IGxpbWl0ZXIsIG9yIG51bGwgdG8gdW5zZXQuXG4gKi9cbkZsYXRWaWV3LnByb3RvdHlwZS5zZXRMaW1pdGVyID0gZnVuY3Rpb24obGltaXRlcikge1xuICB0aGlzLl9saW1pdGVyID0gbGltaXRlciB8fCBudWxsO1xuICB0aGlzLl91cGRhdGUoKTtcbn07XG5cblxuRmxhdFZpZXcucHJvdG90eXBlLl9yZXNldFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICBwYXJhbXMueCA9IG51bGw7XG4gIHBhcmFtcy55ID0gbnVsbDtcbiAgcGFyYW1zLnpvb20gPSBudWxsO1xuICBwYXJhbXMubWVkaWFBc3BlY3RSYXRpbyA9IG51bGw7XG4gIHBhcmFtcy53aWR0aCA9IG51bGw7XG4gIHBhcmFtcy5oZWlnaHQgPSBudWxsO1xufTtcblxuXG5GbGF0Vmlldy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXG4gIC8vIEF2b2lkIG9iamVjdCBhbGxvY2F0aW9uIHdoZW4gbm8gcGFyYW1ldGVycyBhcmUgc3VwcGxpZWQuXG4gIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gICAgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICB9XG5cbiAgLy8gU2F2ZSBvbGQgcGFyYW1ldGVycyBmb3IgbGF0ZXIgY29tcGFyaXNvbi5cbiAgdmFyIG9sZFggPSB0aGlzLl94O1xuICB2YXIgb2xkWSA9IHRoaXMuX3k7XG4gIHZhciBvbGRab29tID0gdGhpcy5fem9vbTtcbiAgdmFyIG9sZE1lZGlhQXNwZWN0UmF0aW8gPSB0aGlzLl9tZWRpYUFzcGVjdFJhdGlvO1xuICB2YXIgb2xkV2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIG9sZEhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAvLyBGaWxsIGluIG9iamVjdCB3aXRoIHRoZSBuZXcgc2V0IG9mIHBhcmFtZXRlcnMgdG8gcGFzcyBpbnRvIHRoZSBsaW1pdGVyLlxuICBwYXJhbXMueCA9IHBhcmFtcy54ICE9IG51bGwgPyBwYXJhbXMueCA6IG9sZFg7XG4gIHBhcmFtcy55ID0gcGFyYW1zLnkgIT0gbnVsbCA/IHBhcmFtcy55IDogb2xkWTtcbiAgcGFyYW1zLnpvb20gPSBwYXJhbXMuem9vbSAhPSBudWxsID8gcGFyYW1zLnpvb20gOiBvbGRab29tO1xuICBwYXJhbXMubWVkaWFBc3BlY3RSYXRpbyA9IHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvICE9IG51bGwgP1xuICAgIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvIDogb2xkTWVkaWFBc3BlY3RSYXRpbztcbiAgcGFyYW1zLndpZHRoID0gcGFyYW1zLndpZHRoICE9IG51bGwgPyBwYXJhbXMud2lkdGggOiBvbGRXaWR0aDtcbiAgcGFyYW1zLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgIT0gbnVsbCA/IHBhcmFtcy5oZWlnaHQgOiBvbGRIZWlnaHQ7XG5cbiAgLy8gQXBwbHkgdmlldyBsaW1pdGluZyB3aGVuIGRlZmluZWQuXG4gIGlmICh0aGlzLl9saW1pdGVyKSB7XG4gICAgcGFyYW1zID0gdGhpcy5fbGltaXRlcihwYXJhbXMpO1xuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCB2aWV3IGxpbWl0ZXInKTtcbiAgICB9XG4gIH1cblxuICAvLyBHcmFiIHRoZSBsaW1pdGVkIHBhcmFtZXRlcnMuXG4gIHZhciBuZXdYID0gcGFyYW1zLng7XG4gIHZhciBuZXdZID0gcGFyYW1zLnk7XG4gIHZhciBuZXdab29tID0gcGFyYW1zLnpvb207XG4gIHZhciBuZXdNZWRpYUFzcGVjdFJhdGlvID0gcGFyYW1zLm1lZGlhQXNwZWN0UmF0aW87XG4gIHZhciBuZXdXaWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgdmFyIG5ld0hlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG5cbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2suXG4gIGlmICghcmVhbChuZXdYKSB8fCAhcmVhbChuZXdZKSB8fCAhcmVhbChuZXdab29tKSB8fFxuICAgICAgIXJlYWwobmV3TWVkaWFBc3BlY3RSYXRpbykgfHwgIXJlYWwobmV3V2lkdGgpIHx8ICFyZWFsKG5ld0hlaWdodCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCB2aWV3IC0gc3VzcGVjdCBhIGJyb2tlbiBsaW1pdGVyJyk7XG4gIH1cblxuICAvLyBDb25zdHJhaW4gem9vbS5cbiAgbmV3Wm9vbSA9IGNsYW1wKG5ld1pvb20sIHpvb21MaW1pdEVwc2lsb24sIEluZmluaXR5KTtcblxuICAvLyBVcGRhdGUgcGFyYW1ldGVycy5cbiAgdGhpcy5feCA9IG5ld1g7XG4gIHRoaXMuX3kgPSBuZXdZO1xuICB0aGlzLl96b29tID0gbmV3Wm9vbTtcbiAgdGhpcy5fbWVkaWFBc3BlY3RSYXRpbyA9IG5ld01lZGlhQXNwZWN0UmF0aW87XG4gIHRoaXMuX3dpZHRoID0gbmV3V2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IG5ld0hlaWdodDtcblxuICAvLyBDaGVjayB3aGV0aGVyIHRoZSBwYXJhbWV0ZXJzIGNoYW5nZWQgYW5kIGVtaXQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzLlxuICBpZiAobmV3WCAhPT0gb2xkWCB8fCBuZXdZICE9PSBvbGRZIHx8IG5ld1pvb20gIT09IG9sZFpvb20gfHxcbiAgICAgIG5ld01lZGlhQXNwZWN0UmF0aW8gIT09IG9sZE1lZGlhQXNwZWN0UmF0aW8gfHxcbiAgICAgIG5ld1dpZHRoICE9PSBvbGRXaWR0aCB8fCBuZXdIZWlnaHQgIT09IG9sZEhlaWdodCkge1xuICAgIHRoaXMuX3Byb2plY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICB9XG4gIGlmIChuZXdXaWR0aCAhPT0gb2xkV2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBvbGRIZWlnaHQpIHtcbiAgICB0aGlzLmVtaXQoJ3Jlc2l6ZScpO1xuICB9XG5cbn07XG5cblxuRmxhdFZpZXcucHJvdG90eXBlLl96b29tWCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fem9vbTtcbn07XG5cblxuRmxhdFZpZXcucHJvdG90eXBlLl96b29tWSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWVkaWFBc3BlY3RSYXRpbyA9IHRoaXMuX21lZGlhQXNwZWN0UmF0aW87XG4gIHZhciBhc3BlY3QgPSB0aGlzLl93aWR0aCAvIHRoaXMuX2hlaWdodDtcbiAgdmFyIHpvb21YID0gdGhpcy5fem9vbTtcbiAgdmFyIHpvb21ZID0gem9vbVggKiBtZWRpYUFzcGVjdFJhdGlvIC8gYXNwZWN0O1xuICBpZiAoaXNOYU4oem9vbVkpKSB7XG4gICAgem9vbVkgPSB6b29tWDtcbiAgfVxuICByZXR1cm4gem9vbVk7XG59O1xuXG5cbkZsYXRWaWV3LnByb3RvdHlwZS51cGRhdGVXaXRoQ29udHJvbFBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gIHZhciBzY2FsZSA9IHRoaXMuem9vbSgpO1xuICB2YXIgem9vbVggPSB0aGlzLl96b29tWCgpO1xuICB2YXIgem9vbVkgPSB0aGlzLl96b29tWSgpO1xuXG4gIC8vIFRPRE86IHNob3VsZCB0aGUgc2NhbGUgYmUgdGhlIHNhbWUgZm9yIGJvdGggYXhlcz9cbiAgdGhpcy5vZmZzZXRYKHBhcmFtZXRlcnMuYXhpc1NjYWxlZFggKiB6b29tWCArIHBhcmFtZXRlcnMueCAqIHNjYWxlKTtcbiAgdGhpcy5vZmZzZXRZKHBhcmFtZXRlcnMuYXhpc1NjYWxlZFkgKiB6b29tWSArIHBhcmFtZXRlcnMueSAqIHNjYWxlKTtcbiAgdGhpcy5vZmZzZXRab29tKHBhcmFtZXRlcnMuem9vbSAqIHNjYWxlKTtcbn07XG5cblxuRmxhdFZpZXcucHJvdG90eXBlLl91cGRhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwcm9qTWF0cml4ID0gdGhpcy5fcHJvak1hdHJpeDtcbiAgdmFyIGludlByb2pNYXRyaXggPSB0aGlzLl9pbnZQcm9qTWF0cml4O1xuICB2YXIgZnJ1c3R1bSA9IHRoaXMuX2ZydXN0dW07XG5cbiAgLy8gUmVjYWxjdWxhdGUgcHJvamVjdGlvbiBtYXRyaXggd2hlbiByZXF1aXJlZC5cbiAgaWYgKHRoaXMuX3Byb2plY3Rpb25DaGFuZ2VkKSB7XG4gICAgdmFyIHggPSB0aGlzLl94O1xuICAgIHZhciB5ID0gdGhpcy5feTtcbiAgICB2YXIgem9vbVggPSB0aGlzLl96b29tWCgpO1xuICAgIHZhciB6b29tWSA9IHRoaXMuX3pvb21ZKCk7XG5cbiAgICAvLyBSZWNhbGN1bGF0ZSB2aWV3IGZydXN0dW0uXG4gICAgdmFyIHRvcCAgICAgPSBmcnVzdHVtWzBdID0gKDAuNSAtIHkpICsgMC41ICogem9vbVk7XG4gICAgdmFyIHJpZ2h0ICAgPSBmcnVzdHVtWzFdID0gKHggLSAwLjUpICsgMC41ICogem9vbVg7XG4gICAgdmFyIGJvdHRvbSAgPSBmcnVzdHVtWzJdID0gKDAuNSAtIHkpIC0gMC41ICogem9vbVk7XG4gICAgdmFyIGxlZnQgICAgPSBmcnVzdHVtWzNdID0gKHggLSAwLjUpIC0gMC41ICogem9vbVg7XG5cbiAgICAvLyBSZWNhbGN1bGF0ZSBwcm9qZWN0aW9uIG1hdHJpeCBhbmQgaXRzIGludmVyc2UuXG4gICAgbWF0NC5vcnRobyhwcm9qTWF0cml4LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIC0xLCAxKTtcbiAgICBtYXQ0LmludmVydChpbnZQcm9qTWF0cml4LCBwcm9qTWF0cml4KTtcblxuICAgIHRoaXMuX3Byb2plY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEByZXR1cm5zIHttYXQ0fVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUucHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVQcm9qZWN0aW9uKCk7XG4gIHJldHVybiB0aGlzLl9wcm9qTWF0cml4O1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBAcmV0dXJucyB7bWF0NH1cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmludmVyc2VQcm9qZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZVByb2plY3Rpb24oKTtcbiAgcmV0dXJuIHRoaXMuX2ludlByb2pNYXRyaXg7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgdGhlIHZpZXcgZnJ1c3R1bSBpbnRlcnNlY3RzIHRoZSBnaXZlbiByZWN0YW5nbGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXkgcmV0dXJuIGZhbHNlIHBvc2l0aXZlcywgYnV0IG5ldmVyIGZhbHNlIG5lZ2F0aXZlcy5cbiAqIEl0IGlzIHVzZWQgZm9yIGZydXN0dW0gY3VsbGluZywgaS5lLiwgZXhjbHVkaW5nIGludmlzaWJsZSB0aWxlcyBmcm9tIHRoZVxuICogcmVuZGVyaW5nIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHt2ZWMzW119IHJlY3RhbmdsZSBUaGUgdmVydGljZXMgb2YgdGhlIHJlY3RhbmdsZS5cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihyZWN0YW5nbGUpIHtcbiAgdGhpcy5fdXBkYXRlUHJvamVjdGlvbigpO1xuXG4gIHZhciBmcnVzdHVtID0gdGhpcy5fZnJ1c3R1bTtcblxuICAvLyBDaGVjayB3aGV0aGVyIHRoZSByZWN0YW5nbGUgaXMgb24gdGhlIG91dGVyIHNpZGUgb2YgYW55IG9mIHRoZSBmcnVzdHVtXG4gIC8vIHBsYW5lcy4gVGhpcyBpcyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uLCB0aG91Z2ggbm90IG5lY2Vzc2FyeSwgZm9yIHRoZVxuICAvLyByZWN0YW5nbGUgdG8gYmUgY29tcGxldGVseSBvdXRzaWRlIHRoZSBmcnVvdXRlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZydXN0dW0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGltaXQgPSBmcnVzdHVtW2ldO1xuICAgIHZhciBheGlzID0gcGxhbmVBeGVzW2ldO1xuICAgIHZhciBjbXAgPSBwbGFuZUNtcFtpXTtcbiAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWN0YW5nbGUubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciB2ZXJ0ZXggPSByZWN0YW5nbGVbal07XG4gICAgICBpZiAoY21wIDwgMCAmJiB2ZXJ0ZXhbYXhpc10gPCBsaW1pdCB8fCBjbXAgPiAwICYmIHZlcnRleFtheGlzXSA+IGxpbWl0KSB7XG4gICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluc2lkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBTZWxlY3QgdGhlIGxldmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSB2aWV3LlxuICogQHBhcmFtIHtMZXZlbFtdfSBsZXZlbExpc3QgdGhlIGxpc3Qgb2YgbGV2ZWxzIGZyb20gd2hpY2ggdG8gc2VsZWN0LlxuICogQHJldHVybiB7TGV2ZWx9IHRoZSBzZWxlY3RlZCBsZXZlbC5cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNlbGVjdExldmVsID0gZnVuY3Rpb24obGV2ZWxzKSB7XG5cbiAgLy8gTXVsdGlwbHkgdGhlIHZpZXdwb3J0IHdpZHRoIGJ5IHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8gdG8gZ2V0IHRoZSByZXF1aXJlZFxuICAvLyBob3Jpem9udGFsIHJlc29sdXRpb24gaW4gcGl4ZWxzLlxuICAvL1xuICAvLyBDYWxjdWxhdGUgdGhlIGZyYWN0aW9uIG9mIHRoZSBpbWFnZSB0aGF0IHdvdWxkIGJlIHZpc2libGUgYXQgdGhlIGN1cnJlbnRcbiAgLy8gem9vbSB2YWx1ZS4gVGhlbiwgZm9yIGVhY2ggbGV2ZWwsIG11bHRpcGx5IGJ5IHRoZSBsZXZlbCB3aWR0aCB0byBnZXQgdGhlXG4gIC8vIHdpZHRoIGluIHBpeGVscyBvZiB0aGUgcG9ydGlvbiB0aGF0IHdvdWxkIGJlIHZpc2libGUuXG4gIC8vXG4gIC8vIFNlYXJjaCBmb3IgdGhlIHNtYWxsZXN0IGxldmVsIHRoYXQgc2F0aWZpZXMgdGhlIHRoZSByZXF1aXJlZCB3aWR0aCxcbiAgLy8gZmFsbGluZyBiYWNrIG9uIHRoZSBsYXJnZXN0IGxldmVsIGlmIG5vbmUgZG8uXG5cbiAgdmFyIHJlcXVpcmVkUGl4ZWxzID0gcGl4ZWxSYXRpbygpICogdGhpcy53aWR0aCgpO1xuICB2YXIgem9vbUZhY3RvciA9IHRoaXMuX3pvb207XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgaWYgKHpvb21GYWN0b3IgKiBsZXZlbC53aWR0aCgpID49IHJlcXVpcmVkUGl4ZWxzKSB7XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxldmVsc1tsZXZlbHMubGVuZ3RoIC0gMV07XG5cbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IHZpZXcgY29vcmRpbmF0ZXMgaW50byBzY3JlZW4gY29vcmRpbmF0ZXMuIElmIGEgcmVzdWx0IGFyZ3VtZW50IGlzXG4gKiBwcm92aWRlZCwgaXQgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWRcbiAqIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge0ZsYXRWaWV3Q29vcmRzfSBjb29yZHMgVGhlIHZpZXcgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0Nvb3Jkcz19IHJlc3VsdCBUaGUgcmVzdWx0IGFyZ3VtZW50IGZvciB0aGUgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICogQHJldHVybiB7Q29vcmRzfVxuICovXG5GbGF0Vmlldy5wcm90b3R5cGUuY29vcmRpbmF0ZXNUb1NjcmVlbiA9IGZ1bmN0aW9uKGNvb3JkcywgcmVzdWx0KSB7XG4gIHZhciByYXkgPSB0aGlzLl92ZWM7XG5cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gIC8vIFVuZGVmaW5lZCBvbiBhIG51bGwgdmlld3BvcnQuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgcmVzdWx0LnggPSBudWxsO1xuICAgIHJlc3VsdC55ID0gbnVsbDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEV4dHJhY3QgY29vcmRpbmF0ZXMgZnJvbSBhcmd1bWVudCwgZmlsbGluZyBpbiBkZWZhdWx0IHZhbHVlcy5cbiAgdmFyIHggPSBjb29yZHMgJiYgY29vcmRzLnggIT0gbnVsbCA/IGNvb3Jkcy54IDogZGVmYXVsdFg7XG4gIHZhciB5ID0gY29vcmRzICYmIGNvb3Jkcy55ICE9IG51bGwgPyBjb29yZHMueSA6IGRlZmF1bHRZO1xuXG4gIC8vIFByb2plY3QgdmlldyByYXkgb250byBjbGlwIHNwYWNlLlxuICB2ZWM0LnNldChyYXksIHggLSAwLjUsIDAuNSAtIHksIC0xLCAxKTtcbiAgdmVjNC50cmFuc2Zvcm1NYXQ0KHJheSwgcmF5LCB0aGlzLnByb2plY3Rpb24oKSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHBlcnNwZWN0aXZlIGRpdmlkZS5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByYXlbaV0gLz0gcmF5WzNdO1xuICB9XG5cbiAgLy8gQ29udmVydCB0byB2aWV3cG9ydCBjb29yZGluYXRlcyBhbmQgcmV0dXJuLlxuICByZXN1bHQueCA9IHdpZHRoICogKHJheVswXSArIDEpIC8gMjtcbiAgcmVzdWx0LnkgPSBoZWlnaHQgKiAoMSAtIHJheVsxXSkgLyAyO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogQ29udmVydCBzY3JlZW4gY29vcmRpbmF0ZXMgaW50byB2aWV3IGNvb3JkaW5hdGVzLiBJZiBhIHJlc3VsdCBhcmd1bWVudCBpc1xuICogcHJvdmlkZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoIHRoZSByZXN1bHQgYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2hcbiAqIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7Q29vcmRzfSBjb29yZHMgVGhlIHNjcmVlbiBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7RmxhdFZpZXdDb29yZHM9fSByZXN1bHQgVGhlIHJlc3VsdCBhcmd1bWVudCBmb3IgdGhlIHZpZXcgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtGbGF0Vmlld0Nvb3Jkc31cbiAqL1xuRmxhdFZpZXcucHJvdG90eXBlLnNjcmVlblRvQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbihjb29yZHMsIHJlc3VsdCkge1xuICB2YXIgcmF5ID0gdGhpcy5fdmVjO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0ge307XG4gIH1cblxuICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAvLyBDb252ZXJ0IHZpZXdwb3J0IGNvb3JkaW5hdGVzIHRvIGNsaXAgc3BhY2UuXG4gIHZhciB2ZWN4ID0gMiAqIGNvb3Jkcy54IC8gd2lkdGggLSAxO1xuICB2YXIgdmVjeSA9IDEgLSAyICogY29vcmRzLnkgLyBoZWlnaHQ7XG4gIHZlYzQuc2V0KHJheSwgdmVjeCwgdmVjeSwgMSwgMSk7XG5cbiAgLy8gUHJvamVjdCBiYWNrIHRvIHdvcmxkIHNwYWNlLlxuICB2ZWM0LnRyYW5zZm9ybU1hdDQocmF5LCByYXksIHRoaXMuaW52ZXJzZVByb2plY3Rpb24oKSk7XG5cbiAgLy8gQ29udmVydCB0byBmbGF0IGNvb3JkaW5hdGVzLlxuICByZXN1bHQueCA9IDAuNSArIHJheVswXTtcbiAgcmVzdWx0LnkgPSAwLjUgLSByYXlbMV07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9ucyBmb3IgdmlldyBsaW1pdGVycy4gU2VlIHtAbGluayBGbGF0Vmlld0xpbWl0ZXJ9LlxuICogQG5hbWVzcGFjZVxuICovXG5GbGF0Vmlldy5saW1pdCA9IHtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHggcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHggdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0geSB2YWx1ZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgeDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRYKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnggPSBjbGFtcChwYXJhbXMueCwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSB2aWV3IGxpbWl0ZXIgdGhhdCBjb25zdHJhaW5zIHRoZSB5IHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB5IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHkgdmFsdWUuXG4gICAqIEByZXR1cm4ge0ZsYXRWaWV3TGltaXRlcn1cbiAgICovXG4gIHk6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0WShwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy55ID0gY2xhbXAocGFyYW1zLnksIG1pbiwgbWF4KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGFuIGNvbnN0cmFpbnMgdGhlIHpvb20gcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHpvb20gdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gem9vbSB2YWx1ZS5cbiAgICogQHJldHVybiB7RmxhdFZpZXdMaW1pdGVyfVxuICAgKi9cbiAgem9vbTogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRab29tKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnpvb20gPSBjbGFtcChwYXJhbXMuem9vbSwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgcHJldmVudHMgem9vbWluZyBpbiBiZXlvbmQgdGhlIGdpdmVuXG4gICAqIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoZSBpbWFnZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm4ge0ZsYXRWaWV3TGltaXRlcn1cbiAgICovXG4gIHJlc29sdXRpb246IGZ1bmN0aW9uKHNpemUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRSZXNvbHV0aW9uKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy53aWR0aCA8PSAwIHx8IHBhcmFtcy5oZWlnaHQgPD0gMCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgfVxuICAgICAgdmFyIHdpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgdmFyIG1pblpvb20gPSBwaXhlbFJhdGlvKCkgKiB3aWR0aCAvIHNpemU7XG4gICAgICBwYXJhbXMuem9vbSA9IGNsYW1wKHBhcmFtcy56b29tLCBtaW5ab29tLCBJbmZpbml0eSk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBjb25zdHJhaW5zIHRoZSB2YWx1ZXMgb2YgdGhlIHggcGFyYW1ldGVyIHRoYXRcbiAgICogYXJlIGluc2lkZSB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0geCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB4IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtGbGF0Vmlld0xpbWl0ZXJ9XG4gICAqL1xuICB2aXNpYmxlWDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRWaXNpYmxlWChwYXJhbXMpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgem9vbSB2YWx1ZSB0aGF0IG1ha2VzIHRoZSBzcGVjaWZpZWQgcmFuZ2UgZnVsbHkgdmlzaWJsZS5cbiAgICAgIHZhciBtYXhab29tID0gbWF4IC0gbWluO1xuXG4gICAgICAvLyBDbGFtcCB6b29tIHRvIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAgaWYgKHBhcmFtcy56b29tID4gbWF4Wm9vbSkge1xuICAgICAgICBwYXJhbXMuem9vbSA9IG1heFpvb207XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIFggc3VjaCB0aGF0IHRoZSBpbWFnZSBpcyB2aXNpYmxlIHVwIHRvIHRoZSByYW5nZSBlZGdlcy5cbiAgICAgIHZhciBtaW5YID0gbWluICsgMC41ICogcGFyYW1zLnpvb207XG4gICAgICB2YXIgbWF4WCA9IG1heCAtIDAuNSAqIHBhcmFtcy56b29tO1xuICAgICAgcGFyYW1zLnggPSBjbGFtcChwYXJhbXMueCwgbWluWCwgbWF4WCk7XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHZhbHVlcyBvZiB0aGUgeSBwYXJhbWV0ZXIgdGhhdFxuICAgKiBhcmUgaW5zaWRlIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB5IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHkgdmFsdWUuXG4gICAqIEByZXR1cm4ge0ZsYXRWaWV3TGltaXRlcn1cbiAgICovXG4gIHZpc2libGVZOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFZpc2libGVZKHBhcmFtcykge1xuXG4gICAgICAvLyBEbyBub3RoaW5nIGZvciBhIG51bGwgdmlld3BvcnQuXG4gICAgICBpZiAocGFyYW1zLndpZHRoIDw9IDAgfHwgcGFyYW1zLmhlaWdodCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgWCB0byBZIGNvbnZlcnNpb24gZmFjdG9yLlxuICAgICAgdmFyIHZpZXdwb3J0QXNwZWN0UmF0aW8gPSBwYXJhbXMud2lkdGggLyBwYXJhbXMuaGVpZ2h0O1xuICAgICAgdmFyIGZhY3RvciA9IHZpZXdwb3J0QXNwZWN0UmF0aW8gLyBwYXJhbXMubWVkaWFBc3BlY3RSYXRpbztcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB6b29tIHZhbHVlIHRoYXQgbWFrZXMgdGhlIHNwZWNpZmllZCByYW5nZSBmdWxseSB2aXNpYmxlLlxuICAgICAgdmFyIG1heFpvb20gPSAobWF4IC0gbWluKSAqIGZhY3RvcjtcblxuICAgICAgLy8gQ2xhbXAgem9vbSB0byB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgIGlmIChwYXJhbXMuem9vbSA+IG1heFpvb20pIHtcbiAgICAgICAgcGFyYW1zLnpvb20gPSBtYXhab29tO1xuICAgICAgfVxuXG4gICAgICAvLyBCb3VuZCBZIHN1Y2ggdGhhdCB0aGUgaW1hZ2UgaXMgdmlzaWJsZSB1cCB0byB0aGUgcmFuZ2UgZWRnZXMuXG4gICAgICB2YXIgbWluWSA9IG1pbiArIDAuNSAqIHBhcmFtcy56b29tIC8gZmFjdG9yO1xuICAgICAgdmFyIG1heFkgPSBtYXggLSAwLjUgKiBwYXJhbXMuem9vbSAvIGZhY3RvcjtcbiAgICAgIHBhcmFtcy55ID0gY2xhbXAocGFyYW1zLnksIG1pblksIG1heFkpO1xuXG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHpvb20gcGFyYW1ldGVyIHN1Y2ggdGhhdFxuICAgKiB6b29taW5nIG91dCBpcyBwcmV2ZW50ZWQgYmV5b25kIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgaW1hZ2UgaXMgZnVsbHlcbiAgICogdmlzaWJsZS4gVW5sZXNzIHRoZSBpbWFnZSBhbmQgdGhlIHZpZXdwb3J0IGhhdmUgdGhlIHNhbWUgYXNwZWN0IHJhdGlvLFxuICAgKiB0aGlzIHdpbGwgY2F1c2UgYmFuZHMgdG8gYXBwZWFyIGFyb3VuZCB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm4ge0ZsYXRWaWV3TGltaXRlcn1cbiAgICovXG4gIGxldHRlcmJveDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0TGV0dGVyYm94KHBhcmFtcykge1xuICAgICAgaWYocGFyYW1zLndpZHRoIDw9IDAgfHwgcGFyYW1zLmhlaWdodCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICB9XG4gICAgICB2YXIgdmlld3BvcnRBc3BlY3RSYXRpbyA9IHBhcmFtcy53aWR0aCAvIHBhcmFtcy5oZWlnaHQ7XG5cbiAgICAgIHZhciBmdWxsV2lkdGhab29tID0gMS4wO1xuICAgICAgdmFyIGZ1bGxIZWlnaHRab29tID0gdmlld3BvcnRBc3BlY3RSYXRpbyAvIHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvO1xuXG4gICAgICAvLyBJZiB0aGUgaW1hZ2UgaXMgd2lkZXIgdGhhbiB0aGUgdmlld3BvcnQsIGxpbWl0IHRoZSBob3Jpem9udGFsIHpvb20gdG9cbiAgICAgIC8vIHRoZSBpbWFnZSB3aWR0aC5cbiAgICAgIGlmIChwYXJhbXMubWVkaWFBc3BlY3RSYXRpbyA+PSB2aWV3cG9ydEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIHBhcmFtcy56b29tID0gTWF0aC5taW4ocGFyYW1zLnpvb20sIGZ1bGxXaWR0aFpvb20pO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgaW1hZ2UgaXMgbmFycm93ZXIgdGhhbiB0aGUgdmlld3BvcnQsIGxpbWl0IHRoZSB2ZXJ0aWNhbCB6b29tIHRvXG4gICAgICAvLyB0aGUgaW1hZ2UgaGVpZ2h0LlxuICAgICAgaWYgKHBhcmFtcy5tZWRpYUFzcGVjdFJhdGlvIDw9IHZpZXdwb3J0QXNwZWN0UmF0aW8pIHtcbiAgICAgICAgcGFyYW1zLnpvb20gPSBNYXRoLm1pbihwYXJhbXMuem9vbSwgZnVsbEhlaWdodFpvb20pO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZnVsbCBpbWFnZSB3aWR0aCBpcyB2aXNpYmxlLCBsaW1pdCB4IHRvIHRoZSBjZW50cmFsIHBvaW50LlxuICAgICAgLy8gRWxzZSwgYm91bmQgeCBzdWNoIHRoYXQgaW1hZ2UgaXMgdmlzaWJsZSB1cCB0byB0aGUgaG9yaXpvbnRhbCBlZGdlcy5cbiAgICAgIHZhciBtaW5YLCBtYXhYO1xuICAgICAgaWYgKHBhcmFtcy56b29tID4gZnVsbFdpZHRoWm9vbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IDAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblggPSAwLjAgKyAwLjUgKiBwYXJhbXMuem9vbSAvIGZ1bGxXaWR0aFpvb207XG4gICAgICAgIG1heFggPSAxLjAgLSAwLjUgKiBwYXJhbXMuem9vbSAvIGZ1bGxXaWR0aFpvb207XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmdWxsIGltYWdlIGhlaWdodCBpcyB2aXNpYmxlLCBsaW1pdCB5IHRvIHRoZSBjZW50cmFsIHBvaW50LlxuICAgICAgLy8gRWxzZSwgYm91bmQgeSBzdWNoIHRoYXQgaW1hZ2UgaXMgdmlzaWJsZSB1cCB0byB0aGUgdmVydGljYWwgZWRnZXMuXG4gICAgICB2YXIgbWluWSwgbWF4WTtcbiAgICAgIGlmIChwYXJhbXMuem9vbSA+IGZ1bGxIZWlnaHRab29tKSB7XG4gICAgICAgIG1pblkgPSBtYXhZID0gMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluWSA9IDAuMCArIDAuNSAqIHBhcmFtcy56b29tIC8gZnVsbEhlaWdodFpvb207XG4gICAgICAgIG1heFkgPSAxLjAgLSAwLjUgKiBwYXJhbXMuem9vbSAvIGZ1bGxIZWlnaHRab29tO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGFtcCB4IGFuZCB5IGludG8gdGhlIGNhbGN1bGF0ZWQgYm91bmRzLlxuICAgICAgcGFyYW1zLnggPSBjbGFtcChwYXJhbXMueCwgbWluWCwgbWF4WCk7XG4gICAgICBwYXJhbXMueSA9IGNsYW1wKHBhcmFtcy55LCBtaW5ZLCBtYXhZKTtcblxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9XG5cbn07XG5cblxuRmxhdFZpZXcudHlwZSA9IEZsYXRWaWV3LnByb3RvdHlwZS50eXBlID0gJ2ZsYXQnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmxhdFZpZXc7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudEVtaXR0ZXIgPSByZXF1aXJlKCdtaW5pbWFsLWV2ZW50LWVtaXR0ZXInKTtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcbnZhciB2ZWM0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjNDtcbnZhciB2ZWMzID0gcmVxdWlyZSgnZ2wtbWF0cml4JykudmVjMztcbnZhciBwaXhlbFJhdGlvID0gcmVxdWlyZSgnLi4vdXRpbC9waXhlbFJhdGlvJyk7XG52YXIgY29udmVydEZvdiA9IHJlcXVpcmUoJy4uL3V0aWwvY29udmVydEZvdicpO1xudmFyIG1vZCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kJyk7XG52YXIgcmVhbCA9IHJlcXVpcmUoJy4uL3V0aWwvcmVhbCcpO1xudmFyIGNsYW1wID0gcmVxdWlyZSgnLi4vdXRpbC9jbGFtcCcpO1xudmFyIGRlY2ltYWwgPSByZXF1aXJlKCcuLi91dGlsL2RlY2ltYWwnKTtcbnZhciBjb21wb3NlID0gcmVxdWlyZSgnLi4vdXRpbC9jb21wb3NlJyk7XG52YXIgY2xlYXJPd25Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXRpbC9jbGVhck93blByb3BlcnRpZXMnKTtcblxuLy8gRGVmYXVsdCB2aWV3cG9ydCBkaW1lbnNpb25zLlxuLy8gU3RhcnQgd2l0aCB6ZXJvIHRvIGVuc3VyZSB0aGF0IHRob3NlIHZhbHVlcyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG52YXIgZGVmYXVsdFdpZHRoID0gMDtcbnZhciBkZWZhdWx0SGVpZ2h0ID0gMDtcblxuLy8gRGVmYXVsdCB2aWV3IHBhcmFtZXRlcnMuXG52YXIgZGVmYXVsdFlhdyA9IDA7XG52YXIgZGVmYXVsdFBpdGNoID0gMDtcbnZhciBkZWZhdWx0Um9sbCA9IDA7XG52YXIgZGVmYXVsdEZvdiA9IE1hdGguUEkvNDtcbnZhciBkZWZhdWx0UHJvamVjdGlvbkNlbnRlclggPSAwO1xudmFyIGRlZmF1bHRQcm9qZWN0aW9uQ2VudGVyWSA9IDA7XG52YXIgZGVmYXVsdFR4ID0gMDtcbnZhciBkZWZhdWx0VHkgPSAwO1xudmFyIGRlZmF1bHRUeiA9IDA7XG52YXIgZGVmYXVsdE94ID0gMDtcbnZhciBkZWZhdWx0T3kgPSAwO1xudmFyIGRlZmF1bHRPeiA9IDA7XG5cbi8vIEEgZm92IG9mIGV4YWN0bHkgMCBvciDPgCBicmVha3Mgc29tZSBjb21wdXRhdGlvbnMsIHNvIHdlIGNvbnN0cmFpbiBpdCB0byB0aGVcbi8vIFtmb3ZMaW1pdEVwc2lsb24sIM+AIC0gZm92TGltaXRFcHNpbG9uXSBpbnRlcnZhbC4gV2UgdXNlIDYgZGVjaW1hbCBwbGFjZXMgZm9yXG4vLyB0aGUgZXBzaWxvbiB2YWx1ZSB0byBhdm9pZCBicm9rZW4gcmVuZGVyaW5nIGR1ZSB0byBsb3NzIG9mIHByZWNpc2lvbiBpblxuLy8gZmxvYXRpbmcgcG9pbnQgY29tcHV0YXRpb25zLlxudmFyIGZvdkxpbWl0RXBzaWxvbiA9IDAuMDAwMDAxO1xuXG5cbi8qKlxuICogQGludGVyZmFjZSBSZWN0aWxpbmVhclZpZXdQYXJhbXNcbiAqXG4gKiBBIGNhbWVyYSBjb25maWd1cmF0aW9uIGZvciBhIHtAbGluayBSZWN0aWxpbmVhclZpZXd9LlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5YXcgVGhlIHlhdyBhbmdsZSwgaW4gdGhlIFstz4AsIM+AXSByYW5nZS5cbiAqICAgICBXaGVuIGB5YXcgPCAwYCwgdGhlIHZpZXcgcm90YXRlcyB0byB0aGUgbGVmdC5cbiAqICAgICBXaGVuIGB5YXcgPiAwYCwgdGhlIHZpZXcgcm90YXRlcyB0byB0aGUgcmlnaHQuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpdGNoIFRoZSBwaXRjaCBhbmdsZSwgaW4gdGhlIFstz4AsIM+AXSByYW5nZS5cbiAqICAgICBXaGVuIGBwaXRjaCA8IDBgLCB0aGUgdmlldyByb3RhdGVzIGRvd253YXJkcy5cbiAqICAgICBXaGVuIGBwaXRjaCA+IDBgLCB0aGUgdmlldyByb3RhdGVzIHVwd2FyZHMuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvbGwgVGhlIHJvbGwgYW5nbGUsIGluIHRoZSBbLc+ALCDPgF0gcmFuZ2UuXG4gKiAgICAgV2hlbiBgcm9sbCA8IDBgLCB0aGUgdmlldyByb3RhdGVzIGNsb2Nrd2lzZS5cbiAqICAgICBXaGVuIGByb2xsID4gMGAsIHRoZSB2aWV3IHJvdGF0ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gKlxuICogQHByb3BlcnR5IHtmb3Z9IGZvdiBUaGUgdmVydGljYWwgZmllbGQgb2YgdmlldywgaW4gdGhlIFswLCDPgF0gcmFuZ2UuXG4gKi9cblxuXG4vKipcbiAqIEBpbnRlcmZhY2UgUmVjdGlsaW5lYXJWaWV3Q29vcmRzXG4gKlxuICogVGhlIHBvc2l0aW9uIG9mIGEgcG9pbnQgaW4gYSAzNjDCsCBpbWFnZS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geWF3IFRoZSB5YXcgYW5nbGUsIGluIHRoZSBbLc+ALCDPgF0gcmFuZ2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl0Y2ggVGhlIHBpdGNoIGFuZ2xlLCBpbiB0aGUgWy3PgCwgz4BdIHJhbmdlLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFJlY3RpbGluZWFyVmlld0xpbWl0ZXJcbiAqXG4gKiBWaWV3IGxpbWl0ZXIgZm9yIGEge0BsaW5rIFJlY3RpbGluZWFyVmlld30uXG4gKlxuICogQSB2aWV3IGxpbWl0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEge0BsaW5rIFJlY3RpbGluZWFyVmlld1BhcmFtc31cbiAqIG9iamVjdCwgb3B0aW9uYWxseSBtb2RpZmllcyBpdCBpbiBwbGFjZSwgYW5kIHJldHVybnMgaXQuIEl0IGNhbiBiZSB1c2VkIHRvXG4gKiBlbmZvcmNlIGNvbnN0cmFpbnRzIG9uIHRoZSB2aWV3IHBhcmFtZXRlcnMuXG4gKlxuICogU2VlIHtAbGluayBSZWN0aWxpbmVhclZpZXcubGltaXR9IGZvciBjb21tb25seSB1c2VkIGxpbWl0ZXJzLiBUaGV5IG1heSBiZVxuICogY29tcG9zZWQgdG9nZXRoZXIgb3Igd2l0aCB1c2VyLWRlZmluZWQgbGltaXRlcnMgd2l0aCB7QGxpbmsgdXRpbC5jb21wb3NlfS5cbiAqXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld1BhcmFtc30gcGFyYW1zXG4gKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdQYXJhbXN9XG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgUmVjdGlsaW5lYXJWaWV3XG4gKiBAaW1wbGVtZW50cyBWaWV3XG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQSB7QGxpbmsgVmlld30gaW1wbGVtZW50aW5nIGEgcmVjdGlsaW5lYXIgcHJvamVjdGlvbiBmb3IgMzYwwrAgaW1hZ2VzLlxuICpcbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3UGFyYW1zPX0gcGFyYW1zIFRoZSBpbml0aWFsIHZpZXcgcGFyYW1ldGVycy4gSWZcbiAqICAgICB1bnNwZWNpZmllZCwgZGVmYXVsdHMgdG8gYHt5YXc6IDAsIHBpdGNoOiAwLCByb2xsOiAwLCBmb3Y6IE1hdGguUEkvNCB9YC5cbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcj19IGxpbWl0ZXIgVGhlIHZpZXcgbGltaXRlci4gSWYgdW5zcGVjaWZpZWQsXG4gKiAgICAgbm8gdmlldyBsaW1pdGluZyBpcyBhcHBsaWVkLiBTZWUge0BsaW5rIFJlY3RpbGluZWFyVmlldy5saW1pdH0gZm9yXG4gKiAgICAgY29tbW9ubHkgdXNlZCBsaW1pdGVycy5cbiAqL1xuZnVuY3Rpb24gUmVjdGlsaW5lYXJWaWV3KHBhcmFtcywgbGltaXRlcikge1xuICAvLyBUaGUgaW5pdGlhbCB2YWx1ZXMgZm9yIHRoZSB2aWV3IHBhcmFtZXRlcnMuXG4gIHRoaXMuX3lhdyA9IHBhcmFtcyAmJiBwYXJhbXMueWF3ICE9IG51bGwgPyBwYXJhbXMueWF3IDogZGVmYXVsdFlhdztcbiAgdGhpcy5fcGl0Y2ggPSBwYXJhbXMgJiYgcGFyYW1zLnBpdGNoICE9IG51bGwgPyBwYXJhbXMucGl0Y2ggOiBkZWZhdWx0UGl0Y2g7XG4gIHRoaXMuX3JvbGwgPSBwYXJhbXMgJiYgcGFyYW1zLnJvbGwgIT0gbnVsbCA/IHBhcmFtcy5yb2xsIDogZGVmYXVsdFJvbGw7XG4gIHRoaXMuX2ZvdiA9IHBhcmFtcyAmJiBwYXJhbXMuZm92ICE9IG51bGwgPyBwYXJhbXMuZm92IDogZGVmYXVsdEZvdjtcbiAgdGhpcy5fd2lkdGggPSBwYXJhbXMgJiYgcGFyYW1zLndpZHRoICE9IG51bGwgP1xuICAgIHBhcmFtcy53aWR0aCA6IGRlZmF1bHRXaWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gcGFyYW1zICYmIHBhcmFtcy5oZWlnaHQgIT0gbnVsbCA/XG4gICAgcGFyYW1zLmhlaWdodCA6IGRlZmF1bHRIZWlnaHQ7XG4gIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYID0gcGFyYW1zICYmIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCAhPSBudWxsID9cbiAgICBwYXJhbXMucHJvamVjdGlvbkNlbnRlclggOiBkZWZhdWx0UHJvamVjdGlvbkNlbnRlclg7XG4gIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZID0gcGFyYW1zICYmIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWSAhPSBudWxsID9cbiAgICBwYXJhbXMucHJvamVjdGlvbkNlbnRlclkgOiBkZWZhdWx0UHJvamVjdGlvbkNlbnRlclk7XG5cbiAgLy8gQSAzRCB0cmFuc2xhdGlvbiBvZiB0aGUgdmlld3BvaW50LlxuICB0aGlzLl90eCA9IHBhcmFtcyAmJiBwYXJhbXMudHggIT0gbnVsbCA/IHBhcmFtcy50eCA6IGRlZmF1bHRUeDtcbiAgdGhpcy5fdHkgPSBwYXJhbXMgJiYgcGFyYW1zLnR5ICE9IG51bGwgPyBwYXJhbXMudHkgOiBkZWZhdWx0VHk7XG4gIHRoaXMuX3R6ID0gcGFyYW1zICYmIHBhcmFtcy50eiAhPSBudWxsID8gcGFyYW1zLnR6IDogZGVmYXVsdFR6O1xuXG4gIC8vIEFuIGFkZGl0aW9uYWwgM0QgdHJhbnNsYXRpb24gb2Zmc2V0IG9mIHRoZSB2aWV3cG9pbnQuIFxuICAvLyBCdXQgdGhlIHZpZXdpbmcgcm90YXRpb24gd2lsbCBiZSBzdGlsbCBmcm9tIHRoZSBub24tb2Zmc2V0IHBvaW50LlxuICB0aGlzLl9veCA9IHBhcmFtcyAmJiBwYXJhbXMub3ggIT0gbnVsbCA/IHBhcmFtcy5veCA6IGRlZmF1bHRPeDtcbiAgdGhpcy5fb3kgPSBwYXJhbXMgJiYgcGFyYW1zLm95ICE9IG51bGwgPyBwYXJhbXMub3kgOiBkZWZhdWx0T3k7XG4gIHRoaXMuX296ID0gcGFyYW1zICYmIHBhcmFtcy5veiAhPSBudWxsID8gcGFyYW1zLm96IDogZGVmYXVsdE96O1xuXG4gIC8vIEludmVydCBjb250cm9sLlxuICB0aGlzLl9pbnZlcnRDb250cm9sID0gcGFyYW1zICYmIHBhcmFtcy5pbnZlcnRDb250cm9sICE9IG51bGwgPyBwYXJhbXMuaW52ZXJ0Q29udHJvbCA6IGZhbHNlO1xuXG4gIC8vIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgdmlldyBsaW1pdGVyLlxuICB0aGlzLl9saW1pdGVyID0gbGltaXRlciB8fCBudWxsO1xuXG4gIC8vIFRoZSBsYXN0IGNhbGN1bGF0ZWQgcHJvamVjdGlvbiBtYXRyaXggYW5kIGl0cyBpbnZlcnNlLlxuICB0aGlzLl9wcm9qTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgdGhpcy5faW52UHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gVGhlIGxhc3QgY2FsY3VsYXRlZCB2aWV3IG1hdHJpeCBhbmQgaXRzIGludmVyc2UuXG4gIHRoaXMuX3ZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICB0aGlzLl9pbnZWaWV3TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBUaGUgbGFzdCBjYWxjdWxhdGVkIHZpZXcgZnJ1c3R1bS5cbiAgdGhpcy5fZnJ1c3R1bSA9IFtcbiAgICB2ZWM0LmNyZWF0ZSgpLCAvLyBsZWZ0XG4gICAgdmVjNC5jcmVhdGUoKSwgLy8gcmlnaHRcbiAgICB2ZWM0LmNyZWF0ZSgpLCAvLyBib3R0b21cbiAgICB2ZWM0LmNyZWF0ZSgpLCAvLyB0b3BcbiAgICB2ZWM0LmNyZWF0ZSgpICAvLyBjYW1lcmFcbiAgXTtcblxuICAvLyBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIG1hdHJpY2VzIGFuZCB0aGUgdmlldyBmcnVzdHVtIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgdGhpcy5fbWF0cml4Q2hhbmdlZCA9IHRydWU7XG5cbiAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlcyB1c2VkIGZvciBjYWxjdWxhdGlvbnMuXG4gIHRoaXMuX3BhcmFtcyA9IHt9O1xuICB0aGlzLl9mb3ZzID0ge307XG4gIHRoaXMuX3RtcFZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgLy8gRm9yY2UgdmlldyBsaW1pdGluZyBvbiBpbml0aWFsIHBhcmFtZXRlcnMuXG4gIHRoaXMuX3VwZGF0ZSgpO1xufVxuXG5ldmVudEVtaXR0ZXIoUmVjdGlsaW5lYXJWaWV3KTtcblxuXG4vKipcbiAqIERlc3RydWN0b3IuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhck93blByb3BlcnRpZXModGhpcyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB5YXcgYW5nbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUueWF3ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl95YXc7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBwaXRjaCBhbmdsZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5waXRjaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGl0Y2g7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSByb2xsIGFuZ2xlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnJvbGwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JvbGw7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUucHJvamVjdGlvbkNlbnRlclggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnByb2plY3Rpb25DZW50ZXJZID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wcm9qZWN0aW9uQ2VudGVyWTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmb3YgdmFsdWUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuZm92ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9mb3Y7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9ydCB3aWR0aC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fd2lkdGg7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9ydCBoZWlnaHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmlld3BvaW50J3MgdHguXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUudHggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3R4O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb2ludCdzIHR5LlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl90eTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9pbnQncyB0ei5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS50eiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdHo7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmlld3BvaW50J3Mgb3guXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUub3ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX294O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZpZXdwb2ludCdzIG95LlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm95ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9veTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9pbnQncyB0ei5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5veiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fb3o7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW52ZXJ0IGNvbnRyb2wgZmxhZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuaW52ZXJ0Q29udHJvbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW52ZXJ0Q29udHJvbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zLiBJZiBhbiBhcmd1bWVudCBpcyBzdXBwbGllZCwgaXQgaXMgZmlsbGVkIGluIHdpdGhcbiAqIHRoZSByZXN1bHQgYW5kIHJldHVybmVkLiBPdGhlcndpc2UsIGEgZnJlc2ggb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1NpemU9fSBzaXplXG4gKiBAcmV0dXJuIHtTaXplfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHNpemUgPSBzaXplIHx8IHt9O1xuICBzaXplLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICByZXR1cm4gc2l6ZTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXcgcGFyYW1ldGVycy4gSWYgYW4gYXJndW1lbnQgaXMgc3VwcGxpZWQsIGl0IGlzIGZpbGxlZCBpbiB3aXRoIHRoZVxuICogcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWQgaW4gYW5kIHJldHVybmVkLlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdQYXJhbXM9fSBvYmpcbiAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld1BhcmFtc31cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgcGFyYW1zLnlhdyA9IHRoaXMuX3lhdztcbiAgcGFyYW1zLnBpdGNoID0gdGhpcy5fcGl0Y2g7XG4gIHBhcmFtcy5yb2xsID0gdGhpcy5fcm9sbDtcbiAgcGFyYW1zLmZvdiA9IHRoaXMuX2ZvdjtcbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIHZpZXcgbGltaXRlciwgb3IgbnVsbCBpZiB1bnNldC5cbiAqIEByZXR1cm4gez9SZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLmxpbWl0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpbWl0ZXI7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSB5YXcgYW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0geWF3XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0WWF3ID0gZnVuY3Rpb24oeWF3KSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy55YXcgPSB5YXc7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgcGl0Y2ggYW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl0Y2hcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRQaXRjaCA9IGZ1bmN0aW9uKHBpdGNoKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy5waXRjaCA9IHBpdGNoO1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHJvbGwgYW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcm9sbFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFJvbGwgPSBmdW5jdGlvbihyb2xsKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy5yb2xsID0gcm9sbDtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBmb3YgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gZm92XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0Rm92ID0gZnVuY3Rpb24oZm92KSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy5mb3YgPSBmb3Y7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFByb2plY3Rpb25DZW50ZXJYID0gZnVuY3Rpb24ocHJvamVjdGlvbkNlbnRlclgpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYID0gcHJvamVjdGlvbkNlbnRlclg7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFByb2plY3Rpb25DZW50ZXJZID0gZnVuY3Rpb24ocHJvamVjdGlvbkNlbnRlclkpIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZID0gcHJvamVjdGlvbkNlbnRlclk7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIEFkZCB5YXdPZmZzZXQgdG8gdGhlIGN1cnJlbnQgeWF3IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHlhd09mZnNldFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm9mZnNldFlhdyA9IGZ1bmN0aW9uKHlhd09mZnNldCkge1xuICB0aGlzLnNldFlhdyh0aGlzLl95YXcgKyB5YXdPZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIEFkZCBwaXRjaE9mZnNldCB0byB0aGUgY3VycmVudCBwaXRjaCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXRjaE9mZnNldFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm9mZnNldFBpdGNoID0gZnVuY3Rpb24ocGl0Y2hPZmZzZXQpIHtcbiAgdGhpcy5zZXRQaXRjaCh0aGlzLl9waXRjaCArIHBpdGNoT2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBBZGQgcm9sbE9mZnNldCB0byB0aGUgY3VycmVudCByb2xsIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvbGxPZmZzZXRcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5vZmZzZXRSb2xsID0gZnVuY3Rpb24ocm9sbE9mZnNldCkge1xuICB0aGlzLnNldFJvbGwodGhpcy5fcm9sbCArIHJvbGxPZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIEFkZCBmb3ZPZmZzZXQgdG8gdGhlIGN1cnJlbnQgZm92IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZvdk9mZnNldFxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm9mZnNldEZvdiA9IGZ1bmN0aW9uKGZvdk9mZnNldCkge1xuICB0aGlzLnNldEZvdih0aGlzLl9mb3YgKyBmb3ZPZmZzZXQpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmlld3BvcnQgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy53aWR0aCA9IHNpemUud2lkdGg7XG4gIHRoaXMuX3BhcmFtcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmlld3BvaW50J3MgdHguXG4gKiBAcGFyYW0ge251bWJlcn0gdHhcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRUeCA9IGZ1bmN0aW9uKHR4KSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy50eCA9IHR4O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXdwb2ludCdzIHR5LlxuICogQHBhcmFtIHtudW1iZXJ9IHR5XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0VHkgPSBmdW5jdGlvbih0eSkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMudHkgPSB0eTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSB2aWV3cG9pbnQncyB0ei5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0elxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldFR6ID0gZnVuY3Rpb24odHopIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLnR6ID0gdHo7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdmlld3BvaW50J3Mgb3guXG4gKiBAcGFyYW0ge251bWJlcn0gdHhcbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zZXRPeCA9IGZ1bmN0aW9uKG94KSB7XG4gIHRoaXMuX3Jlc2V0UGFyYW1zKCk7XG4gIHRoaXMuX3BhcmFtcy5veCA9IG94O1xuICB0aGlzLl91cGRhdGUodGhpcy5fcGFyYW1zKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZpZXdwb2ludCdzIG95LlxuICogQHBhcmFtIHtudW1iZXJ9IG95XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0T3kgPSBmdW5jdGlvbihveSkge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMub3kgPSBveTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuX3BhcmFtcyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSB2aWV3cG9pbnQncyBvei5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvelxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnNldE96ID0gZnVuY3Rpb24ob3opIHtcbiAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgdGhpcy5fcGFyYW1zLm96ID0gb3o7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgaW52ZXJ0IGNvbnRyb2wgZmxhZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0SW52ZXJ0Q29udHJvbCA9IGZ1bmN0aW9uKGludmVydENvbnRyb2wpIHtcbiAgdGhpcy5faW52ZXJ0Q29udHJvbCA9IGludmVydENvbnRyb2w7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmlldyBwYXJhbWV0ZXJzLiBVbnNwZWNpZmllZCBwYXJhbWV0ZXJzIGFyZSBsZWZ0IHVuY2hhbmdlZC5cbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3UGFyYW1ldGVyc30gcGFyYW1zXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB0aGlzLl9yZXNldFBhcmFtcygpO1xuICB0aGlzLl9wYXJhbXMueWF3ID0gcGFyYW1zLnlhdztcbiAgdGhpcy5fcGFyYW1zLnBpdGNoID0gcGFyYW1zLnBpdGNoO1xuICB0aGlzLl9wYXJhbXMucm9sbCA9IHBhcmFtcy5yb2xsO1xuICB0aGlzLl9wYXJhbXMuZm92ID0gcGFyYW1zLmZvdjtcbiAgdGhpcy5fcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYO1xuICB0aGlzLl9wYXJhbXMucHJvamVjdGlvbkNlbnRlclkgPSBwYXJhbXMucHJvamVjdGlvbkNlbnRlclk7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9wYXJhbXMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgdmlldyBsaW1pdGVyLlxuICogQHBhcmFtIHs/UmVjdGlsaW5lYXJWaWV3TGltaXRlcn0gbGltaXRlciBUaGUgbmV3IGxpbWl0ZXIsIG9yIG51bGwgdG8gdW5zZXQuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2V0TGltaXRlciA9IGZ1bmN0aW9uKGxpbWl0ZXIpIHtcbiAgdGhpcy5fbGltaXRlciA9IGxpbWl0ZXIgfHwgbnVsbDtcbiAgdGhpcy5fdXBkYXRlKCk7XG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuX3Jlc2V0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIHBhcmFtcy55YXcgPSBudWxsO1xuICBwYXJhbXMucGl0Y2ggPSBudWxsO1xuICBwYXJhbXMucm9sbCA9IG51bGw7XG4gIHBhcmFtcy5mb3YgPSBudWxsO1xuICBwYXJhbXMud2lkdGggPSBudWxsO1xuICBwYXJhbXMuaGVpZ2h0ID0gbnVsbDtcbiAgcGFyYW1zLnBvc2l0aW9uID0gbnVsbDtcbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgLy8gQXZvaWQgb2JqZWN0IGFsbG9jYXRpb24gd2hlbiBubyBwYXJhbWV0ZXJzIGFyZSBzdXBwbGllZC5cbiAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgdGhpcy5fcmVzZXRQYXJhbXMoKTtcbiAgICBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gIH1cblxuICAvLyBTYXZlIG9sZCBwYXJhbWV0ZXJzIGZvciBsYXRlciBjb21wYXJpc29uLlxuICB2YXIgb2xkWWF3ID0gdGhpcy5feWF3O1xuICB2YXIgb2xkUGl0Y2ggPSB0aGlzLl9waXRjaDtcbiAgdmFyIG9sZFJvbGwgPSB0aGlzLl9yb2xsO1xuICB2YXIgb2xkRm92ID0gdGhpcy5fZm92O1xuICB2YXIgb2xkUHJvamVjdGlvbkNlbnRlclggPSB0aGlzLl9wcm9qZWN0aW9uQ2VudGVyWDtcbiAgdmFyIG9sZFByb2plY3Rpb25DZW50ZXJZID0gdGhpcy5fcHJvamVjdGlvbkNlbnRlclk7XG4gIHZhciBvbGRXaWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICBcbiAgdmFyIG9sZFR4ID0gdGhpcy5fdHg7XG4gIHZhciBvbGRUeSA9IHRoaXMuX3R5O1xuICB2YXIgb2xkVHogPSB0aGlzLl90ejtcbiAgdmFyIG9sZE94ID0gdGhpcy5fb3g7XG4gIHZhciBvbGRPeSA9IHRoaXMuX295O1xuICB2YXIgb2xkT3ogPSB0aGlzLl9vejtcblxuICAvLyBGaWxsIGluIG9iamVjdCB3aXRoIHRoZSBuZXcgc2V0IG9mIHBhcmFtZXRlcnMgdG8gcGFzcyBpbnRvIHRoZSBsaW1pdGVyLlxuICBwYXJhbXMueWF3ID0gcGFyYW1zLnlhdyAhPSBudWxsID8gcGFyYW1zLnlhdyA6IG9sZFlhdztcbiAgcGFyYW1zLnBpdGNoID0gcGFyYW1zLnBpdGNoICE9IG51bGwgPyBwYXJhbXMucGl0Y2ggOiBvbGRQaXRjaDtcbiAgcGFyYW1zLnJvbGwgPSBwYXJhbXMucm9sbCAhPSBudWxsID8gcGFyYW1zLnJvbGwgOiBvbGRSb2xsO1xuICBwYXJhbXMuZm92ID0gcGFyYW1zLmZvdiAhPSBudWxsID8gcGFyYW1zLmZvdiA6IG9sZEZvdjtcbiAgcGFyYW1zLndpZHRoID0gcGFyYW1zLndpZHRoICE9IG51bGwgPyBwYXJhbXMud2lkdGggOiBvbGRXaWR0aDtcbiAgcGFyYW1zLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgIT0gbnVsbCA/IHBhcmFtcy5oZWlnaHQgOiBvbGRIZWlnaHQ7XG4gIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCA9IHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWCAhPSBudWxsID9cbiAgICBwYXJhbXMucHJvamVjdGlvbkNlbnRlclggOiBvbGRQcm9qZWN0aW9uQ2VudGVyWDtcbiAgcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJZICE9IG51bGwgP1xuICAgIHBhcmFtcy5wcm9qZWN0aW9uQ2VudGVyWSA6IG9sZFByb2plY3Rpb25DZW50ZXJZO1xuXG4gIHBhcmFtcy50eCA9IHBhcmFtcy50eCAhPSBudWxsID8gcGFyYW1zLnR4IDogb2xkVHg7XG4gIHBhcmFtcy50eSA9IHBhcmFtcy50eSAhPSBudWxsID8gcGFyYW1zLnR5IDogb2xkVHk7XG4gIHBhcmFtcy50eiA9IHBhcmFtcy50eiAhPSBudWxsID8gcGFyYW1zLnR6IDogb2xkVHo7XG4gIHBhcmFtcy5veCA9IHBhcmFtcy5veCAhPSBudWxsID8gcGFyYW1zLm94IDogb2xkT3g7XG4gIHBhcmFtcy5veSA9IHBhcmFtcy5veSAhPSBudWxsID8gcGFyYW1zLm95IDogb2xkT3k7XG4gIHBhcmFtcy5veiA9IHBhcmFtcy5veiAhPSBudWxsID8gcGFyYW1zLm96IDogb2xkT3o7XG5cbiAgLy8gQXBwbHkgdmlldyBsaW1pdGluZyB3aGVuIGRlZmluZWQuXG4gIGlmICh0aGlzLl9saW1pdGVyKSB7XG4gICAgcGFyYW1zID0gdGhpcy5fbGltaXRlcihwYXJhbXMpO1xuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCB2aWV3IGxpbWl0ZXInKTtcbiAgICB9XG4gIH1cblxuICAvLyBOb3JtYWxpemUgcGFyYW1ldGVycy5cbiAgcGFyYW1zID0gdGhpcy5fbm9ybWFsaXplKHBhcmFtcyk7XG5cbiAgLy8gR3JhYiB0aGUgbGltaXRlZCBwYXJhbWV0ZXJzLlxuICB2YXIgbmV3WWF3ID0gcGFyYW1zLnlhdztcbiAgdmFyIG5ld1BpdGNoID0gcGFyYW1zLnBpdGNoO1xuICB2YXIgbmV3Um9sbCA9IHBhcmFtcy5yb2xsO1xuICB2YXIgbmV3Rm92ID0gcGFyYW1zLmZvdjtcbiAgdmFyIG5ld1dpZHRoID0gcGFyYW1zLndpZHRoO1xuICB2YXIgbmV3SGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgdmFyIG5ld1Byb2plY3Rpb25DZW50ZXJYID0gcGFyYW1zLnByb2plY3Rpb25DZW50ZXJYO1xuICB2YXIgbmV3UHJvamVjdGlvbkNlbnRlclkgPSBwYXJhbXMucHJvamVjdGlvbkNlbnRlclk7XG5cbiAgdmFyIG5ld1R4ID0gcGFyYW1zLnR4O1xuICB2YXIgbmV3VHkgPSBwYXJhbXMudHk7XG4gIHZhciBuZXdUeiA9IHBhcmFtcy50ejtcbiAgdmFyIG5ld094ID0gcGFyYW1zLm94O1xuICB2YXIgbmV3T3kgPSBwYXJhbXMub3k7XG4gIHZhciBuZXdPeiA9IHBhcmFtcy5vejtcblxuICAvLyBDb25zaXN0ZW5jeSBjaGVjay5cbiAgaWYgKCFyZWFsKG5ld1lhdykgfHwgIXJlYWwobmV3UGl0Y2gpIHx8ICFyZWFsKG5ld1JvbGwpIHx8XG4gICAgICAhcmVhbChuZXdGb3YpIHx8ICFyZWFsKG5ld1dpZHRoKSB8fCAhcmVhbChuZXdIZWlnaHQpIHx8XG4gICAgICAhcmVhbChuZXdQcm9qZWN0aW9uQ2VudGVyWCkgfHwgIXJlYWwobmV3UHJvamVjdGlvbkNlbnRlclkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgdmlldyAtIHN1c3BlY3QgYSBicm9rZW4gbGltaXRlcicpO1xuICB9XG5cbiAgLy8gVXBkYXRlIHBhcmFtZXRlcnMuXG4gIHRoaXMuX3lhdyA9IG5ld1lhdztcbiAgdGhpcy5fcGl0Y2ggPSBuZXdQaXRjaDtcbiAgdGhpcy5fcm9sbCA9IG5ld1JvbGw7XG4gIHRoaXMuX2ZvdiA9IG5ld0ZvdjtcbiAgdGhpcy5fd2lkdGggPSBuZXdXaWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICB0aGlzLl9wcm9qZWN0aW9uQ2VudGVyWCA9IG5ld1Byb2plY3Rpb25DZW50ZXJYO1xuICB0aGlzLl9wcm9qZWN0aW9uQ2VudGVyWSA9IG5ld1Byb2plY3Rpb25DZW50ZXJZO1xuICBcbiAgdGhpcy5fdHggPSBuZXdUeDtcbiAgdGhpcy5fdHkgPSBuZXdUeTtcbiAgdGhpcy5fdHogPSBuZXdUejtcbiAgdGhpcy5fb3ggPSBuZXdPeDtcbiAgdGhpcy5fb3kgPSBuZXdPeTtcbiAgdGhpcy5fb3ogPSBuZXdPejtcblxuICAvLyBDaGVjayB3aGV0aGVyIHRoZSBwYXJhbWV0ZXJzIGNoYW5nZWQgYW5kIGVtaXQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzLlxuICBpZiAobmV3WWF3ICE9PSBvbGRZYXcgfHwgbmV3UGl0Y2ggIT09IG9sZFBpdGNoIHx8IG5ld1JvbGwgIT09IG9sZFJvbGwgfHxcbiAgICAgIG5ld0ZvdiAhPT0gb2xkRm92IHx8IG5ld1dpZHRoICE9PSBvbGRXaWR0aCB8fCBuZXdIZWlnaHQgIT09IG9sZEhlaWdodCB8fFxuICAgICAgbmV3UHJvamVjdGlvbkNlbnRlclggIT09IG9sZFByb2plY3Rpb25DZW50ZXJYIHx8XG4gICAgICBuZXdQcm9qZWN0aW9uQ2VudGVyWSAhPT0gb2xkUHJvamVjdGlvbkNlbnRlclkgfHxcbiAgICAgIG5ld1R4ICE9PSBvbGRUeCB8fCBuZXdUeSAhPT0gb2xkVHkgfHwgbmV3VHogIT09IG9sZFR6IHx8XG4gICAgICBuZXdPeCAhPT0gb2xkT3ggfHwgbmV3T3kgIT09IG9sZE95IHx8IG5ld096ICE9PSBvbGRPeikge1xuICAgIHRoaXMuX21hdHJpeENoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIH1cbiAgaWYgKG5ld1dpZHRoICE9PSBvbGRXaWR0aCB8fCBuZXdIZWlnaHQgIT09IG9sZEhlaWdodCkge1xuICAgIHRoaXMuZW1pdCgncmVzaXplJyk7XG4gIH1cbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5fbm9ybWFsaXplID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cbiAgdGhpcy5fbm9ybWFsaXplQ29vcmRpbmF0ZXMocGFyYW1zKTtcblxuICAvLyBNYWtlIHN1cmUgdGhhdCBuZWl0aGVyIHRoZSBob3Jpem9udGFsIG5vciB0aGUgdmVydGljYWwgZmllbGRzIG9mIHZpZXdcbiAgLy8gZXhjZWVkIM+AIC0gZm92TGltaXRFcHNpbG9uLlxuICB2YXIgaGZvdlBpID0gY29udmVydEZvdi5odG92KE1hdGguUEksIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gIHZhciBtYXhGb3YgPSBpc05hTihoZm92UGkpID8gTWF0aC5QSSA6IE1hdGgubWluKE1hdGguUEksIGhmb3ZQaSk7XG4gIHBhcmFtcy5mb3YgPSBjbGFtcChwYXJhbXMuZm92LCBmb3ZMaW1pdEVwc2lsb24sIG1heEZvdiAtIGZvdkxpbWl0RXBzaWxvbik7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5fbm9ybWFsaXplQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgLy8gQ29uc3RyYWluIHlhdywgcGl0Y2ggYW5kIHJvbGwgdG8gdGhlIFstz4AsIM+AXSBpbnRlcnZhbC5cbiAgaWYgKCd5YXcnIGluIHBhcmFtcykge1xuICAgIHBhcmFtcy55YXcgPSBtb2QocGFyYW1zLnlhdyAtIE1hdGguUEksIC0yKk1hdGguUEkpICsgTWF0aC5QSTtcbiAgfVxuICBpZiAoJ3BpdGNoJyBpbiBwYXJhbXMpIHtcbiAgICBwYXJhbXMucGl0Y2ggPSBtb2QocGFyYW1zLnBpdGNoIC0gTWF0aC5QSSwgLTIqTWF0aC5QSSkgKyBNYXRoLlBJO1xuICB9XG4gIGlmICgncm9sbCcgaW4gcGFyYW1zKSB7XG4gICAgcGFyYW1zLnJvbGwgPSBtb2QocGFyYW1zLnJvbGwgLSBNYXRoLlBJLCAtMipNYXRoLlBJKSArIE1hdGguUEk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cblxuLyoqXG4gKiBOb3JtYWxpemUgdmlldyBjb29yZGluYXRlcyBzbyB0aGF0IHRoZXkgYXJlIHRoZSBjbG9zZXN0IHRvIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBVc2VmdWwgZm9yIHR3ZWVuaW5nIHRoZSB2aWV3IHRocm91Z2ggdGhlIHNob3J0ZXN0IHBhdGguIElmIGEgcmVzdWx0IGFyZ3VtZW50XG4gKiBpcyBzdXBwbGllZCwgaXQgaXMgZmlsbGVkIGluIHdpdGggdGhlIHJlc3VsdCBhbmQgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBmcmVzaFxuICogb2JqZWN0IGlzIGZpbGxlZCBpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdDb29yZHN9IGNvb3JkcyBUaGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7UmVjdGlsaW5lYXJWaWV3Q29vcmRzfSByZXN1bHQgVGhlIHJlc3VsdCBhcmd1bWVudCBmb3IgdGhlIG5vcm1hbGl6ZWRcbiAqICAgICB2aWV3IGNvb3JkaW5hdGVzLlxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLm5vcm1hbGl6ZVRvQ2xvc2VzdCA9IGZ1bmN0aW9uKGNvb3JkcywgcmVzdWx0KSB7XG5cbiAgdmFyIHZpZXdZYXcgPSB0aGlzLl95YXc7XG4gIHZhciB2aWV3UGl0Y2ggPSB0aGlzLl9waXRjaDtcblxuICB2YXIgY29vcmRZYXcgPSBjb29yZHMueWF3O1xuICB2YXIgY29vcmRQaXRjaCA9IGNvb3Jkcy5waXRjaDtcblxuICAvLyBDaGVjayBpZiB0aGUgeWF3IGlzIGNsb3NlciBhZnRlciBzdWJ0cmFjdGluZyBvciBhZGRpbmcgYSBmdWxsIGNpcmNsZS5cbiAgdmFyIHByZXZZYXcgPSBjb29yZFlhdyAtIDIqTWF0aC5QSTtcbiAgdmFyIG5leHRZYXcgPSBjb29yZFlhdyArIDIqTWF0aC5QSTtcbiAgaWYgKE1hdGguYWJzKHByZXZZYXcgLSB2aWV3WWF3KSA8IE1hdGguYWJzKGNvb3JkWWF3IC0gdmlld1lhdykpIHtcbiAgICBjb29yZFlhdyA9IHByZXZZYXc7XG4gIH1cbiAgZWxzZSBpZiAoTWF0aC5hYnMobmV4dFlhdyAtIHZpZXdZYXcpIDwgTWF0aC5hYnMoY29vcmRZYXcgLSB2aWV3WWF3KSkge1xuICAgIGNvb3JkWWF3ID0gbmV4dFlhdztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBwaXRjaCBpcyBjbG9zZXIgYWZ0ZXIgc3VidHJhY3Rpbmcgb3IgYWRkaW5nIGEgZnVsbCBjaXJjbGUuXG4gIHZhciBwcmV2UGl0Y2ggPSBjb29yZFBpdGNoIC0gMipNYXRoLlBJO1xuICB2YXIgbmV4dFBpdGNoID0gY29vcmRQaXRjaCArIDIqTWF0aC5QSTtcbiAgaWYgKE1hdGguYWJzKHByZXZQaXRjaCAtIHZpZXdQaXRjaCkgPCBNYXRoLmFicyhjb29yZFBpdGNoIC0gdmlld1BpdGNoKSkge1xuICAgIGNvb3JkUGl0Y2ggPSBwcmV2UGl0Y2g7XG4gIH1cbiAgZWxzZSBpZiAoTWF0aC5hYnMocHJldlBpdGNoIC0gdmlld1BpdGNoKSA8IE1hdGguYWJzKGNvb3JkUGl0Y2ggLSB2aWV3UGl0Y2gpKSB7XG4gICAgY29vcmRQaXRjaCA9IG5leHRQaXRjaDtcbiAgfVxuXG4gIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcbiAgcmVzdWx0LnlhdyA9IGNvb3JkWWF3O1xuICByZXN1bHQucGl0Y2ggPSBjb29yZFBpdGNoO1xuICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG5cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUudXBkYXRlV2l0aENvbnRyb2xQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICAvLyBheGlzU2NhbGVkWCBhbmQgYXhpc1NjYWxlZFkgYXJlIHNjYWxlZCBhY2NvcmRpbmcgdG8gdGhlaXIgb3duIGF4aXNcbiAgLy8geCBhbmQgeSBhcmUgc2NhbGVkIGJ5IHRoZSBzYW1lIHZhbHVlXG5cbiAgLy8gSWYgdGhlIHZpZXdwb3J0IGRpbWVuc2lvbnMgYXJlIHplcm8sIGFzc3VtZSBhIHNxdWFyZSB2aWV3cG9ydFxuICAvLyB3aGVuIGNvbnZlcnRpbmcgZnJvbSBoZm92IHRvIHZmb3YuXG4gIHZhciB2Zm92ID0gdGhpcy5fZm92O1xuICB2YXIgaGZvdiA9IGNvbnZlcnRGb3YudnRvaCh2Zm92LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgaWYgKGlzTmFOKGhmb3YpKSB7XG4gICAgaGZvdiA9IHZmb3Y7XG4gIH1cblxuICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgYWZ0ZXIgd2UgcmV0aGluayB0aGUgY29udHJvbCBwYXJhbWV0ZXJzLlxuICB0aGlzLm9mZnNldFlhdyhwYXJhbWV0ZXJzLmF4aXNTY2FsZWRYICogaGZvdiArIHBhcmFtZXRlcnMueCAqIDIgKiBoZm92ICsgcGFyYW1ldGVycy55YXcpO1xuICB0aGlzLm9mZnNldFBpdGNoKHBhcmFtZXRlcnMuYXhpc1NjYWxlZFkgKiB2Zm92ICsgcGFyYW1ldGVycy55ICogMiAqIGhmb3YgKyBwYXJhbWV0ZXJzLnBpdGNoKTtcbiAgdGhpcy5vZmZzZXRSb2xsKC1wYXJhbWV0ZXJzLnJvbGwpO1xuICB0aGlzLm9mZnNldEZvdihwYXJhbWV0ZXJzLnpvb20gKiB2Zm92KTtcbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5fdXBkYXRlTWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwcm9qTWF0cml4ID0gdGhpcy5fcHJvak1hdHJpeDtcbiAgdmFyIGludlByb2pNYXRyaXggPSB0aGlzLl9pbnZQcm9qTWF0cml4O1xuICB2YXIgdmlld01hdHJpeCA9IHRoaXMuX3ZpZXdNYXRyaXg7XG4gIHZhciBpbnZWaWV3TWF0cml4ID0gdGhpcy5faW52Vmlld01hdHJpeDtcbiAgdmFyIGZydXN0dW0gPSB0aGlzLl9mcnVzdHVtO1xuXG4gIGlmICh0aGlzLl9tYXRyaXhDaGFuZ2VkKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAgIHZhciB2Zm92ID0gdGhpcy5fZm92O1xuICAgIHZhciBoZm92ID0gY29udmVydEZvdi52dG9oKHZmb3YsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcblxuICAgIHZhciBwcm9qZWN0aW9uQ2VudGVyWCA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJYO1xuICAgIHZhciBwcm9qZWN0aW9uQ2VudGVyWSA9IHRoaXMuX3Byb2plY3Rpb25DZW50ZXJZO1xuXG4gICAgLy8gUHJvamVjdGlvbiBNYXRyaXguXG4gICAgaWYgKHByb2plY3Rpb25DZW50ZXJYICE9PSAwIHx8IHByb2plY3Rpb25DZW50ZXJZICE9PSAwKSB7XG4gICAgICB2YXIgb2Zmc2V0QW5nbGVYID0gTWF0aC5hdGFuKHByb2plY3Rpb25DZW50ZXJYICogMiAqIE1hdGgudGFuKGhmb3YvMikpO1xuICAgICAgdmFyIG9mZnNldEFuZ2xlWSA9IE1hdGguYXRhbihwcm9qZWN0aW9uQ2VudGVyWSAqIDIgKiBNYXRoLnRhbih2Zm92LzIpKTtcbiAgICAgIHZhciBmb3ZzID0gdGhpcy5fZm92cztcbiAgICAgIGZvdnMubGVmdERlZ3JlZXMgPSAoaGZvdi8yICsgb2Zmc2V0QW5nbGVYKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy5yaWdodERlZ3JlZXMgPSAoaGZvdi8yIC0gb2Zmc2V0QW5nbGVYKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy51cERlZ3JlZXMgPSAodmZvdi8yICsgb2Zmc2V0QW5nbGVZKSAqIDE4MC9NYXRoLlBJO1xuICAgICAgZm92cy5kb3duRGVncmVlcyA9ICh2Zm92LzIgLSBvZmZzZXRBbmdsZVkpICogMTgwL01hdGguUEk7XG4gICAgICBtYXQ0LnBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KHByb2pNYXRyaXgsIGZvdnMsIC0xLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0NC5wZXJzcGVjdGl2ZShwcm9qTWF0cml4LCB2Zm92LCBhc3BlY3QsIC0xLCAxKTtcbiAgICB9XG5cbiAgICBtYXQ0LmludmVydChpbnZQcm9qTWF0cml4LCBwcm9qTWF0cml4KTtcblxuICAgIC8vIFZpZXcgTWF0cml4LlxuICAgIG1hdDQuaWRlbnRpdHkodmlld01hdHJpeCk7XG4gICAgbWF0NC50cmFuc2xhdGUodmlld01hdHJpeCwgdmlld01hdHJpeCwgdmVjMy5uZWdhdGUodmVjMy5jcmVhdGUoKSwgW3RoaXMuX294LCB0aGlzLl9veSwgdGhpcy5fb3pdKSk7XG5cbiAgICAvLyBJbnZlcnQgY29udHJvbC5cbiAgICB2YXIgcm9sbCA9IHRoaXMuX2ludmVydENvbnRyb2wgPyAtdGhpcy5fcm9sbCA6IHRoaXMuX3JvbGw7XG4gICAgdmFyIHBpdGNoID0gdGhpcy5faW52ZXJ0Q29udHJvbCA/IC10aGlzLl9waXRjaCA6dGhpcy5fcGl0Y2g7XG4gICAgdmFyIHlhdyA9IHRoaXMuX2ludmVydENvbnRyb2wgPyAtdGhpcy5feWF3IDogdGhpcy5feWF3O1xuICAgIG1hdDQucm90YXRlWih2aWV3TWF0cml4LCB2aWV3TWF0cml4LCByb2xsKTtcbiAgICBtYXQ0LnJvdGF0ZVgodmlld01hdHJpeCwgdmlld01hdHJpeCwgcGl0Y2gpO1xuICAgIG1hdDQucm90YXRlWSh2aWV3TWF0cml4LCB2aWV3TWF0cml4LCB5YXcpO1xuXG4gICAgbWF0NC50cmFuc2xhdGUodmlld01hdHJpeCwgdmlld01hdHJpeCwgdmVjMy5uZWdhdGUodmVjMy5jcmVhdGUoKSwgW3RoaXMuX3R4LCB0aGlzLl90eSwgdGhpcy5fdHpdKSk7XG5cbiAgICBtYXQ0LmludmVydChpbnZWaWV3TWF0cml4LCB2aWV3TWF0cml4KTtcblxuICAgIC8vIEdldCB0aGUgZnJ1c3R1bSBwbGFuZXMuXG4gICAgdmFyIG1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgbWF0NC5tdWx0aXBseShtYXRyaXgsIHByb2pNYXRyaXgsIHZpZXdNYXRyaXgpO1xuICAgIHRoaXMuX21hdHJpeFRvRnJ1c3R1bShtYXRyaXgsIGZydXN0dW0pO1xuXG4gICAgdGhpcy5fbWF0cml4Q2hhbmdlZCA9IGZhbHNlO1xuICB9XG59O1xuXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLl9tYXRyaXhUb0ZydXN0dW0gPSBmdW5jdGlvbihwLCBmKSB7XG4gIC8vIEV4dHJhY3QgZnJ1c3R1bSBwbGFuZXMgZnJvbSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgLy8gaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTEvSFQxMi9sYWIvcGxhbmVfZXh0cmFjdGlvbi5wZGZcbiAgdmVjNC5zZXQoZlswXSwgcFszXSArIHBbMF0sIHBbN10gKyBwWzRdLCBwWzExXSArIHBbOF0sIHBbMTVdICsgcFsxMl0pOyAvLyBsZWZ0XG4gIHZlYzQuc2V0KGZbMV0sIHBbM10gLSBwWzBdLCBwWzddIC0gcFs0XSwgcFsxMV0gLSBwWzhdLCBwWzE1XSAtIHBbMTJdKTsgLy8gcmlnaHRcbiAgdmVjNC5zZXQoZlsyXSwgcFszXSArIHBbMV0sIHBbN10gKyBwWzVdLCBwWzExXSArIHBbOV0sIHBbMTVdICsgcFsxM10pOyAvLyB0b3BcbiAgdmVjNC5zZXQoZlszXSwgcFszXSAtIHBbMV0sIHBbN10gLSBwWzVdLCBwWzExXSAtIHBbOV0sIHBbMTVdIC0gcFsxM10pOyAvLyBib3R0b21cbiAgdmVjNC5zZXQoZls0XSwgcFszXSArIHBbMl0sIHBbN10gKyBwWzZdLCBwWzExXSArIHBbMTBdLCBwWzE1XSArIHBbMTRdKTsgLy8gY2FtZXJhXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGUgY3VycmVudCB2aWV3LlxuICogQHJldHVybnMge21hdDR9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUucHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVNYXRyaXgoKTtcbiAgcmV0dXJuIHRoaXMuX3Byb2pNYXRyaXg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSBjdXJyZW50IHZpZXcuXG4gKiBAcmV0dXJucyB7bWF0NH1cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5pbnZlcnNlUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVNYXRyaXgoKTtcbiAgcmV0dXJuIHRoaXMuX2ludlByb2pNYXRyaXg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZpZXcgbWF0cml4IGZvciB0aGUgY3VycmVudCB2aWV3LlxuICogQHJldHVybnMge21hdDR9XG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUudmlld01hdHJpeCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVNYXRyaXgoKTtcbiAgcmV0dXJuIHRoaXMuX3ZpZXdNYXRyaXg7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSB2aWV3IG1hdHJpeCBmb3IgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEByZXR1cm5zIHttYXQ0fVxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLmludmVyc2VWaWV3TWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZU1hdHJpeCgpO1xuICByZXR1cm4gdGhpcy5faW52Vmlld01hdHJpeDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciB0aGUgdmlldyBmcnVzdHVtIGludGVyc2VjdHMgdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1heSByZXR1cm4gZmFsc2UgcG9zaXRpdmVzLCBidXQgbmV2ZXIgZmFsc2UgbmVnYXRpdmVzLlxuICogSXQgaXMgdXNlZCBmb3IgZnJ1c3R1bSBjdWxsaW5nLCBpLmUuLCBleGNsdWRpbmcgaW52aXNpYmxlIHRpbGVzIGZyb20gdGhlXG4gKiByZW5kZXJpbmcgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzJbXX0gcmVjdGFuZ2xlIFRoZSB2ZXJ0aWNlcyBvZiB0aGUgcmVjdGFuZ2xlLlxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihyZWN0YW5nbGUpIHtcbiAgdGhpcy5fdXBkYXRlTWF0cml4KCk7XG5cbiAgdmFyIGZydXN0dW0gPSB0aGlzLl9mcnVzdHVtO1xuICB2YXIgdmVydGV4ID0gdGhpcy5fdG1wVmVjO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHJlY3RhbmdsZSBpcyBvbiB0aGUgb3V0ZXIgc2lkZSBvZiBhbnkgb2YgdGhlIGZydXN0dW1cbiAgLy8gcGxhbmVzLiBUaGlzIGlzIGEgc3VmZmljaWVudCBjb25kaXRpb24sIHRob3VnaCBub3QgbmVjZXNzYXJ5LCBmb3IgdGhlXG4gIC8vIHJlY3RhbmdsZSB0byBiZSBjb21wbGV0ZWx5IG91dHNpZGUgdGhlIGZydXN0dW0uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJ1c3R1bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFuZSA9IGZydXN0dW1baV07XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVjdGFuZ2xlLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgY29ybmVyID0gcmVjdGFuZ2xlW2pdO1xuICAgICAgdmVjNC5zZXQodmVydGV4LCBjb3JuZXJbMF0sIGNvcm5lclsxXSwgY29ybmVyWzJdLCAxLjApO1xuICAgICAgaWYgKHZlYzQuZG90KHBsYW5lLCB2ZXJ0ZXgpID49IDApIHtcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbnNpZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogU2VsZWN0IHRoZSBsZXZlbCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgdmlldy5cbiAqIEBwYXJhbSB7TGV2ZWxbXX0gbGV2ZWxMaXN0IHRoZSBsaXN0IG9mIGxldmVscyBmcm9tIHdoaWNoIHRvIHNlbGVjdC5cbiAqIEByZXR1cm4ge0xldmVsfSB0aGUgc2VsZWN0ZWQgbGV2ZWwuXG4gKi9cblJlY3RpbGluZWFyVmlldy5wcm90b3R5cGUuc2VsZWN0TGV2ZWwgPSBmdW5jdGlvbihsZXZlbExpc3QpIHtcblxuICAvLyBNdWx0aXBseSB0aGUgdmlld3BvcnQgd2lkdGggYnkgdGhlIGRldmljZSBwaXhlbCByYXRpbyB0byBnZXQgdGhlIHJlcXVpcmVkXG4gIC8vIGhvcml6b250YWwgcmVzb2x1dGlvbiBpbiBwaXhlbHMuXG4gIC8vXG4gIC8vIENhbGN1bGF0ZSB0aGUgZnJhY3Rpb24gb2YgYSBjdWJlIGZhY2UgdGhhdCB3b3VsZCBiZSB2aXNpYmxlIGdpdmVuIHRoZVxuICAvLyBjdXJyZW50IHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcuIFRoZW4sIGZvciBlYWNoIGxldmVsLCBtdWx0aXBseSBieSB0aGVcbiAgLy8gbGV2ZWwgaGVpZ2h0IHRvIGdldCB0aGUgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgcG9ydGlvbiB0aGF0IHdvdWxkIGJlXG4gIC8vIHZpc2libGUuXG4gIC8vXG4gIC8vIFNlYXJjaCBmb3IgdGhlIHNtYWxsZXN0IGxldmVsIHRoYXQgc2F0aWZpZXMgdGhlIHRoZSByZXF1aXJlZCBoZWlnaHQsXG4gIC8vIGZhbGxpbmcgYmFjayBvbiB0aGUgbGFyZ2VzdCBsZXZlbCBpZiBub25lIGRvLlxuXG4gIHZhciByZXF1aXJlZFBpeGVscyA9IHBpeGVsUmF0aW8oKSAqIHRoaXMuX2hlaWdodDtcbiAgdmFyIGNvdmVyRmFjdG9yID0gTWF0aC50YW4oMC41ICogdGhpcy5fZm92KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsTGlzdFtpXTtcbiAgICBpZiAoY292ZXJGYWN0b3IgKiBsZXZlbC5oZWlnaHQoKSA+PSByZXF1aXJlZFBpeGVscykge1xuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZXZlbExpc3RbbGV2ZWxMaXN0Lmxlbmd0aCAtIDFdO1xuXG59O1xuXG5cbi8qKlxuICogQ29udmVydCB2aWV3IHBhcmFtZXRlcnMgaW50byBzY3JlZW4gcG9zaXRpb24uIElmIGEgcmVzdWx0IGFyZ3VtZW50IGlzXG4gKiBwcm92aWRlZCwgaXQgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoIG9iamVjdCBpcyBmaWxsZWRcbiAqIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld0Nvb3Jkc30gY29vcmRzIFRoZSB2aWV3IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtDb29yZHM9fSByZXN1bHQgVGhlIHJlc3VsdCBhcmd1bWVudCBmb3IgdGhlIHNjcmVlbiBjb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0Nvb3Jkc31cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5jb29yZGluYXRlc1RvU2NyZWVuID0gZnVuY3Rpb24oY29vcmRzLCByZXN1bHQpIHtcbiAgdmFyIHJheSA9IHRoaXMuX3RtcFZlYztcblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9XG5cbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgLy8gVW5kZWZpbmVkIG9uIGEgbnVsbCB2aWV3cG9ydC5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICByZXN1bHQueCA9IG51bGw7XG4gICAgcmVzdWx0LnkgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB2aWV3IHJheSBwb2ludGluZyBpbnRvIHRoZSAoeWF3LCBwaXRjaCkgZGlyZWN0aW9uLlxuICB2YXIgeWF3ID0gY29vcmRzLnlhdztcbiAgdmFyIHBpdGNoID0gY29vcmRzLnBpdGNoO1xuICB2YXIgeCA9IE1hdGguc2luKHlhdykgKiBNYXRoLmNvcyhwaXRjaCk7XG4gIHZhciB5ID0gLU1hdGguc2luKHBpdGNoKTtcbiAgdmFyIHogPSAtTWF0aC5jb3MoeWF3KSAqIE1hdGguY29zKHBpdGNoKTtcbiAgdmVjNC5zZXQocmF5LCB4LCB5LCB6LCAxKTtcblxuICAvLyBQcm9qZWN0IHZpZXcgcmF5IG9udG8gY2xpcCBzcGFjZS5cbiAgdmVjNC50cmFuc2Zvcm1NYXQ0KHJheSwgcmF5LCB0aGlzLnByb2plY3Rpb24oKSk7XG5cbiAgLy8gdyBpbiBjbGlwIHNwYWNlIGVxdWFscyAteiBpbiBjYW1lcmEgc3BhY2UuXG4gIGlmIChyYXlbM10gPj0gMCkge1xuICAgIC8vIFBvaW50IGlzIGluIGZyb250IG9mIGNhbWVyYS5cbiAgICAvLyBDb252ZXJ0IHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzLlxuICAgIHJlc3VsdC54ID0gd2lkdGggKiAocmF5WzBdIC8gcmF5WzNdICsgMSkgLyAyO1xuICAgIHJlc3VsdC55ID0gaGVpZ2h0ICogKDEgLSByYXlbMV0gLyByYXlbM10pIC8gMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBQb2ludCBpcyBiZWhpbmQgY2FtZXJhLlxuICAgIHJlc3VsdC54ID0gbnVsbDtcbiAgICByZXN1bHQueSA9IG51bGw7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIENvbnZlcnQgc2NyZWVuIGNvb3JkaW5hdGVzIGludG8gdmlldyBjb29yZGluYXRlcy4gSWYgYSByZXN1bHQgYXJndW1lbnQgaXNcbiAqIHByb3ZpZGVkLCBpdCBpcyBmaWxsZWQgaW4gd2l0aCB0aGUgcmVzdWx0IGFuZCByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIGZyZXNoXG4gKiBvYmplY3QgaXMgZmlsbGVkIGluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge0Nvb3Jkc30gY29vcmRzIFRoZSBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge1JlY3RpbGluZWFyVmlld0Nvb3Jkcz19IHJlc3VsdCBUaGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0Nvb3Jkc31cbiAqL1xuUmVjdGlsaW5lYXJWaWV3LnByb3RvdHlwZS5zY3JlZW5Ub0Nvb3JkaW5hdGVzID0gZnVuY3Rpb24oY29vcmRzLCByZXN1bHQpIHtcbiAgdmFyIHJheSA9IHRoaXMuX3RtcFZlYztcblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9XG5cbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgLy8gQ29udmVydCB2aWV3cG9ydCBjb29yZGluYXRlcyB0byBjbGlwIHNwYWNlLlxuICB2YXIgdmVjeCA9IDIgKiBjb29yZHMueCAvIHdpZHRoIC0gMTtcbiAgdmFyIHZlY3kgPSAxIC0gMiAqIGNvb3Jkcy55IC8gaGVpZ2h0O1xuICB2ZWM0LnNldChyYXksIHZlY3gsIHZlY3ksIDEsIDEpO1xuXG4gIC8vIFByb2plY3QgYmFjayB0byB3b3JsZCBzcGFjZS5cbiAgdmVjNC50cmFuc2Zvcm1NYXQ0KHJheSwgcmF5LCB0aGlzLmludmVyc2VQcm9qZWN0aW9uKCkpO1xuXG4gIC8vIENvbnZlcnQgdG8gc3BoZXJpY2FsIGNvb3JkaW5hdGVzLlxuICB2YXIgciA9IE1hdGguc3FydChyYXlbMF0gKiByYXlbMF0gKyByYXlbMV0gKiByYXlbMV0gKyByYXlbMl0gKiByYXlbMl0pO1xuICByZXN1bHQueWF3ID0gTWF0aC5hdGFuMihyYXlbMF0sIC1yYXlbMl0pO1xuICByZXN1bHQucGl0Y2ggPSBNYXRoLmFjb3MocmF5WzFdIC8gcikgLSBNYXRoLlBJLzI7XG5cbiAgdGhpcy5fbm9ybWFsaXplQ29vcmRpbmF0ZXMocmVzdWx0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcGVyc3BlY3RpdmUgdHJhbnNmb3JtIHJlcXVpcmVkIHRvIHBvc2l0aW9uIGFuIGVsZW1lbnQgd2l0aFxuICogcGVyc3BlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtSZWN0aWxpbmVhclZpZXdDb29yZHN9IGNvb3JkcyBUaGUgdmlldyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSBzcGhlcmUgZW1iZWRkaW5nIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV4dHJhVHJhbnNmb3JtcyBFeHRyYSB0cmFuc2Zvcm1hdGlvbnMgdG8gYmUgYXBwbGllZCBhZnRlclxuICogICAgIHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQuIFRoaXMgbWF5IGJlIHVzZWQgdG8gcm90YXRlIHRoZSBlbGVtZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgQ1NTIDNEIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuICovXG5SZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLmNvb3JkaW5hdGVzVG9QZXJzcGVjdGl2ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uKFxuICAgIGNvb3JkcywgcmFkaXVzLCBleHRyYVRyYW5zZm9ybXMpIHtcbiAgZXh0cmFUcmFuc2Zvcm1zID0gZXh0cmFUcmFuc2Zvcm1zIHx8IFwiXCI7XG5cbiAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBmb3YgPSB0aGlzLl9mb3Y7XG4gIHZhciBwZXJzcGVjdGl2ZSA9IDAuNSAqIGhlaWdodCAvIE1hdGgudGFuKGZvdiAvIDIpO1xuXG4gIHZhciB0cmFuc2Zvcm0gPSAnJztcblxuICAvLyBDZW50ZXIgaG90c3BvdCBpbiBzY3JlZW4uXG4gIHRyYW5zZm9ybSArPSAndHJhbnNsYXRlWCgnICsgZGVjaW1hbCh3aWR0aC8yKSArICdweCkgJztcbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVZKCcgKyBkZWNpbWFsKGhlaWdodC8yKSArICdweCkgJztcbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgJztcblxuICAvLyBTZXQgdGhlIHBlcnNwZWN0aXZlIGRlcHRoLlxuICB0cmFuc2Zvcm0gKz0gJ3BlcnNwZWN0aXZlKCcgKyBkZWNpbWFsKHBlcnNwZWN0aXZlKSArICdweCkgJztcbiAgdHJhbnNmb3JtICs9ICd0cmFuc2xhdGVaKCcgKyBkZWNpbWFsKHBlcnNwZWN0aXZlKSArICdweCkgJztcblxuICAvLyBTZXQgdGhlIGNhbWVyYSByb3RhdGlvbi5cbiAgdHJhbnNmb3JtICs9ICdyb3RhdGVaKCcgKyBkZWNpbWFsKC10aGlzLl9yb2xsKSArICdyYWQpICc7XG4gIHRyYW5zZm9ybSArPSAncm90YXRlWCgnICsgZGVjaW1hbCgtdGhpcy5fcGl0Y2gpICsgJ3JhZCkgJztcbiAgdHJhbnNmb3JtICs9ICdyb3RhdGVZKCcgKyBkZWNpbWFsKHRoaXMuX3lhdykgKyAncmFkKSAnO1xuXG4gIC8vIFNldCB0aGUgaG90c3BvdCByb3RhdGlvbi5cbiAgdHJhbnNmb3JtICs9ICdyb3RhdGVZKCcgKyBkZWNpbWFsKC1jb29yZHMueWF3KSArICdyYWQpICc7XG4gIHRyYW5zZm9ybSArPSAncm90YXRlWCgnICsgZGVjaW1hbChjb29yZHMucGl0Y2gpICsgJ3JhZCkgJztcblxuICAvLyBNb3ZlIGJhY2sgdG8gc3BoZXJlLlxuICB0cmFuc2Zvcm0gKz0gJ3RyYW5zbGF0ZVooJyArIGRlY2ltYWwoLXJhZGl1cykgKyAncHgpICc7XG5cbiAgLy8gQXBwbHkgdGhlIGV4dHJhIHRyYW5zZm9ybWF0aW9uc1xuICB0cmFuc2Zvcm0gKz0gZXh0cmFUcmFuc2Zvcm1zICsgJyAnO1xuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59O1xuXG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbnMgZm9yIHZpZXcgbGltaXRlcnMuIFNlZSB7QGxpbmsgUmVjdGlsaW5lYXJWaWV3TGltaXRlcn0uXG4gKiBAbmFtZXNwYWNlXG4gKi9cblJlY3RpbGluZWFyVmlldy5saW1pdCA9IHtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIHlhdyBhbmdsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB5YXcgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0geWF3IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgeWF3OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFlhdyhwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy55YXcgPSBjbGFtcChwYXJhbXMueWF3LCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBjb25zdHJhaW5zIHRoZSBwaXRjaCBhbmdsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBwaXRjaCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwaXRjaCB2YWx1ZS5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIHBpdGNoOiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFBpdGNoKHBhcmFtcykge1xuICAgICAgcGFyYW1zLnBpdGNoID0gY2xhbXAocGFyYW1zLnBpdGNoLCBtaW4sIG1heCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBjb25zdHJhaW5zIHRoZSByb2xsIGFuZ2xlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHJvbGwgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gcm9sbCB2YWx1ZS5cbiAgICogQHJldHVybiB7UmVjdGlsaW5lYXJWaWV3TGltaXRlcn1cbiAgICovXG4gIHJvbGw6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0Um9sbChwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5yb2xsID0gY2xhbXAocGFyYW1zLnJvbGwsIG1pbiwgbWF4KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZpZXcgbGltaXRlciB0aGF0IGNvbnN0cmFpbnMgdGhlIGhvcml6b250YWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBob3Jpem9udGFsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgaGZvdjogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGltaXRIZm92KHBhcmFtcykge1xuICAgICAgdmFyIHdpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcbiAgICAgICAgdmFyIHZtaW4gPSBjb252ZXJ0Rm92Lmh0b3YobWluLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIHZtYXggPSBjb252ZXJ0Rm92Lmh0b3YobWF4LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcGFyYW1zLmZvdiA9IGNsYW1wKHBhcmFtcy5mb3YsIHZtaW4sIHZtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgY29uc3RyYWlucyB0aGUgdmVydGljYWwgZmllbGQgb2Ygdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICB2Zm92OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFZmb3YocGFyYW1zKSB7XG4gICAgICBwYXJhbXMuZm92ID0gY2xhbXAocGFyYW1zLmZvdiwgbWluLCBtYXgpO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmlldyBsaW1pdGVyIHRoYXQgcHJldmVudHMgem9vbWluZyBpbiBiZXlvbmQgdGhlIGdpdmVuXG4gICAqIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoZSBjdWJlIGZhY2Ugd2lkdGggaW4gcGl4ZWxzIG9yLCBlcXVpdmFsZW50bHksIG9uZVxuICAgKiAgICAgZm91cnRoIG9mIHRoZSBlcXVpcmVjdGFuZ3VsYXIgd2lkdGggaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtSZWN0aWxpbmVhclZpZXdMaW1pdGVyfVxuICAgKi9cbiAgcmVzb2x1dGlvbjogZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW1pdFJlc29sdXRpb24ocGFyYW1zKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgdmFyIHJlcXVpcmVkUGl4ZWxzID0gcGl4ZWxSYXRpbygpICogaGVpZ2h0O1xuICAgICAgICB2YXIgbWluRm92ID0gMiAqIE1hdGguYXRhbihyZXF1aXJlZFBpeGVscyAvIHNpemUpO1xuICAgICAgICBwYXJhbXMuZm92ID0gY2xhbXAocGFyYW1zLmZvdiwgbWluRm92LCBJbmZpbml0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2aWV3IGxpbWl0ZXIgdGhhdCBsaW1pdHMgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGZpZWxkIG9mXG4gICAqIHZpZXcsIHByZXZlbnRzIHpvb21pbmcgaW4gcGFzdCB0aGUgaW1hZ2UgcmVzb2x1dGlvbiwgYW5kIGxpbWl0cyB0aGUgcGl0Y2hcbiAgICogcmFuZ2UgdG8gcHJldmVudCB0aGUgY2FtZXJhIHdyYXBwaW5nIGFyb3VuZCBhdCB0aGUgcG9sZXMuIFRoZXNlIGFyZSB0aGVcbiAgICogbW9zdCBjb21tb24gdmlldyBjb25zdHJhaW50cyBmb3IgYSAzNjDCsCBwYW5vcmFtYS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gVGhlIGN1YmUgZmFjZSB3aWR0aCBpbiBwaXhlbHMgb3IsXG4gICAqICAgICBlcXVpdmFsZW50bHksIG9uZSBmb3VydGggb2YgdGhlIGVxdWlyZWN0YW5ndWxhciB3aWR0aCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhWRm92IFRoZSBtYXhpbXVtIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4SEZvdj1tYXhWRm92XSBUaGUgbWF4aW11bSBob3Jpem9udGFsIGZpZWxkIG9mIHZpZXcuXG4gICAqIEByZXR1cm4ge1JlY3RpbGluZWFyVmlld0xpbWl0ZXJ9XG4gICAqL1xuICB0cmFkaXRpb25hbDogZnVuY3Rpb24obWF4UmVzb2x1dGlvbiwgbWF4VkZvdiwgbWF4SEZvdikge1xuICAgIG1heEhGb3YgPSBtYXhIRm92ICE9IG51bGwgPyBtYXhIRm92IDogbWF4VkZvdjtcblxuICAgIHJldHVybiBjb21wb3NlKFxuICAgICAgUmVjdGlsaW5lYXJWaWV3LmxpbWl0LnJlc29sdXRpb24obWF4UmVzb2x1dGlvbiksXG4gICAgICBSZWN0aWxpbmVhclZpZXcubGltaXQudmZvdigwLCBtYXhWRm92KSxcbiAgICAgIFJlY3RpbGluZWFyVmlldy5saW1pdC5oZm92KDAsIG1heEhGb3YpLFxuICAgICAgUmVjdGlsaW5lYXJWaWV3LmxpbWl0LnBpdGNoKC1NYXRoLlBJLzIsIE1hdGguUEkvMikpO1xuICB9XG5cbn07XG5cblxuUmVjdGlsaW5lYXJWaWV3LnR5cGUgPSBSZWN0aWxpbmVhclZpZXcucHJvdG90eXBlLnR5cGUgPSAncmVjdGlsaW5lYXInO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVjdGlsaW5lYXJWaWV3O1xuIl19
